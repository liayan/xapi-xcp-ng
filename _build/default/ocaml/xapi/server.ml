open API
open Server_helpers

module Make = functor(Custom : Custom_actions.CUSTOM_ACTIONS) -> functor(Forward : Custom_actions.CUSTOM_ACTIONS) ->struct

  module D = Debug.Make(struct let name = "dispatcher" end)
  module ApiLogRead = Debug.Make(struct let name = "api_readonly" end)
  module ApiLogSideEffect = Debug.Make(struct let name = "api_effect" end)
  (**  *)
  let dispatch_call (http_req: Http.Request.t) (fd: Unix.file_descr) (call: Rpc.call) =
    let __call, __params = call.Rpc.name, call.Rpc.params in
    List.iter (fun p -> let s = Rpc.to_string p in if not (Xapi_stdext_encodings.Encodings.UTF8_XML.is_valid s) then
    raise (Api_errors.Server_error(Api_errors.invalid_value, ["Invalid UTF-8 string in parameter"; s])))  __params;
    let __label = __call in
    let (__sync_ty, __call) = Server_helpers.sync_ty_and_maybe_remove_prefix __call in
    let subtask_of = if http_req.Http.Request.task <> None then http_req.Http.Request.task else http_req.Http.Request.subtask_of in
    let http_other_config = Context.get_http_other_config http_req in
    Server_helpers.exec_with_new_task ("dispatch:"^__call^"") ~http_other_config ?subtask_of:(Option.map Ref.of_string subtask_of) (fun __context ->
    Server_helpers.dispatch_exn_wrapper (fun () -> (match __call with 
    | "session.get_record" | "session_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_session_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_by_uuid" | "session_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_session x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_uuid" | "session_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_this_host" | "session_get_this_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_this_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_this_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_this_user" | "session_get_this_user" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_user x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_this_user ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_this_user";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_last_active" | "session_get_last_active" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_last_active ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_last_active";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_pool" | "session_get_pool" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_pool ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_pool";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_other_config" | "session_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_is_local_superuser" | "session_get_is_local_superuser" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_is_local_superuser ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_is_local_superuser";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_subject" | "session_get_subject" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_subject x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_subject ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_subject";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_validation_time" | "session_get_validation_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_validation_time ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_validation_time";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_auth_user_sid" | "session_get_auth_user_sid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_auth_user_sid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_auth_user_sid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_auth_user_name" | "session_get_auth_user_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_auth_user_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_auth_user_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_rbac_permissions" | "session_get_rbac_permissions" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_rbac_permissions ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_rbac_permissions";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_tasks" | "session_get_tasks" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_task_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_tasks ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_tasks";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_parent" | "session_get_parent" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_session x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_parent ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_parent";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_originator" | "session_get_originator" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.get_originator ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "session.get_originator";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.set_other_config" | "session_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "session.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "session.add_to_other_config" | "session_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "session.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "session.remove_from_other_config" | "session_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_session_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Session.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "session.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "session.login_with_password" | "session_login_with_password" -> 
        begin match __params with
        | uname_rpc :: pwd_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let version_rpc = try List.nth default_args 0 with _ -> Rpc.String "1.1" in
            let originator_rpc = try List.nth default_args 1 with _ -> Rpc.String "" in
            let uname = string_of_rpc uname_rpc in
            let pwd = string_of_rpc pwd_rpc in
            let version = string_of_rpc version_rpc in
            let originator = string_of_rpc originator_rpc in
            let rbac __context fn = fn () in
            let marshaller = (fun x -> rpc_of_ref_session x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Session.login_with_password ~__context:(Context.check_for_foreign_database ~__context)  ~uname ~pwd ~version ~originator))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Session.login_with_password ~__context:(Context.check_for_foreign_database ~__context)  ~uname ~pwd ~version ~originator) )) in
            let resp = Server_helpers.do_dispatch  ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 0))
        end
    | "session.logout" | "session_logout" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Session.logout ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Session.logout ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "session.change_password" | "session_change_password" -> 
        begin match __params with
        | [session_id_rpc; old_pwd_rpc; new_pwd_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let old_pwd = string_of_rpc old_pwd_rpc in
            let new_pwd = string_of_rpc new_pwd_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("old_pwd", old_pwd_rpc); ("new_pwd", new_pwd_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Session.change_password ~__context:(Context.check_for_foreign_database ~__context)  ~old_pwd ~new_pwd))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Session.change_password ~__context:(Context.check_for_foreign_database ~__context)  ~old_pwd ~new_pwd) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "session.slave_login" | "session_slave_login" -> 
        begin match __params with
        | [host_rpc; psecret_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let host = ref_host_of_rpc host_rpc in
            let psecret = secretstring_of_rpc psecret_rpc in
            let rbac __context fn = fn () in
            let marshaller = (fun x -> rpc_of_ref_session x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Session.slave_login ~__context:(Context.check_for_foreign_database ~__context)  ~host ~psecret))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Session.slave_login ~__context:(Context.check_for_foreign_database ~__context)  ~host ~psecret) )) in
            let resp = Server_helpers.do_dispatch  ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 0))
        end
    | "session.slave_local_login" | "session_slave_local_login" -> 
        begin match __params with
        | [psecret_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let psecret = secretstring_of_rpc psecret_rpc in
            let rbac __context fn = fn () in
            let marshaller = (fun x -> rpc_of_ref_session x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Session.slave_local_login ~__context:(Context.check_for_foreign_database ~__context)  ~psecret))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Session.slave_local_login ~__context:(Context.check_for_foreign_database ~__context)  ~psecret) )) in
            let resp = Server_helpers.do_dispatch  ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 0))
        end
    | "session.slave_local_login_with_password" | "session_slave_local_login_with_password" -> 
        begin match __params with
        | [uname_rpc; pwd_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let uname = string_of_rpc uname_rpc in
            let pwd = string_of_rpc pwd_rpc in
            let rbac __context fn = fn () in
            let marshaller = (fun x -> rpc_of_ref_session x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Session.slave_local_login_with_password ~__context:(Context.check_for_foreign_database ~__context)  ~uname ~pwd))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Session.slave_local_login_with_password ~__context:(Context.check_for_foreign_database ~__context)  ~uname ~pwd) )) in
            let resp = Server_helpers.do_dispatch  ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 0))
        end
    | "session.create_from_db_file" | "session_create_from_db_file" -> 
        begin match __params with
        | [session_id_rpc; filename_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let filename = string_of_rpc filename_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("filename", filename_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_session x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Session.create_from_db_file ~__context:(Context.check_for_foreign_database ~__context)  ~filename))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Session.create_from_db_file ~__context:(Context.check_for_foreign_database ~__context)  ~filename) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "session.local_logout" | "session_local_logout" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Session.local_logout ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Session.local_logout ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "session.get_all_subject_identifiers" | "session_get_all_subject_identifiers" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Session.get_all_subject_identifiers ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Session.get_all_subject_identifiers ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "session.logout_subject_identifier" | "session_logout_subject_identifier" -> 
        begin match __params with
        | [session_id_rpc; subject_identifier_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let subject_identifier = string_of_rpc subject_identifier_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("subject_identifier", subject_identifier_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Session.logout_subject_identifier ~__context:(Context.check_for_foreign_database ~__context)  ~subject_identifier))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Session.logout_subject_identifier ~__context:(Context.check_for_foreign_database ~__context)  ~subject_identifier) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "auth.get_subject_identifier" | "auth_get_subject_identifier" -> 
        begin match __params with
        | [session_id_rpc; subject_name_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let subject_name = string_of_rpc subject_name_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("subject_name", subject_name_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Auth.get_subject_identifier ~__context:(Context.check_for_foreign_database ~__context)  ~subject_name))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Auth.get_subject_identifier ~__context:(Context.check_for_foreign_database ~__context)  ~subject_name) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "auth.get_subject_information_from_identifier" | "auth_get_subject_information_from_identifier" -> 
        begin match __params with
        | [session_id_rpc; subject_identifier_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let subject_identifier = string_of_rpc subject_identifier_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("subject_identifier", subject_identifier_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Auth.get_subject_information_from_identifier ~__context:(Context.check_for_foreign_database ~__context)  ~subject_identifier))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Auth.get_subject_information_from_identifier ~__context:(Context.check_for_foreign_database ~__context)  ~subject_identifier) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "auth.get_group_membership" | "auth_get_group_membership" -> 
        begin match __params with
        | [session_id_rpc; subject_identifier_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let subject_identifier = string_of_rpc subject_identifier_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("subject_identifier", subject_identifier_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Auth.get_group_membership ~__context:(Context.check_for_foreign_database ~__context)  ~subject_identifier))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Auth.get_group_membership ~__context:(Context.check_for_foreign_database ~__context)  ~subject_identifier) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "subject.get_record" | "subject_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_subject_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_subject_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Subject.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "subject.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "subject.get_by_uuid" | "subject_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_subject x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Subject.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "subject.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "subject.create" | "subject_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let subject_identifier = string_of_rpc ((List.assoc_opt "subject_identifier" __structure) |> Option.value ~default:(Rpc.String "")) in
            let other_config = string_to_string_map_of_rpc ((List.assoc_opt "other_config" __structure) |> Option.value ~default:(Rpc.Dict [])) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_subject x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Subject.create ~__context:(Context.check_for_foreign_database ~__context)  ~subject_identifier ~other_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Subject.create ~__context:(Context.check_for_foreign_database ~__context)  ~subject_identifier ~other_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "subject.destroy" | "subject_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_subject_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Subject.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Subject.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "subject.get_uuid" | "subject_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_subject_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Subject.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "subject.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "subject.get_subject_identifier" | "subject_get_subject_identifier" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_subject_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Subject.get_subject_identifier ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "subject.get_subject_identifier";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "subject.get_other_config" | "subject_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_subject_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Subject.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "subject.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "subject.get_roles" | "subject_get_roles" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_subject_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_role_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Subject.get_roles ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "subject.get_roles";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "subject.add_to_roles" | "subject_add_to_roles" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; role_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_subject_of_rpc self_rpc in
            let role = ref_role_of_rpc role_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("role", role_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Subject.add_to_roles ~__context:(Context.check_for_foreign_database ~__context)  ~self ~role))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Subject.add_to_roles ~__context:(Context.check_for_foreign_database ~__context)  ~self ~role) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "subject.remove_from_roles" | "subject_remove_from_roles" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; role_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_subject_of_rpc self_rpc in
            let role = ref_role_of_rpc role_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("role", role_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Subject.remove_from_roles ~__context:(Context.check_for_foreign_database ~__context)  ~self ~role))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Subject.remove_from_roles ~__context:(Context.check_for_foreign_database ~__context)  ~self ~role) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "subject.get_permissions_name_label" | "subject_get_permissions_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_subject_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Subject.get_permissions_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Subject.get_permissions_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "subject.get_all" | "subject_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_subject_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Subject.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "subject.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "subject.get_all_records_where" | "subject_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_subject_to_subject_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Subject.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "subject.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "subject.get_all_records" | "subject_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_subject_to_subject_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Subject.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "subject.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_record" | "role_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_role_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_role_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_by_uuid" | "role_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_role x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_by_name_label" | "role_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_role_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_uuid" | "role_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_role_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_name_label" | "role_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_role_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_name_description" | "role_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_role_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_subroles" | "role_get_subroles" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_role_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_role_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_subroles ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_subroles ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_permissions" | "role_get_permissions" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_role_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_role_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_permissions ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_permissions ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_permissions_name_label" | "role_get_permissions_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_role_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_permissions_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_permissions_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_by_permission" | "role_get_by_permission" -> 
        begin match __params with
        | [session_id_rpc; permission_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let permission = ref_role_of_rpc permission_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("permission", permission_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_role_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_by_permission ~__context:(Context.check_for_foreign_database ~__context)  ~permission))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_by_permission ~__context:(Context.check_for_foreign_database ~__context)  ~permission) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_by_permission_name_label" | "role_get_by_permission_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_role_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_by_permission_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_by_permission_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_all" | "role_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_role_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_all ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_all_records_where" | "role_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_role_to_role_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "role.get_all_records" | "role_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_role_to_role_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Role.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Role.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_record" | "task_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_task_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_by_uuid" | "task_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_task x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_by_name_label" | "task_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_task_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_uuid" | "task_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_name_label" | "task_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_name_description" | "task_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_allowed_operations" | "task_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_task_allowed_operations_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_current_operations" | "task_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_task_allowed_operations_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_created" | "task_get_created" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_created ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_created";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_finished" | "task_get_finished" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_finished ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_finished";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_status" | "task_get_status" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_task_status_type x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_status ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_status";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_resident_on" | "task_get_resident_on" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_resident_on ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_resident_on";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_progress" | "task_get_progress" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_float x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_progress ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_progress";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_type" | "task_get_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_result" | "task_get_result" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_result ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_result";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_error_info" | "task_get_error_info" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_error_info ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_error_info";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_other_config" | "task_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_subtask_of" | "task_get_subtask_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_task x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_subtask_of ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_subtask_of";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_subtasks" | "task_get_subtasks" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_task_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_subtasks ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_subtasks";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_backtrace" | "task_get_backtrace" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_backtrace ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_backtrace";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.set_other_config" | "task_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogSideEffect.debug "task.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "task.add_to_other_config" | "task_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = ["applies_to"; "XenCenterUUID"; "XenCenterMeddlingActionTitle"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogSideEffect.debug "task.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "task.remove_from_other_config" | "task_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = ["applies_to"; "XenCenterUUID"; "XenCenterMeddlingActionTitle"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogSideEffect.debug "task.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "task.create" | "task_create" -> 
        begin match __params with
        | [session_id_rpc; label_rpc; description_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            let description = string_of_rpc description_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc); ("description", description_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_task x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Task.create ~__context:(Context.check_for_foreign_database ~__context)  ~label ~description))) in
            let supports_async = false in
            let generate_task_for = false in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Task.create ~__context:(Context.check_for_foreign_database ~__context)  ~label ~description) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "task.destroy" | "task_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Task.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = false in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Task.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.cancel" | "task_cancel" -> 
        begin match __params with
        | [session_id_rpc; task_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let task = ref_task_of_rpc task_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("task", task_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Task.cancel ~__context:(Context.check_for_foreign_database ~__context)  ~task))) in
            let supports_async = true in
            let generate_task_for = false in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Task.cancel ~__context:(Context.check_for_foreign_database ~__context)  ~task) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.set_status" | "task_set_status" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            let value = task_status_type_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Task.set_status ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = false in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Task.set_status ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "task.set_progress" | "task_set_progress" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_task_of_rpc self_rpc in
            let value = float_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Task.set_progress ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = false in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Task.set_progress ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_all" | "task_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_task_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_all_records_where" | "task_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_task_to_task_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "task.get_all_records" | "task_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_task_to_task_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Task.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = false in
            ApiLogRead.debug "task.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "event.register" | "event_register" -> 
        begin match __params with
        | [session_id_rpc; classes_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let classes = string_set_of_rpc classes_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("classes", classes_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Event.register ~__context:(Context.check_for_foreign_database ~__context)  ~classes))) in
            let supports_async = true in
            let generate_task_for = false in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Event.register ~__context:(Context.check_for_foreign_database ~__context)  ~classes) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "event.unregister" | "event_unregister" -> 
        begin match __params with
        | [session_id_rpc; classes_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let classes = string_set_of_rpc classes_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("classes", classes_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Event.unregister ~__context:(Context.check_for_foreign_database ~__context)  ~classes))) in
            let supports_async = true in
            let generate_task_for = false in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Event.unregister ~__context:(Context.check_for_foreign_database ~__context)  ~classes) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "event.next" | "event_next" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Event.next ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = false in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Event.next ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "event.from" | "event_from" -> 
        begin match __params with
        | [session_id_rpc; classes_rpc; token_rpc; timeout_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let classes = string_set_of_rpc classes_rpc in
            let token = string_of_rpc token_rpc in
            let timeout = float_of_rpc timeout_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("classes", classes_rpc); ("token", token_rpc); ("timeout", timeout_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Event.from ~__context:(Context.check_for_foreign_database ~__context)  ~classes ~token ~timeout))) in
            let supports_async = false in
            let generate_task_for = false in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Event.from ~__context:(Context.check_for_foreign_database ~__context)  ~classes ~token ~timeout) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "event.get_current_id" | "event_get_current_id" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Event.get_current_id ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = false in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Event.get_current_id ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "event.inject" | "event_inject" -> 
        begin match __params with
        | [session_id_rpc; _class_rpc; _ref_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let _class = string_of_rpc _class_rpc in
            let _ref = string_of_rpc _ref_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("_class", _class_rpc); ("_ref", _ref_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Event.inject ~__context:(Context.check_for_foreign_database ~__context)  ~_class ~_ref))) in
            let supports_async = false in
            let generate_task_for = false in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Event.inject ~__context:(Context.check_for_foreign_database ~__context)  ~_class ~_ref) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_record" | "pool_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pool_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_by_uuid" | "pool_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_uuid" | "pool_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_name_label" | "pool_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_name_description" | "pool_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_master" | "pool_get_master" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_master ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_master";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_default_SR" | "pool_get_default_SR" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_default_SR ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_default_SR";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_suspend_image_SR" | "pool_get_suspend_image_SR" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_suspend_image_SR ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_suspend_image_SR";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_crash_dump_SR" | "pool_get_crash_dump_SR" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_crash_dump_SR ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_crash_dump_SR";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_other_config" | "pool_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_ha_enabled" | "pool_get_ha_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_ha_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_ha_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_ha_configuration" | "pool_get_ha_configuration" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_ha_configuration ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_ha_configuration";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_ha_statefiles" | "pool_get_ha_statefiles" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_ha_statefiles ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_ha_statefiles";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_ha_host_failures_to_tolerate" | "pool_get_ha_host_failures_to_tolerate" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_ha_host_failures_to_tolerate ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_ha_host_failures_to_tolerate";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_ha_plan_exists_for" | "pool_get_ha_plan_exists_for" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_ha_plan_exists_for ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_ha_plan_exists_for";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_ha_allow_overcommit" | "pool_get_ha_allow_overcommit" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_ha_allow_overcommit ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_ha_allow_overcommit";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_ha_overcommitted" | "pool_get_ha_overcommitted" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_ha_overcommitted ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_ha_overcommitted";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_blobs" | "pool_get_blobs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_ref_blob_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_blobs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_blobs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_tags" | "pool_get_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_gui_config" | "pool_get_gui_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_gui_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_gui_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_health_check_config" | "pool_get_health_check_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_health_check_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_health_check_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_wlb_url" | "pool_get_wlb_url" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_wlb_url ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_wlb_url";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_wlb_username" | "pool_get_wlb_username" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_wlb_username ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_wlb_username";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_wlb_enabled" | "pool_get_wlb_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_wlb_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_wlb_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_wlb_verify_cert" | "pool_get_wlb_verify_cert" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_wlb_verify_cert ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_wlb_verify_cert";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_redo_log_enabled" | "pool_get_redo_log_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_redo_log_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_redo_log_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_redo_log_vdi" | "pool_get_redo_log_vdi" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_redo_log_vdi ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_redo_log_vdi";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_vswitch_controller" | "pool_get_vswitch_controller" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_vswitch_controller ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_vswitch_controller";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_restrictions" | "pool_get_restrictions" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_restrictions ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_restrictions";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_metadata_VDIs" | "pool_get_metadata_VDIs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_metadata_VDIs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_metadata_VDIs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_ha_cluster_stack" | "pool_get_ha_cluster_stack" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_ha_cluster_stack ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_ha_cluster_stack";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_allowed_operations" | "pool_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pool_allowed_operations_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_current_operations" | "pool_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_pool_allowed_operations_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_guest_agent_config" | "pool_get_guest_agent_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_guest_agent_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_guest_agent_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_cpu_info" | "pool_get_cpu_info" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_cpu_info ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_cpu_info";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_policy_no_vendor_device" | "pool_get_policy_no_vendor_device" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_policy_no_vendor_device ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_policy_no_vendor_device";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_live_patching_disabled" | "pool_get_live_patching_disabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_live_patching_disabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_live_patching_disabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_igmp_snooping_enabled" | "pool_get_igmp_snooping_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_igmp_snooping_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_igmp_snooping_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_uefi_certificates" | "pool_get_uefi_certificates" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_uefi_certificates ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_uefi_certificates";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_is_psr_pending" | "pool_get_is_psr_pending" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_is_psr_pending ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_is_psr_pending";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_name_label" | "pool_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_name_description" | "pool_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_default_SR" | "pool_set_default_SR" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = ref_SR_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_default_SR ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_default_SR";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_suspend_image_SR" | "pool_set_suspend_image_SR" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = ref_SR_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_suspend_image_SR ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_suspend_image_SR";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_crash_dump_SR" | "pool_set_crash_dump_SR" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = ref_SR_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_crash_dump_SR ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_crash_dump_SR";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_other_config" | "pool_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.add_to_other_config" | "pool_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = ["folder"; "XenCenter.CustomFields.*"; "EMPTY_FOLDERS"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool.remove_from_other_config" | "pool_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = ["folder"; "XenCenter.CustomFields.*"; "EMPTY_FOLDERS"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_ha_allow_overcommit" | "pool_set_ha_allow_overcommit" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_ha_allow_overcommit ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_ha_allow_overcommit";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_tags" | "pool_set_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = string_set_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.add_tags" | "pool_add_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.add_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.add_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.remove_tags" | "pool_remove_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.remove_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.remove_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_gui_config" | "pool_set_gui_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_gui_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_gui_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.add_to_gui_config" | "pool_add_to_gui_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.add_to_gui_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.add_to_gui_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool.remove_from_gui_config" | "pool_remove_from_gui_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.remove_from_gui_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.remove_from_gui_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_health_check_config" | "pool_set_health_check_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_health_check_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_health_check_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.add_to_health_check_config" | "pool_add_to_health_check_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.add_to_health_check_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.add_to_health_check_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool.remove_from_health_check_config" | "pool_remove_from_health_check_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.remove_from_health_check_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.remove_from_health_check_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_wlb_enabled" | "pool_set_wlb_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_wlb_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_wlb_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_wlb_verify_cert" | "pool_set_wlb_verify_cert" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_wlb_verify_cert ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_wlb_verify_cert";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_policy_no_vendor_device" | "pool_set_policy_no_vendor_device" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_policy_no_vendor_device ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_policy_no_vendor_device";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_live_patching_disabled" | "pool_set_live_patching_disabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_live_patching_disabled ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_live_patching_disabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_uefi_certificates" | "pool_set_uefi_certificates" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_uefi_certificates ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_uefi_certificates";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_is_psr_pending" | "pool_set_is_psr_pending" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.set_is_psr_pending ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool.set_is_psr_pending";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.join" | "pool_join" -> 
        begin match __params with
        | [session_id_rpc; master_address_rpc; master_username_rpc; master_password_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let master_address = string_of_rpc master_address_rpc in
            let master_username = string_of_rpc master_username_rpc in
            let master_password = string_of_rpc master_password_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("master_address", master_address_rpc); ("master_username", master_username_rpc); ("master_password", master_password_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.join ~__context:(Context.check_for_foreign_database ~__context)  ~master_address ~master_username ~master_password))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.join ~__context:(Context.check_for_foreign_database ~__context)  ~master_address ~master_username ~master_password) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool.join_force" | "pool_join_force" -> 
        begin match __params with
        | [session_id_rpc; master_address_rpc; master_username_rpc; master_password_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let master_address = string_of_rpc master_address_rpc in
            let master_username = string_of_rpc master_username_rpc in
            let master_password = string_of_rpc master_password_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("master_address", master_address_rpc); ("master_username", master_username_rpc); ("master_password", master_password_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.join_force ~__context:(Context.check_for_foreign_database ~__context)  ~master_address ~master_username ~master_password))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.join_force ~__context:(Context.check_for_foreign_database ~__context)  ~master_address ~master_username ~master_password) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool.eject" | "pool_eject" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.eject ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.eject ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.initial_auth" | "pool_initial_auth" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_secretstring x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.initial_auth ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.initial_auth ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.emergency_transition_to_master" | "pool_emergency_transition_to_master" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.emergency_transition_to_master ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.emergency_transition_to_master ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.emergency_reset_master" | "pool_emergency_reset_master" -> 
        begin match __params with
        | [session_id_rpc; master_address_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let master_address = string_of_rpc master_address_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("master_address", master_address_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.emergency_reset_master ~__context:(Context.check_for_foreign_database ~__context)  ~master_address))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.emergency_reset_master ~__context:(Context.check_for_foreign_database ~__context)  ~master_address) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.recover_slaves" | "pool_recover_slaves" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.recover_slaves ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.recover_slaves ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.hello" | "pool_hello" -> 
        begin match __params with
        | [session_id_rpc; host_uuid_rpc; host_address_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host_uuid = string_of_rpc host_uuid_rpc in
            let host_address = string_of_rpc host_address_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host_uuid", host_uuid_rpc); ("host_address", host_address_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_hello_return x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.hello ~__context:(Context.check_for_foreign_database ~__context)  ~host_uuid ~host_address))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.hello ~__context:(Context.check_for_foreign_database ~__context)  ~host_uuid ~host_address) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.is_slave" | "pool_is_slave" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.is_slave ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.is_slave ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.create_VLAN" | "pool_create_VLAN" -> 
        begin match __params with
        | [session_id_rpc; device_rpc; network_rpc; vLAN_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let device = string_of_rpc device_rpc in
            let network = ref_network_of_rpc network_rpc in
            let vLAN = int64_of_rpc vLAN_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("device", device_rpc); ("network", network_rpc); ("vLAN", vLAN_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.create_VLAN ~__context:(Context.check_for_foreign_database ~__context)  ~device ~network ~vLAN))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.create_VLAN ~__context:(Context.check_for_foreign_database ~__context)  ~device ~network ~vLAN) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool.management_reconfigure" | "pool_management_reconfigure" -> 
        begin match __params with
        | [session_id_rpc; network_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let network = ref_network_of_rpc network_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("network", network_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.management_reconfigure ~__context:(Context.check_for_foreign_database ~__context)  ~network))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.management_reconfigure ~__context:(Context.check_for_foreign_database ~__context)  ~network) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.create_VLAN_from_PIF" | "pool_create_VLAN_from_PIF" -> 
        begin match __params with
        | [session_id_rpc; pif_rpc; network_rpc; vLAN_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let pif = ref_PIF_of_rpc pif_rpc in
            let network = ref_network_of_rpc network_rpc in
            let vLAN = int64_of_rpc vLAN_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("pif", pif_rpc); ("network", network_rpc); ("vLAN", vLAN_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.create_VLAN_from_PIF ~__context:(Context.check_for_foreign_database ~__context)  ~pif ~network ~vLAN))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.create_VLAN_from_PIF ~__context:(Context.check_for_foreign_database ~__context)  ~pif ~network ~vLAN) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool.slave_network_report" | "pool_slave_network_report" -> 
        begin match __params with
        | [session_id_rpc; phydevs_rpc; dev_to_mac_rpc; dev_to_mtu_rpc; slave_host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let phydevs = string_to_string_map_of_rpc phydevs_rpc in
            let dev_to_mac = string_to_string_map_of_rpc dev_to_mac_rpc in
            let dev_to_mtu = string_to_int64_map_of_rpc dev_to_mtu_rpc in
            let slave_host = ref_host_of_rpc slave_host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("phydevs", phydevs_rpc); ("dev_to_mac", dev_to_mac_rpc); ("dev_to_mtu", dev_to_mtu_rpc); ("slave_host", slave_host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.slave_network_report ~__context:(Context.check_for_foreign_database ~__context)  ~phydevs ~dev_to_mac ~dev_to_mtu ~slave_host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.slave_network_report ~__context:(Context.check_for_foreign_database ~__context)  ~phydevs ~dev_to_mac ~dev_to_mtu ~slave_host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "pool.enable_ha" | "pool_enable_ha" -> 
        begin match __params with
        | [session_id_rpc; heartbeat_srs_rpc; configuration_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let heartbeat_srs = ref_SR_set_of_rpc heartbeat_srs_rpc in
            let configuration = string_to_string_map_of_rpc configuration_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("heartbeat_srs", heartbeat_srs_rpc); ("configuration", configuration_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.enable_ha ~__context:(Context.check_for_foreign_database ~__context)  ~heartbeat_srs ~configuration))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.enable_ha ~__context:(Context.check_for_foreign_database ~__context)  ~heartbeat_srs ~configuration) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.disable_ha" | "pool_disable_ha" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.disable_ha ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.disable_ha ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.sync_database" | "pool_sync_database" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.sync_database ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.sync_database ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.designate_new_master" | "pool_designate_new_master" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.designate_new_master ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.designate_new_master ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.ha_prevent_restarts_for" | "pool_ha_prevent_restarts_for" -> 
        begin match __params with
        | [session_id_rpc; seconds_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let seconds = int64_of_rpc seconds_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("seconds", seconds_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.ha_prevent_restarts_for ~__context:(Context.check_for_foreign_database ~__context)  ~seconds))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.ha_prevent_restarts_for ~__context:(Context.check_for_foreign_database ~__context)  ~seconds) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.ha_failover_plan_exists" | "pool_ha_failover_plan_exists" -> 
        begin match __params with
        | [session_id_rpc; n_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let n = int64_of_rpc n_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("n", n_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.ha_failover_plan_exists ~__context:(Context.check_for_foreign_database ~__context)  ~n))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.ha_failover_plan_exists ~__context:(Context.check_for_foreign_database ~__context)  ~n) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.ha_compute_max_host_failures_to_tolerate" | "pool_ha_compute_max_host_failures_to_tolerate" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.ha_compute_max_host_failures_to_tolerate ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.ha_compute_max_host_failures_to_tolerate ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.ha_compute_hypothetical_max_host_failures_to_tolerate" | "pool_ha_compute_hypothetical_max_host_failures_to_tolerate" -> 
        begin match __params with
        | [session_id_rpc; configuration_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let configuration = ref_VM_to_string_map_of_rpc configuration_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("configuration", configuration_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.ha_compute_hypothetical_max_host_failures_to_tolerate ~__context:(Context.check_for_foreign_database ~__context)  ~configuration))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.ha_compute_hypothetical_max_host_failures_to_tolerate ~__context:(Context.check_for_foreign_database ~__context)  ~configuration) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.ha_compute_vm_failover_plan" | "pool_ha_compute_vm_failover_plan" -> 
        begin match __params with
        | [session_id_rpc; failed_hosts_rpc; failed_vms_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let failed_hosts = ref_host_set_of_rpc failed_hosts_rpc in
            let failed_vms = ref_VM_set_of_rpc failed_vms_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("failed_hosts", failed_hosts_rpc); ("failed_vms", failed_vms_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_to_string_to_string_map_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.ha_compute_vm_failover_plan ~__context:(Context.check_for_foreign_database ~__context)  ~failed_hosts ~failed_vms))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.ha_compute_vm_failover_plan ~__context:(Context.check_for_foreign_database ~__context)  ~failed_hosts ~failed_vms) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_ha_host_failures_to_tolerate" | "pool_set_ha_host_failures_to_tolerate" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.set_ha_host_failures_to_tolerate ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.set_ha_host_failures_to_tolerate ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.create_new_blob" | "pool_create_new_blob" -> 
        begin match __params with
        | session_id_rpc :: pool_rpc :: name_rpc :: mime_type_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let public_rpc = try List.nth default_args 0 with _ -> Rpc.Bool false in
            let session_id = ref_session_of_rpc session_id_rpc in
            let pool = ref_pool_of_rpc pool_rpc in
            let name = string_of_rpc name_rpc in
            let mime_type = string_of_rpc mime_type_rpc in
            let public = bool_of_rpc public_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("pool", pool_rpc); ("name", name_rpc); ("mime_type", mime_type_rpc); ("public", public_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_blob x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.create_new_blob ~__context:(Context.check_for_foreign_database ~__context)  ~pool ~name ~mime_type ~public))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.create_new_blob ~__context:(Context.check_for_foreign_database ~__context)  ~pool ~name ~mime_type ~public) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool.ha_schedule_plan_recomputation" | "pool_ha_schedule_plan_recomputation" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.ha_schedule_plan_recomputation ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.ha_schedule_plan_recomputation ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.enable_binary_storage" | "pool_enable_binary_storage" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.enable_binary_storage ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.enable_binary_storage ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.disable_binary_storage" | "pool_disable_binary_storage" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.disable_binary_storage ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.disable_binary_storage ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.enable_external_auth" | "pool_enable_external_auth" -> 
        begin match __params with
        | [session_id_rpc; pool_rpc; config_rpc; service_name_rpc; auth_type_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let pool = ref_pool_of_rpc pool_rpc in
            let config = string_to_string_map_of_rpc config_rpc in
            let service_name = string_of_rpc service_name_rpc in
            let auth_type = string_of_rpc auth_type_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("pool", pool_rpc); ("config", config_rpc); ("service_name", service_name_rpc); ("auth_type", auth_type_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.enable_external_auth ~__context:(Context.check_for_foreign_database ~__context)  ~pool ~config ~service_name ~auth_type))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.enable_external_auth ~__context:(Context.check_for_foreign_database ~__context)  ~pool ~config ~service_name ~auth_type) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "pool.disable_external_auth" | "pool_disable_external_auth" -> 
        begin match __params with
        | session_id_rpc :: pool_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let config_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let pool = ref_pool_of_rpc pool_rpc in
            let config = string_to_string_map_of_rpc config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("pool", pool_rpc); ("config", config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.disable_external_auth ~__context:(Context.check_for_foreign_database ~__context)  ~pool ~config))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.disable_external_auth ~__context:(Context.check_for_foreign_database ~__context)  ~pool ~config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.detect_nonhomogeneous_external_auth" | "pool_detect_nonhomogeneous_external_auth" -> 
        begin match __params with
        | [session_id_rpc; pool_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let pool = ref_pool_of_rpc pool_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("pool", pool_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.detect_nonhomogeneous_external_auth ~__context:(Context.check_for_foreign_database ~__context)  ~pool))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.detect_nonhomogeneous_external_auth ~__context:(Context.check_for_foreign_database ~__context)  ~pool) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.initialize_wlb" | "pool_initialize_wlb" -> 
        begin match __params with
        | [session_id_rpc; wlb_url_rpc; wlb_username_rpc; wlb_password_rpc; xenserver_username_rpc; xenserver_password_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let wlb_url = string_of_rpc wlb_url_rpc in
            let wlb_username = string_of_rpc wlb_username_rpc in
            let wlb_password = string_of_rpc wlb_password_rpc in
            let xenserver_username = string_of_rpc xenserver_username_rpc in
            let xenserver_password = string_of_rpc xenserver_password_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("wlb_url", wlb_url_rpc); ("wlb_username", wlb_username_rpc); ("wlb_password", wlb_password_rpc); ("xenserver_username", xenserver_username_rpc); ("xenserver_password", xenserver_password_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.initialize_wlb ~__context:(Context.check_for_foreign_database ~__context)  ~wlb_url ~wlb_username ~wlb_password ~xenserver_username ~xenserver_password))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.initialize_wlb ~__context:(Context.check_for_foreign_database ~__context)  ~wlb_url ~wlb_username ~wlb_password ~xenserver_username ~xenserver_password) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "5" (string_of_int ((List.length __params) - 1))
        end
    | "pool.deconfigure_wlb" | "pool_deconfigure_wlb" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.deconfigure_wlb ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.deconfigure_wlb ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.send_wlb_configuration" | "pool_send_wlb_configuration" -> 
        begin match __params with
        | [session_id_rpc; config_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let config = string_to_string_map_of_rpc config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("config", config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.send_wlb_configuration ~__context:(Context.check_for_foreign_database ~__context)  ~config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.send_wlb_configuration ~__context:(Context.check_for_foreign_database ~__context)  ~config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.retrieve_wlb_configuration" | "pool_retrieve_wlb_configuration" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.retrieve_wlb_configuration ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.retrieve_wlb_configuration ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.retrieve_wlb_recommendations" | "pool_retrieve_wlb_recommendations" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_to_string_set_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.retrieve_wlb_recommendations ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.retrieve_wlb_recommendations ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.send_test_post" | "pool_send_test_post" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; port_rpc; body_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = string_of_rpc host_rpc in
            let port = int64_of_rpc port_rpc in
            let body = string_of_rpc body_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("port", port_rpc); ("body", body_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.send_test_post ~__context:(Context.check_for_foreign_database ~__context)  ~host ~port ~body))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.send_test_post ~__context:(Context.check_for_foreign_database ~__context)  ~host ~port ~body) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool.certificate_install" | "pool_certificate_install" -> 
        begin match __params with
        | [session_id_rpc; name_rpc; cert_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let name = string_of_rpc name_rpc in
            let cert = string_of_rpc cert_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("name", name_rpc); ("cert", cert_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.certificate_install ~__context:(Context.check_for_foreign_database ~__context)  ~name ~cert))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.certificate_install ~__context:(Context.check_for_foreign_database ~__context)  ~name ~cert) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.certificate_uninstall" | "pool_certificate_uninstall" -> 
        begin match __params with
        | [session_id_rpc; name_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let name = string_of_rpc name_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("name", name_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.certificate_uninstall ~__context:(Context.check_for_foreign_database ~__context)  ~name))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.certificate_uninstall ~__context:(Context.check_for_foreign_database ~__context)  ~name) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.certificate_list" | "pool_certificate_list" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.certificate_list ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.certificate_list ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.crl_install" | "pool_crl_install" -> 
        begin match __params with
        | [session_id_rpc; name_rpc; cert_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let name = string_of_rpc name_rpc in
            let cert = string_of_rpc cert_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("name", name_rpc); ("cert", cert_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.crl_install ~__context:(Context.check_for_foreign_database ~__context)  ~name ~cert))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.crl_install ~__context:(Context.check_for_foreign_database ~__context)  ~name ~cert) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.crl_uninstall" | "pool_crl_uninstall" -> 
        begin match __params with
        | [session_id_rpc; name_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let name = string_of_rpc name_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("name", name_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.crl_uninstall ~__context:(Context.check_for_foreign_database ~__context)  ~name))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.crl_uninstall ~__context:(Context.check_for_foreign_database ~__context)  ~name) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.crl_list" | "pool_crl_list" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.crl_list ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.crl_list ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.certificate_sync" | "pool_certificate_sync" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.certificate_sync ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.certificate_sync ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.enable_redo_log" | "pool_enable_redo_log" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.enable_redo_log ~__context:(Context.check_for_foreign_database ~__context)  ~sr))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.enable_redo_log ~__context:(Context.check_for_foreign_database ~__context)  ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.disable_redo_log" | "pool_disable_redo_log" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.disable_redo_log ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.disable_redo_log ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.audit_log_append" | "pool_audit_log_append" -> 
        begin match __params with
        | [session_id_rpc; line_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let line = string_of_rpc line_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("line", line_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.audit_log_append ~__context:(Context.check_for_foreign_database ~__context)  ~line))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.audit_log_append ~__context:(Context.check_for_foreign_database ~__context)  ~line) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_vswitch_controller" | "pool_set_vswitch_controller" -> 
        begin match __params with
        | [session_id_rpc; address_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let address = string_of_rpc address_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("address", address_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.set_vswitch_controller ~__context:(Context.check_for_foreign_database ~__context)  ~address))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.set_vswitch_controller ~__context:(Context.check_for_foreign_database ~__context)  ~address) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.test_archive_target" | "pool_test_archive_target" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; config_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let config = string_to_string_map_of_rpc config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("config", config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.test_archive_target ~__context:(Context.check_for_foreign_database ~__context)  ~self ~config))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.test_archive_target ~__context:(Context.check_for_foreign_database ~__context)  ~self ~config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.enable_local_storage_caching" | "pool_enable_local_storage_caching" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.enable_local_storage_caching ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.enable_local_storage_caching ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.disable_local_storage_caching" | "pool_disable_local_storage_caching" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.disable_local_storage_caching ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.disable_local_storage_caching ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_license_state" | "pool_get_license_state" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.get_license_state ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.get_license_state ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.apply_edition" | "pool_apply_edition" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; edition_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let edition = string_of_rpc edition_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("edition", edition_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.apply_edition ~__context:(Context.check_for_foreign_database ~__context)  ~self ~edition))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.apply_edition ~__context:(Context.check_for_foreign_database ~__context)  ~self ~edition) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.enable_ssl_legacy" | "pool_enable_ssl_legacy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.disable_ssl_legacy" | "pool_disable_ssl_legacy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.disable_ssl_legacy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.disable_ssl_legacy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_igmp_snooping_enabled" | "pool_set_igmp_snooping_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.set_igmp_snooping_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.set_igmp_snooping_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.has_extension" | "pool_has_extension" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; name_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let name = string_of_rpc name_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("name", name_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.has_extension ~__context:(Context.check_for_foreign_database ~__context)  ~self ~name))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.has_extension ~__context:(Context.check_for_foreign_database ~__context)  ~self ~name) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.add_to_guest_agent_config" | "pool_add_to_guest_agent_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.add_to_guest_agent_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.add_to_guest_agent_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool.remove_from_guest_agent_config" | "pool_remove_from_guest_agent_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.remove_from_guest_agent_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.remove_from_guest_agent_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.rotate_secret" | "pool_rotate_secret" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.rotate_secret ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.rotate_secret ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.set_https_only" | "pool_set_https_only" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool.set_https_only ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool.set_https_only ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_all" | "pool_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_all_records_where" | "pool_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_to_pool_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool.get_all_records" | "pool_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_to_pool_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_record" | "pool_patch_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pool_patch_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_by_uuid" | "pool_patch_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_patch x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_by_name_label" | "pool_patch_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_patch_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_uuid" | "pool_patch_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_name_label" | "pool_patch_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_name_description" | "pool_patch_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_version" | "pool_patch_get_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_size" | "pool_patch_get_size" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_size ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_size";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_pool_applied" | "pool_patch_get_pool_applied" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_pool_applied ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_pool_applied";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_host_patches" | "pool_patch_get_host_patches" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_patch_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_host_patches ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_host_patches";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_after_apply_guidance" | "pool_patch_get_after_apply_guidance" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_after_apply_guidance_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_after_apply_guidance ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_after_apply_guidance";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_pool_update" | "pool_patch_get_pool_update" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_update x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_pool_update ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_pool_update";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_other_config" | "pool_patch_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.set_other_config" | "pool_patch_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool_patch.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.add_to_other_config" | "pool_patch_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool_patch.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.remove_from_other_config" | "pool_patch_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool_patch.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.apply" | "pool_patch_apply" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_patch.apply ~__context:(Context.check_for_foreign_database ~__context)  ~self ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_patch.apply ~__context:(Context.check_for_foreign_database ~__context)  ~self ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.pool_apply" | "pool_patch_pool_apply" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_patch.pool_apply ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_patch.pool_apply ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.precheck" | "pool_patch_precheck" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_patch.precheck ~__context:(Context.check_for_foreign_database ~__context)  ~self ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_patch.precheck ~__context:(Context.check_for_foreign_database ~__context)  ~self ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.clean" | "pool_patch_clean" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_patch.clean ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_patch.clean ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.pool_clean" | "pool_patch_pool_clean" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_patch.pool_clean ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_patch.pool_clean ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.destroy" | "pool_patch_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_patch.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_patch.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.clean_on_host" | "pool_patch_clean_on_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_patch_of_rpc self_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_patch.clean_on_host ~__context:(Context.check_for_foreign_database ~__context)  ~self ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_patch.clean_on_host ~__context:(Context.check_for_foreign_database ~__context)  ~self ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_all" | "pool_patch_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_patch_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_all_records_where" | "pool_patch_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_patch_to_pool_patch_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_patch.get_all_records" | "pool_patch_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_patch_to_pool_patch_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_patch.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_patch.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_record" | "pool_update_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pool_update_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_by_uuid" | "pool_update_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_update x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_by_name_label" | "pool_update_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_update_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_uuid" | "pool_update_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_name_label" | "pool_update_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_name_description" | "pool_update_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_version" | "pool_update_get_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_installation_size" | "pool_update_get_installation_size" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_installation_size ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_installation_size";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_key" | "pool_update_get_key" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_key ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_key";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_after_apply_guidance" | "pool_update_get_after_apply_guidance" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_update_after_apply_guidance_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_after_apply_guidance ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_after_apply_guidance";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_vdi" | "pool_update_get_vdi" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_vdi ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_vdi";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_hosts" | "pool_update_get_hosts" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_hosts ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_hosts";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_other_config" | "pool_update_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_enforce_homogeneity" | "pool_update_get_enforce_homogeneity" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_enforce_homogeneity ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_enforce_homogeneity";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.set_other_config" | "pool_update_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool_update.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.add_to_other_config" | "pool_update_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool_update.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.remove_from_other_config" | "pool_update_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "pool_update.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.introduce" | "pool_update_introduce" -> 
        begin match __params with
        | [session_id_rpc; vdi_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vdi", vdi_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_update x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_update.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~vdi))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_update.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~vdi) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.precheck" | "pool_update_precheck" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; host_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let _self = ref_pool_update_of_rpc self_rpc in
            let _host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let host = ref_host_of_rpc host_rpc in
            let call_string = Jsonrpc.string_of_call {call with name=__call} in
            let marshaller = (fun x -> x) in
            let local_op = fun ~__context -> (rbac __context (fun()->(Custom.Host.call_extension ~__context:(Context.check_for_foreign_database ~__context) ~host ~call:call_string))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.call_extension ~__context:(Context.check_for_foreign_database ~__context) ~host ~call:call_string) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            if resp.Rpc.success then
              try
                D.debug "HostExtension '%s' resp \"%s\"" __call (Jsonrpc.string_of_response resp);
                ignore(if __sync_ty = `Sync then let _ = (fun x -> livepatch_status_of_rpc x) resp.contents in ());
                resp
              with
              | _ -> API.response_of_failure Api_errors.internal_error [string_of_rpc resp.Rpc.contents]
            else
              Server_helpers.unknown_rpc_failure __call
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.apply" | "pool_update_apply" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; host_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let _self = ref_pool_update_of_rpc self_rpc in
            let _host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let host = ref_host_of_rpc host_rpc in
            let call_string = Jsonrpc.string_of_call {call with name=__call} in
            let marshaller = (fun x -> x) in
            let local_op = fun ~__context -> (rbac __context (fun()->(Custom.Host.call_extension ~__context:(Context.check_for_foreign_database ~__context) ~host ~call:call_string))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.call_extension ~__context:(Context.check_for_foreign_database ~__context) ~host ~call:call_string) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            if resp.Rpc.success then
              try
                D.debug "HostExtension '%s' resp \"%s\"" __call (Jsonrpc.string_of_response resp);
                ignore(if __sync_ty = `Sync then let _ = (fun _ -> ()) resp.contents in ());
                resp
              with
              | _ -> API.response_of_failure Api_errors.internal_error [string_of_rpc resp.Rpc.contents]
            else
              Server_helpers.unknown_rpc_failure __call
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.pool_apply" | "pool_update_pool_apply" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_update.pool_apply ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_update.pool_apply ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.pool_clean" | "pool_update_pool_clean" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_update.pool_clean ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_update.pool_clean ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.destroy" | "pool_update_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_update.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_update.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.attach" | "pool_update_attach" -> 
        begin match __params with
        | session_id_rpc :: self_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let use_localhost_proxy_rpc = try List.nth default_args 0 with _ -> Rpc.Bool false in
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            let use_localhost_proxy = bool_of_rpc use_localhost_proxy_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("use_localhost_proxy", use_localhost_proxy_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_update.attach ~__context:(Context.check_for_foreign_database ~__context)  ~self ~use_localhost_proxy))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_update.attach ~__context:(Context.check_for_foreign_database ~__context)  ~self ~use_localhost_proxy) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.detach" | "pool_update_detach" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_pool_update_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_update.detach ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_update.detach ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.resync_host" | "pool_update_resync_host" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Pool_update.resync_host ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Pool_update.resync_host ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_all" | "pool_update_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_update_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_all_records_where" | "pool_update_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_update_to_pool_update_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "pool_update.get_all_records" | "pool_update_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_update_to_pool_update_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Pool_update.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "pool_update.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_record" | "VM_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vM_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_by_uuid" | "VM_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.create" | "VM_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let name_label = string_of_rpc ((List.assoc_opt "name_label" __structure) |> Option.value ~default:(Rpc.String "")) in
            let name_description = string_of_rpc ((List.assoc_opt "name_description" __structure) |> Option.value ~default:(Rpc.String "")) in
            let power_state = vm_power_state_of_rpc ((List.assoc_opt "power_state" __structure) |> Option.value ~default:(Rpc.String "Halted")) in
            let user_version = int64_of_rpc (my_assoc "user_version" __structure) in
            let is_a_template = bool_of_rpc (my_assoc "is_a_template" __structure) in
            let suspend_VDI = ref_VDI_of_rpc ((List.assoc_opt "suspend_VDI" __structure) |> Option.value ~default:(Rpc.String "OpaqueRef:NULL")) in
            let affinity = ref_host_of_rpc (my_assoc "affinity" __structure) in
            let memory_target = int64_of_rpc ((List.assoc_opt "memory_target" __structure) |> Option.value ~default:(Rpc.Int (0L))) in
            let memory_static_max = int64_of_rpc (my_assoc "memory_static_max" __structure) in
            let memory_dynamic_max = int64_of_rpc (my_assoc "memory_dynamic_max" __structure) in
            let memory_dynamic_min = int64_of_rpc (my_assoc "memory_dynamic_min" __structure) in
            let memory_static_min = int64_of_rpc (my_assoc "memory_static_min" __structure) in
            let vCPUs_params = string_to_string_map_of_rpc (my_assoc "VCPUs_params" __structure) in
            let vCPUs_max = int64_of_rpc (my_assoc "VCPUs_max" __structure) in
            let vCPUs_at_startup = int64_of_rpc (my_assoc "VCPUs_at_startup" __structure) in
            let actions_after_shutdown = on_normal_exit_of_rpc (my_assoc "actions_after_shutdown" __structure) in
            let actions_after_reboot = on_normal_exit_of_rpc (my_assoc "actions_after_reboot" __structure) in
            let actions_after_crash = on_crash_behaviour_of_rpc (my_assoc "actions_after_crash" __structure) in
            let pV_bootloader = string_of_rpc (my_assoc "PV_bootloader" __structure) in
            let pV_kernel = string_of_rpc (my_assoc "PV_kernel" __structure) in
            let pV_ramdisk = string_of_rpc (my_assoc "PV_ramdisk" __structure) in
            let pV_args = string_of_rpc (my_assoc "PV_args" __structure) in
            let pV_bootloader_args = string_of_rpc (my_assoc "PV_bootloader_args" __structure) in
            let pV_legacy_args = string_of_rpc (my_assoc "PV_legacy_args" __structure) in
            let hVM_boot_policy = string_of_rpc (my_assoc "HVM_boot_policy" __structure) in
            let hVM_boot_params = string_to_string_map_of_rpc (my_assoc "HVM_boot_params" __structure) in
            let hVM_shadow_multiplier = float_of_rpc ((List.assoc_opt "HVM_shadow_multiplier" __structure) |> Option.value ~default:(Rpc.Float (1.000000))) in
            let platform = string_to_string_map_of_rpc (my_assoc "platform" __structure) in
            let pCI_bus = string_of_rpc (my_assoc "PCI_bus" __structure) in
            let other_config = string_to_string_map_of_rpc (my_assoc "other_config" __structure) in
            let last_boot_CPU_flags = string_to_string_map_of_rpc ((List.assoc_opt "last_boot_CPU_flags" __structure) |> Option.value ~default:(Rpc.Dict [])) in
            let last_booted_record = string_of_rpc ((List.assoc_opt "last_booted_record" __structure) |> Option.value ~default:(Rpc.String "")) in
            let recommendations = string_of_rpc (my_assoc "recommendations" __structure) in
            let xenstore_data = string_to_string_map_of_rpc ((List.assoc_opt "xenstore_data" __structure) |> Option.value ~default:(Rpc.Dict [])) in
            let ha_always_run = bool_of_rpc ((List.assoc_opt "ha_always_run" __structure) |> Option.value ~default:(Rpc.Bool false)) in
            let ha_restart_priority = string_of_rpc ((List.assoc_opt "ha_restart_priority" __structure) |> Option.value ~default:(Rpc.String "")) in
            let tags = string_set_of_rpc ((List.assoc_opt "tags" __structure) |> Option.value ~default:(Rpc.Enum [])) in
            let blocked_operations = vm_operations_to_string_map_of_rpc ((List.assoc_opt "blocked_operations" __structure) |> Option.value ~default:(Rpc.Dict [])) in
            let protection_policy = ref_VMPP_of_rpc ((List.assoc_opt "protection_policy" __structure) |> Option.value ~default:(Rpc.String "OpaqueRef:NULL")) in
            let is_snapshot_from_vmpp = bool_of_rpc ((List.assoc_opt "is_snapshot_from_vmpp" __structure) |> Option.value ~default:(Rpc.Bool false)) in
            let snapshot_schedule = ref_VMSS_of_rpc ((List.assoc_opt "snapshot_schedule" __structure) |> Option.value ~default:(Rpc.String "OpaqueRef:NULL")) in
            let is_vmss_snapshot = bool_of_rpc ((List.assoc_opt "is_vmss_snapshot" __structure) |> Option.value ~default:(Rpc.Bool false)) in
            let appliance = ref_VM_appliance_of_rpc ((List.assoc_opt "appliance" __structure) |> Option.value ~default:(Rpc.String "OpaqueRef:NULL")) in
            let start_delay = int64_of_rpc ((List.assoc_opt "start_delay" __structure) |> Option.value ~default:(Rpc.Int (0L))) in
            let shutdown_delay = int64_of_rpc ((List.assoc_opt "shutdown_delay" __structure) |> Option.value ~default:(Rpc.Int (0L))) in
            let order = int64_of_rpc ((List.assoc_opt "order" __structure) |> Option.value ~default:(Rpc.Int (0L))) in
            let suspend_SR = ref_SR_of_rpc ((List.assoc_opt "suspend_SR" __structure) |> Option.value ~default:(Rpc.String "OpaqueRef:NULL")) in
            let version = int64_of_rpc ((List.assoc_opt "version" __structure) |> Option.value ~default:(Rpc.Int (0L))) in
            let generation_id = string_of_rpc ((List.assoc_opt "generation_id" __structure) |> Option.value ~default:(Rpc.String "0:0")) in
            let hardware_platform_version = int64_of_rpc ((List.assoc_opt "hardware_platform_version" __structure) |> Option.value ~default:(Rpc.Int (0L))) in
            let has_vendor_device = bool_of_rpc ((List.assoc_opt "has_vendor_device" __structure) |> Option.value ~default:((try Rpc.Bool (
let pool = List.hd (Db_actions.DB_Action.Pool.get_all ~__context) in
let restrictions = Db_actions.DB_Action.Pool.get_restrictions ~__context ~self:pool in 
let vendor_device_allowed = try List.assoc "restrict_pci_device_for_auto_update" restrictions = "false" with _ -> false in
let policy_says_its_ok = not (Db_actions.DB_Action.Pool.get_policy_no_vendor_device ~__context ~self:pool) in
vendor_device_allowed && policy_says_its_ok) with e -> D.error "Failure when defaulting has_vendor_device field: %s" (Printexc.to_string e); Rpc.Bool false))) in
            let reference_label = string_of_rpc ((List.assoc_opt "reference_label" __structure) |> Option.value ~default:(Rpc.String "")) in
            let domain_type = domain_type_of_rpc ((List.assoc_opt "domain_type" __structure) |> Option.value ~default:(Rpc.String "unspecified")) in
            let nVRAM = string_to_string_map_of_rpc ((List.assoc_opt "NVRAM" __structure) |> Option.value ~default:(Rpc.Dict [])) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~power_state ~user_version ~is_a_template ~suspend_VDI ~affinity ~memory_target ~memory_static_max ~memory_dynamic_max ~memory_dynamic_min ~memory_static_min ~vCPUs_params ~vCPUs_max ~vCPUs_at_startup ~actions_after_shutdown ~actions_after_reboot ~actions_after_crash ~pV_bootloader ~pV_kernel ~pV_ramdisk ~pV_args ~pV_bootloader_args ~pV_legacy_args ~hVM_boot_policy ~hVM_boot_params ~hVM_shadow_multiplier ~platform ~pCI_bus ~other_config ~last_boot_CPU_flags ~last_booted_record ~recommendations ~xenstore_data ~ha_always_run ~ha_restart_priority ~tags ~blocked_operations ~protection_policy ~is_snapshot_from_vmpp ~snapshot_schedule ~is_vmss_snapshot ~appliance ~start_delay ~shutdown_delay ~order ~suspend_SR ~version ~generation_id ~hardware_platform_version ~has_vendor_device ~reference_label ~domain_type ~nVRAM))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~power_state ~user_version ~is_a_template ~suspend_VDI ~affinity ~memory_target ~memory_static_max ~memory_dynamic_max ~memory_dynamic_min ~memory_static_min ~vCPUs_params ~vCPUs_max ~vCPUs_at_startup ~actions_after_shutdown ~actions_after_reboot ~actions_after_crash ~pV_bootloader ~pV_kernel ~pV_ramdisk ~pV_args ~pV_bootloader_args ~pV_legacy_args ~hVM_boot_policy ~hVM_boot_params ~hVM_shadow_multiplier ~platform ~pCI_bus ~other_config ~last_boot_CPU_flags ~last_booted_record ~recommendations ~xenstore_data ~ha_always_run ~ha_restart_priority ~tags ~blocked_operations ~protection_policy ~is_snapshot_from_vmpp ~snapshot_schedule ~is_vmss_snapshot ~appliance ~start_delay ~shutdown_delay ~order ~suspend_SR ~version ~generation_id ~hardware_platform_version ~has_vendor_device ~reference_label ~domain_type ~nVRAM) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.destroy" | "VM_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_by_name_label" | "VM_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_uuid" | "VM_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_allowed_operations" | "VM_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vm_operations_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_current_operations" | "VM_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_vm_operations_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_name_label" | "VM_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_name_description" | "VM_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_power_state" | "VM_get_power_state" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vm_power_state x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_power_state ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_power_state";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_user_version" | "VM_get_user_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_user_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_user_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_is_a_template" | "VM_get_is_a_template" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_is_a_template ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_is_a_template";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_is_default_template" | "VM_get_is_default_template" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_is_default_template ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_is_default_template";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_suspend_VDI" | "VM_get_suspend_VDI" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_suspend_VDI ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_suspend_VDI";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_resident_on" | "VM_get_resident_on" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_resident_on ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_resident_on";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_scheduled_to_be_resident_on" | "VM_get_scheduled_to_be_resident_on" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_scheduled_to_be_resident_on ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_scheduled_to_be_resident_on";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_affinity" | "VM_get_affinity" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_affinity ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_affinity";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_memory_overhead" | "VM_get_memory_overhead" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_memory_overhead ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_memory_overhead";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_memory_target" | "VM_get_memory_target" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_memory_target ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_memory_target";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_memory_static_max" | "VM_get_memory_static_max" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_memory_static_max ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_memory_static_max";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_memory_dynamic_max" | "VM_get_memory_dynamic_max" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_memory_dynamic_max ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_memory_dynamic_max";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_memory_dynamic_min" | "VM_get_memory_dynamic_min" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_memory_dynamic_min ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_memory_dynamic_min";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_memory_static_min" | "VM_get_memory_static_min" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_memory_static_min ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_memory_static_min";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_VCPUs_params" | "VM_get_VCPUs_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_VCPUs_params ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_VCPUs_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_VCPUs_max" | "VM_get_VCPUs_max" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_VCPUs_max ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_VCPUs_max";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_VCPUs_at_startup" | "VM_get_VCPUs_at_startup" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_VCPUs_at_startup ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_VCPUs_at_startup";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_actions_after_shutdown" | "VM_get_actions_after_shutdown" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_on_normal_exit x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_actions_after_shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_actions_after_shutdown";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_actions_after_reboot" | "VM_get_actions_after_reboot" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_on_normal_exit x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_actions_after_reboot ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_actions_after_reboot";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_actions_after_crash" | "VM_get_actions_after_crash" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_on_crash_behaviour x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_actions_after_crash ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_actions_after_crash";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_consoles" | "VM_get_consoles" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_console_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_consoles ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_consoles";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_VIFs" | "VM_get_VIFs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VIF_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_VIFs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_VIFs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_VBDs" | "VM_get_VBDs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VBD_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_VBDs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_VBDs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_VUSBs" | "VM_get_VUSBs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VUSB_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_VUSBs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_VUSBs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_crash_dumps" | "VM_get_crash_dumps" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_crashdump_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_crash_dumps ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_crash_dumps";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_VTPMs" | "VM_get_VTPMs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VTPM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_VTPMs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_VTPMs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_PV_bootloader" | "VM_get_PV_bootloader" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_PV_bootloader ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_PV_bootloader";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_PV_kernel" | "VM_get_PV_kernel" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_PV_kernel ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_PV_kernel";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_PV_ramdisk" | "VM_get_PV_ramdisk" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_PV_ramdisk ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_PV_ramdisk";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_PV_args" | "VM_get_PV_args" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_PV_args ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_PV_args";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_PV_bootloader_args" | "VM_get_PV_bootloader_args" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_PV_bootloader_args ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_PV_bootloader_args";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_PV_legacy_args" | "VM_get_PV_legacy_args" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_PV_legacy_args ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_PV_legacy_args";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_HVM_boot_policy" | "VM_get_HVM_boot_policy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_HVM_boot_policy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_HVM_boot_policy";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_HVM_boot_params" | "VM_get_HVM_boot_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_HVM_boot_params ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_HVM_boot_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_HVM_shadow_multiplier" | "VM_get_HVM_shadow_multiplier" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_float x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_HVM_shadow_multiplier ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_HVM_shadow_multiplier";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_platform" | "VM_get_platform" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_platform ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_platform";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_PCI_bus" | "VM_get_PCI_bus" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_PCI_bus ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_PCI_bus";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_other_config" | "VM_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_domid" | "VM_get_domid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_domid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_domid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_domarch" | "VM_get_domarch" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_domarch ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_domarch";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_last_boot_CPU_flags" | "VM_get_last_boot_CPU_flags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_last_boot_CPU_flags ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_last_boot_CPU_flags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_is_control_domain" | "VM_get_is_control_domain" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_is_control_domain ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_is_control_domain";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_metrics" | "VM_get_metrics" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_metrics x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_metrics ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_metrics";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_guest_metrics" | "VM_get_guest_metrics" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_guest_metrics x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_guest_metrics ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_guest_metrics";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_last_booted_record" | "VM_get_last_booted_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_last_booted_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_last_booted_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_recommendations" | "VM_get_recommendations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_recommendations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_recommendations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_xenstore_data" | "VM_get_xenstore_data" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_xenstore_data ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_xenstore_data";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_ha_always_run" | "VM_get_ha_always_run" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_ha_always_run ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_ha_always_run";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_ha_restart_priority" | "VM_get_ha_restart_priority" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_ha_restart_priority ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_ha_restart_priority";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_is_a_snapshot" | "VM_get_is_a_snapshot" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_is_a_snapshot ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_is_a_snapshot";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_snapshot_of" | "VM_get_snapshot_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_snapshot_of ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_snapshot_of";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_snapshots" | "VM_get_snapshots" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_snapshots ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_snapshots";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_snapshot_time" | "VM_get_snapshot_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_snapshot_time ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_snapshot_time";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_transportable_snapshot_id" | "VM_get_transportable_snapshot_id" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_transportable_snapshot_id ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_transportable_snapshot_id";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_blobs" | "VM_get_blobs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_ref_blob_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_blobs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_blobs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_tags" | "VM_get_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_blocked_operations" | "VM_get_blocked_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vm_operations_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_blocked_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_blocked_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_snapshot_info" | "VM_get_snapshot_info" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_snapshot_info ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_snapshot_info";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_snapshot_metadata" | "VM_get_snapshot_metadata" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_snapshot_metadata ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_snapshot_metadata";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_parent" | "VM_get_parent" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_parent ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_parent";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_children" | "VM_get_children" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_children ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_children";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_bios_strings" | "VM_get_bios_strings" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_bios_strings ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_bios_strings";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_protection_policy" | "VM_get_protection_policy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VMPP x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_protection_policy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_protection_policy";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_is_snapshot_from_vmpp" | "VM_get_is_snapshot_from_vmpp" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_is_snapshot_from_vmpp ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_is_snapshot_from_vmpp";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_snapshot_schedule" | "VM_get_snapshot_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VMSS x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_snapshot_schedule ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_snapshot_schedule";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_is_vmss_snapshot" | "VM_get_is_vmss_snapshot" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_is_vmss_snapshot ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_is_vmss_snapshot";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_appliance" | "VM_get_appliance" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_appliance x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_appliance ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_appliance";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_start_delay" | "VM_get_start_delay" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_start_delay ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_start_delay";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_shutdown_delay" | "VM_get_shutdown_delay" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_shutdown_delay ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_shutdown_delay";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_order" | "VM_get_order" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_order ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_order";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_VGPUs" | "VM_get_VGPUs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_VGPUs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_VGPUs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_attached_PCIs" | "VM_get_attached_PCIs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PCI_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_attached_PCIs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_attached_PCIs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_suspend_SR" | "VM_get_suspend_SR" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_suspend_SR ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_suspend_SR";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_version" | "VM_get_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_generation_id" | "VM_get_generation_id" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_generation_id ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_generation_id";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_hardware_platform_version" | "VM_get_hardware_platform_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_hardware_platform_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_hardware_platform_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_has_vendor_device" | "VM_get_has_vendor_device" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_has_vendor_device ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_has_vendor_device";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_requires_reboot" | "VM_get_requires_reboot" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_requires_reboot ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_requires_reboot";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_reference_label" | "VM_get_reference_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_reference_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_reference_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_domain_type" | "VM_get_domain_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_domain_type x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_domain_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_domain_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_NVRAM" | "VM_get_NVRAM" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_NVRAM ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_NVRAM";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_name_label" | "VM_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_name_description" | "VM_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_user_version" | "VM_set_user_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_user_version ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_user_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_is_a_template" | "VM_set_is_a_template" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_is_a_template ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_is_a_template ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_affinity" | "VM_set_affinity" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = ref_host_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_affinity ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_affinity";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_VCPUs_params" | "VM_set_VCPUs_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_VCPUs_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_VCPUs_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.add_to_VCPUs_params" | "VM_add_to_VCPUs_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.add_to_VCPUs_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.add_to_VCPUs_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.remove_from_VCPUs_params" | "VM_remove_from_VCPUs_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.remove_from_VCPUs_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.remove_from_VCPUs_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_actions_after_shutdown" | "VM_set_actions_after_shutdown" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = on_normal_exit_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_actions_after_shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_actions_after_shutdown";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_actions_after_reboot" | "VM_set_actions_after_reboot" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = on_normal_exit_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_actions_after_reboot ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_actions_after_reboot";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_PV_bootloader" | "VM_set_PV_bootloader" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_PV_bootloader ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_PV_bootloader";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_PV_kernel" | "VM_set_PV_kernel" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_PV_kernel ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_PV_kernel";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_PV_ramdisk" | "VM_set_PV_ramdisk" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_PV_ramdisk ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_PV_ramdisk";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_PV_args" | "VM_set_PV_args" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_PV_args ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_PV_args";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_PV_bootloader_args" | "VM_set_PV_bootloader_args" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_PV_bootloader_args ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_PV_bootloader_args";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_PV_legacy_args" | "VM_set_PV_legacy_args" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_PV_legacy_args ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_PV_legacy_args";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_HVM_boot_params" | "VM_set_HVM_boot_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_HVM_boot_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_HVM_boot_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.add_to_HVM_boot_params" | "VM_add_to_HVM_boot_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.add_to_HVM_boot_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.add_to_HVM_boot_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.remove_from_HVM_boot_params" | "VM_remove_from_HVM_boot_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.remove_from_HVM_boot_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.remove_from_HVM_boot_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_platform" | "VM_set_platform" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_platform ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_platform";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.add_to_platform" | "VM_add_to_platform" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.add_to_platform ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.add_to_platform";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.remove_from_platform" | "VM_remove_from_platform" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.remove_from_platform ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.remove_from_platform";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_PCI_bus" | "VM_set_PCI_bus" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_PCI_bus ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_PCI_bus";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_other_config" | "VM_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.add_to_other_config" | "VM_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = ["pci"; "folder"; "XenCenter.CustomFields.*"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.remove_from_other_config" | "VM_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = ["pci"; "folder"; "XenCenter.CustomFields.*"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_recommendations" | "VM_set_recommendations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_recommendations ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_recommendations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_xenstore_data" | "VM_set_xenstore_data" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_xenstore_data ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_xenstore_data ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.add_to_xenstore_data" | "VM_add_to_xenstore_data" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.add_to_xenstore_data ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.add_to_xenstore_data";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.remove_from_xenstore_data" | "VM_remove_from_xenstore_data" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.remove_from_xenstore_data ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.remove_from_xenstore_data";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_tags" | "VM_set_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_set_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.add_tags" | "VM_add_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.add_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.add_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.remove_tags" | "VM_remove_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.remove_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.remove_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_blocked_operations" | "VM_set_blocked_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = vm_operations_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_blocked_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_blocked_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.add_to_blocked_operations" | "VM_add_to_blocked_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = vm_operations_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.add_to_blocked_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.add_to_blocked_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.remove_from_blocked_operations" | "VM_remove_from_blocked_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = vm_operations_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.remove_from_blocked_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.remove_from_blocked_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_suspend_SR" | "VM_set_suspend_SR" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = ref_SR_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_suspend_SR ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_suspend_SR";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_hardware_platform_version" | "VM_set_hardware_platform_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.set_hardware_platform_version ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM.set_hardware_platform_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.snapshot" | "VM_snapshot" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; new_name_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let new_name = string_of_rpc new_name_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("new_name", new_name_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.snapshot ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~new_name))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.snapshot ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~new_name) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.snapshot_with_quiesce" | "VM_snapshot_with_quiesce" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; new_name_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.clone" | "VM_clone" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; new_name_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let new_name = string_of_rpc new_name_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("new_name", new_name_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.clone ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~new_name))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.clone ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~new_name) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.copy" | "VM_copy" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; new_name_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let new_name = string_of_rpc new_name_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("new_name", new_name_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.copy ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~new_name ~sr))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.copy ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~new_name ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.revert" | "VM_revert" -> 
        begin match __params with
        | [session_id_rpc; snapshot_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let snapshot = ref_VM_of_rpc snapshot_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("snapshot", snapshot_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.revert ~__context:(Context.check_for_foreign_database ~__context)  ~snapshot))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.revert ~__context:(Context.check_for_foreign_database ~__context)  ~snapshot) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.checkpoint" | "VM_checkpoint" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; new_name_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let new_name = string_of_rpc new_name_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("new_name", new_name_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.checkpoint ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~new_name))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.checkpoint ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~new_name) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.provision" | "VM_provision" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.provision ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.provision ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.start" | "VM_start" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; start_paused_rpc; force_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let start_paused = bool_of_rpc start_paused_rpc in
            let force = bool_of_rpc force_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("start_paused", start_paused_rpc); ("force", force_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.start ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~start_paused ~force))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.start ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~start_paused ~force) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.start_on" | "VM_start_on" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; host_rpc; start_paused_rpc; force_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let host = ref_host_of_rpc host_rpc in
            let start_paused = bool_of_rpc start_paused_rpc in
            let force = bool_of_rpc force_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("host", host_rpc); ("start_paused", start_paused_rpc); ("force", force_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.start_on ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host ~start_paused ~force))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.start_on ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host ~start_paused ~force) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "VM.pause" | "VM_pause" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.pause ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.pause ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.unpause" | "VM_unpause" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.unpause ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.unpause ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.clean_shutdown" | "VM_clean_shutdown" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.clean_shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.clean_shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.shutdown" | "VM_shutdown" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.clean_reboot" | "VM_clean_reboot" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.clean_reboot ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.clean_reboot ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.hard_shutdown" | "VM_hard_shutdown" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.hard_shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.hard_shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.power_state_reset" | "VM_power_state_reset" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.power_state_reset ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.power_state_reset ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.hard_reboot" | "VM_hard_reboot" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.hard_reboot ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.hard_reboot ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.suspend" | "VM_suspend" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.suspend ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.suspend ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.csvm" | "VM_csvm" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.csvm ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.csvm ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.resume" | "VM_resume" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; start_paused_rpc; force_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let start_paused = bool_of_rpc start_paused_rpc in
            let force = bool_of_rpc force_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("start_paused", start_paused_rpc); ("force", force_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.resume ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~start_paused ~force))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.resume ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~start_paused ~force) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_is_default_template" | "VM_set_is_default_template" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_is_default_template ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_is_default_template ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.hard_reboot_internal" | "VM_hard_reboot_internal" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.hard_reboot_internal ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.hard_reboot_internal ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.resume_on" | "VM_resume_on" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; host_rpc; start_paused_rpc; force_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let host = ref_host_of_rpc host_rpc in
            let start_paused = bool_of_rpc start_paused_rpc in
            let force = bool_of_rpc force_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("host", host_rpc); ("start_paused", start_paused_rpc); ("force", force_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.resume_on ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host ~start_paused ~force))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.resume_on ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host ~start_paused ~force) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "VM.pool_migrate" | "VM_pool_migrate" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; host_rpc; options_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let host = ref_host_of_rpc host_rpc in
            let options = string_to_string_map_of_rpc options_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("host", host_rpc); ("options", options_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.pool_migrate ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host ~options))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.pool_migrate ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host ~options) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.pool_migrate_complete" | "VM_pool_migrate_complete" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.pool_migrate_complete ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.pool_migrate_complete ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_VCPUs_number_live" | "VM_set_VCPUs_number_live" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; nvcpu_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let nvcpu = int64_of_rpc nvcpu_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("nvcpu", nvcpu_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_VCPUs_number_live ~__context:(Context.check_for_foreign_database ~__context)  ~self ~nvcpu))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_VCPUs_number_live ~__context:(Context.check_for_foreign_database ~__context)  ~self ~nvcpu) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.add_to_VCPUs_params_live" | "VM_add_to_VCPUs_params_live" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.add_to_VCPUs_params_live ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.add_to_VCPUs_params_live ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_NVRAM" | "VM_set_NVRAM" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_NVRAM ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_NVRAM ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.add_to_NVRAM" | "VM_add_to_NVRAM" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.add_to_NVRAM ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.add_to_NVRAM ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.remove_from_NVRAM" | "VM_remove_from_NVRAM" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.remove_from_NVRAM ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.remove_from_NVRAM ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_ha_restart_priority" | "VM_set_ha_restart_priority" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_ha_restart_priority ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_ha_restart_priority ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_ha_always_run" | "VM_set_ha_always_run" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_ha_always_run ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_ha_always_run ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.compute_memory_overhead" | "VM_compute_memory_overhead" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.compute_memory_overhead ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.compute_memory_overhead ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_memory_dynamic_max" | "VM_set_memory_dynamic_max" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_memory_dynamic_max ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_memory_dynamic_max ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_memory_dynamic_min" | "VM_set_memory_dynamic_min" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_memory_dynamic_min ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_memory_dynamic_min ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_memory_dynamic_range" | "VM_set_memory_dynamic_range" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; min_rpc; max_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let min = int64_of_rpc min_rpc in
            let max = int64_of_rpc max_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("min", min_rpc); ("max", max_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_memory_dynamic_range ~__context:(Context.check_for_foreign_database ~__context)  ~self ~min ~max))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_memory_dynamic_range ~__context:(Context.check_for_foreign_database ~__context)  ~self ~min ~max) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_memory_static_max" | "VM_set_memory_static_max" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_memory_static_max ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_memory_static_max ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_memory_static_min" | "VM_set_memory_static_min" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_memory_static_min ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_memory_static_min ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_memory_static_range" | "VM_set_memory_static_range" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; min_rpc; max_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let min = int64_of_rpc min_rpc in
            let max = int64_of_rpc max_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("min", min_rpc); ("max", max_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_memory_static_range ~__context:(Context.check_for_foreign_database ~__context)  ~self ~min ~max))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_memory_static_range ~__context:(Context.check_for_foreign_database ~__context)  ~self ~min ~max) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_memory_limits" | "VM_set_memory_limits" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; static_min_rpc; static_max_rpc; dynamic_min_rpc; dynamic_max_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let static_min = int64_of_rpc static_min_rpc in
            let static_max = int64_of_rpc static_max_rpc in
            let dynamic_min = int64_of_rpc dynamic_min_rpc in
            let dynamic_max = int64_of_rpc dynamic_max_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("static_min", static_min_rpc); ("static_max", static_max_rpc); ("dynamic_min", dynamic_min_rpc); ("dynamic_max", dynamic_max_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_memory_limits ~__context:(Context.check_for_foreign_database ~__context)  ~self ~static_min ~static_max ~dynamic_min ~dynamic_max))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_memory_limits ~__context:(Context.check_for_foreign_database ~__context)  ~self ~static_min ~static_max ~dynamic_min ~dynamic_max) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "5" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_memory" | "VM_set_memory" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_memory ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_memory ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_memory_target_live" | "VM_set_memory_target_live" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; target_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let target = int64_of_rpc target_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("target", target_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_memory_target_live ~__context:(Context.check_for_foreign_database ~__context)  ~self ~target))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_memory_target_live ~__context:(Context.check_for_foreign_database ~__context)  ~self ~target) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.wait_memory_target_live" | "VM_wait_memory_target_live" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.wait_memory_target_live ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.wait_memory_target_live ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_cooperative" | "VM_get_cooperative" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.get_cooperative ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.get_cooperative ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_HVM_shadow_multiplier" | "VM_set_HVM_shadow_multiplier" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = float_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_HVM_shadow_multiplier ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_HVM_shadow_multiplier ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_shadow_multiplier_live" | "VM_set_shadow_multiplier_live" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; multiplier_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let multiplier = float_of_rpc multiplier_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("multiplier", multiplier_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_shadow_multiplier_live ~__context:(Context.check_for_foreign_database ~__context)  ~self ~multiplier))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_shadow_multiplier_live ~__context:(Context.check_for_foreign_database ~__context)  ~self ~multiplier) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_VCPUs_max" | "VM_set_VCPUs_max" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_VCPUs_max ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_VCPUs_max ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_VCPUs_at_startup" | "VM_set_VCPUs_at_startup" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_VCPUs_at_startup ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_VCPUs_at_startup ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.send_sysrq" | "VM_send_sysrq" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; key_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.send_sysrq ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~key))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.send_sysrq ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~key) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.send_trigger" | "VM_send_trigger" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; trigger_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let trigger = string_of_rpc trigger_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("trigger", trigger_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.send_trigger ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~trigger))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.send_trigger ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~trigger) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.maximise_memory" | "VM_maximise_memory" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; total_rpc; approximate_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let total = int64_of_rpc total_rpc in
            let approximate = bool_of_rpc approximate_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("total", total_rpc); ("approximate", approximate_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.maximise_memory ~__context:(Context.check_for_foreign_database ~__context)  ~self ~total ~approximate))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.maximise_memory ~__context:(Context.check_for_foreign_database ~__context)  ~self ~total ~approximate) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.migrate_send" | "VM_migrate_send" -> 
        begin match __params with
        | session_id_rpc :: vm_rpc :: dest_rpc :: live_rpc :: vdi_map_rpc :: vif_map_rpc :: options_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let vgpu_map_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let dest = string_to_string_map_of_rpc dest_rpc in
            let live = bool_of_rpc live_rpc in
            let vdi_map = ref_VDI_to_ref_SR_map_of_rpc vdi_map_rpc in
            let vif_map = ref_VIF_to_ref_network_map_of_rpc vif_map_rpc in
            let options = string_to_string_map_of_rpc options_rpc in
            let vgpu_map = ref_VGPU_to_ref_GPU_group_map_of_rpc vgpu_map_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("dest", dest_rpc); ("live", live_rpc); ("vdi_map", vdi_map_rpc); ("vif_map", vif_map_rpc); ("options", options_rpc); ("vgpu_map", vgpu_map_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.migrate_send ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~dest ~live ~vdi_map ~vif_map ~options ~vgpu_map))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.migrate_send ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~dest ~live ~vdi_map ~vif_map ~options ~vgpu_map) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "6" (string_of_int ((List.length __params) - 1))
        end
    | "VM.assert_can_migrate" | "VM_assert_can_migrate" -> 
        begin match __params with
        | session_id_rpc :: vm_rpc :: dest_rpc :: live_rpc :: vdi_map_rpc :: vif_map_rpc :: options_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let vgpu_map_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let dest = string_to_string_map_of_rpc dest_rpc in
            let live = bool_of_rpc live_rpc in
            let vdi_map = ref_VDI_to_ref_SR_map_of_rpc vdi_map_rpc in
            let vif_map = ref_VIF_to_ref_network_map_of_rpc vif_map_rpc in
            let options = string_to_string_map_of_rpc options_rpc in
            let vgpu_map = ref_VGPU_to_ref_GPU_group_map_of_rpc vgpu_map_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("dest", dest_rpc); ("live", live_rpc); ("vdi_map", vdi_map_rpc); ("vif_map", vif_map_rpc); ("options", options_rpc); ("vgpu_map", vgpu_map_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.assert_can_migrate ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~dest ~live ~vdi_map ~vif_map ~options ~vgpu_map))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.assert_can_migrate ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~dest ~live ~vdi_map ~vif_map ~options ~vgpu_map) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "6" (string_of_int ((List.length __params) - 1))
        end
    | "VM.assert_can_migrate_sender" | "VM_assert_can_migrate_sender" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; dest_rpc; live_rpc; vdi_map_rpc; vif_map_rpc; vgpu_map_rpc; options_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let dest = string_to_string_map_of_rpc dest_rpc in
            let live = bool_of_rpc live_rpc in
            let vdi_map = ref_VDI_to_ref_SR_map_of_rpc vdi_map_rpc in
            let vif_map = ref_VIF_to_ref_network_map_of_rpc vif_map_rpc in
            let vgpu_map = ref_VGPU_to_ref_GPU_group_map_of_rpc vgpu_map_rpc in
            let options = string_to_string_map_of_rpc options_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("dest", dest_rpc); ("live", live_rpc); ("vdi_map", vdi_map_rpc); ("vif_map", vif_map_rpc); ("vgpu_map", vgpu_map_rpc); ("options", options_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.assert_can_migrate_sender ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~dest ~live ~vdi_map ~vif_map ~vgpu_map ~options))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.assert_can_migrate_sender ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~dest ~live ~vdi_map ~vif_map ~vgpu_map ~options) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "7" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_boot_record" | "VM_get_boot_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vM_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.get_boot_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.get_boot_record ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_data_sources" | "VM_get_data_sources" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_data_source_t_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.get_data_sources ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.get_data_sources ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.record_data_source" | "VM_record_data_source" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; data_source_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let data_source = string_of_rpc data_source_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("data_source", data_source_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.record_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~self ~data_source))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.record_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~self ~data_source) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.query_data_source" | "VM_query_data_source" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; data_source_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let data_source = string_of_rpc data_source_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("data_source", data_source_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_float x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.query_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~self ~data_source))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.query_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~self ~data_source) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.forget_data_source_archives" | "VM_forget_data_source_archives" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; data_source_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let data_source = string_of_rpc data_source_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("data_source", data_source_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.forget_data_source_archives ~__context:(Context.check_for_foreign_database ~__context)  ~self ~data_source))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.forget_data_source_archives ~__context:(Context.check_for_foreign_database ~__context)  ~self ~data_source) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.assert_operation_valid" | "VM_assert_operation_valid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; op_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let op = vm_operations_of_rpc op_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("op", op_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.assert_operation_valid ~__context:(Context.check_for_foreign_database ~__context)  ~self ~op))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.assert_operation_valid ~__context:(Context.check_for_foreign_database ~__context)  ~self ~op) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.update_allowed_operations" | "VM_update_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.update_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.update_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_allowed_VBD_devices" | "VM_get_allowed_VBD_devices" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.get_allowed_VBD_devices ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.get_allowed_VBD_devices ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_allowed_VIF_devices" | "VM_get_allowed_VIF_devices" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.get_allowed_VIF_devices ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.get_allowed_VIF_devices ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_possible_hosts" | "VM_get_possible_hosts" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.get_possible_hosts ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.get_possible_hosts ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.assert_can_boot_here" | "VM_assert_can_boot_here" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.assert_can_boot_here ~__context:(Context.check_for_foreign_database ~__context)  ~self ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.assert_can_boot_here ~__context:(Context.check_for_foreign_database ~__context)  ~self ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.atomic_set_resident_on" | "VM_atomic_set_resident_on" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.atomic_set_resident_on ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.atomic_set_resident_on ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.create_new_blob" | "VM_create_new_blob" -> 
        begin match __params with
        | session_id_rpc :: vm_rpc :: name_rpc :: mime_type_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let public_rpc = try List.nth default_args 0 with _ -> Rpc.Bool false in
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let name = string_of_rpc name_rpc in
            let mime_type = string_of_rpc mime_type_rpc in
            let public = bool_of_rpc public_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("name", name_rpc); ("mime_type", mime_type_rpc); ("public", public_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_blob x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.create_new_blob ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~name ~mime_type ~public))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.create_new_blob ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~name ~mime_type ~public) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.s3_suspend" | "VM_s3_suspend" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.s3_suspend ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.s3_suspend ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.s3_resume" | "VM_s3_resume" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.s3_resume ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.s3_resume ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.assert_agile" | "VM_assert_agile" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.assert_agile ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.assert_agile ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.update_snapshot_metadata" | "VM_update_snapshot_metadata" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; snapshot_of_rpc; snapshot_time_rpc; transportable_snapshot_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let snapshot_of = ref_VM_of_rpc snapshot_of_rpc in
            let snapshot_time = datetime_of_rpc snapshot_time_rpc in
            let transportable_snapshot_id = string_of_rpc transportable_snapshot_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("snapshot_of", snapshot_of_rpc); ("snapshot_time", snapshot_time_rpc); ("transportable_snapshot_id", transportable_snapshot_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.update_snapshot_metadata ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~snapshot_of ~snapshot_time ~transportable_snapshot_id))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.update_snapshot_metadata ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~snapshot_of ~snapshot_time ~transportable_snapshot_id) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "VM.retrieve_wlb_recommendations" | "VM_retrieve_wlb_recommendations" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_to_string_set_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.retrieve_wlb_recommendations ~__context:(Context.check_for_foreign_database ~__context)  ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.retrieve_wlb_recommendations ~__context:(Context.check_for_foreign_database ~__context)  ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_bios_strings" | "VM_set_bios_strings" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_bios_strings ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_bios_strings ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.copy_bios_strings" | "VM_copy_bios_strings" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.copy_bios_strings ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.copy_bios_strings ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_protection_policy" | "VM_set_protection_policy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = ref_VMPP_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_protection_policy ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_protection_policy ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_snapshot_schedule" | "VM_set_snapshot_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = ref_VMSS_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_snapshot_schedule ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_snapshot_schedule ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_start_delay" | "VM_set_start_delay" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_start_delay ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_start_delay ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_shutdown_delay" | "VM_set_shutdown_delay" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_shutdown_delay ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_shutdown_delay ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_order" | "VM_set_order" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_order ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_order ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_suspend_VDI" | "VM_set_suspend_VDI" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = ref_VDI_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_suspend_VDI ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_suspend_VDI ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.assert_can_be_recovered" | "VM_assert_can_be_recovered" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; session_to_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let session_to = ref_session_of_rpc session_to_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("session_to", session_to_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.assert_can_be_recovered ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.assert_can_be_recovered ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_SRs_required_for_recovery" | "VM_get_SRs_required_for_recovery" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; session_to_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let session_to = ref_session_of_rpc session_to_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("session_to", session_to_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.get_SRs_required_for_recovery ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.get_SRs_required_for_recovery ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.recover" | "VM_recover" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; session_to_rpc; force_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let session_to = ref_session_of_rpc session_to_rpc in
            let force = bool_of_rpc force_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("session_to", session_to_rpc); ("force", force_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.recover ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to ~force))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.recover ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to ~force) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM.import_convert" | "VM_import_convert" -> 
        begin match __params with
        | [session_id_rpc; _type_rpc; username_rpc; password_rpc; sr_rpc; remote_config_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let _type = string_of_rpc _type_rpc in
            let username = string_of_rpc username_rpc in
            let password = string_of_rpc password_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            let remote_config = string_to_string_map_of_rpc remote_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("_type", _type_rpc); ("username", username_rpc); ("password", password_rpc); ("sr", sr_rpc); ("remote_config", remote_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.import_convert ~__context:(Context.check_for_foreign_database ~__context)  ~_type ~username ~password ~sr ~remote_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.import_convert ~__context:(Context.check_for_foreign_database ~__context)  ~_type ~username ~password ~sr ~remote_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "5" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_appliance" | "VM_set_appliance" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = ref_VM_appliance_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_appliance ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_appliance ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.query_services" | "VM_query_services" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.query_services ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.query_services ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.call_plugin" | "VM_call_plugin" -> 
        begin match __params with
        | [session_id_rpc; vm_rpc; plugin_rpc; fn_rpc; args_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let plugin = string_of_rpc plugin_rpc in
            let fn = string_of_rpc fn_rpc in
            let args = string_to_string_map_of_rpc args_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vm", vm_rpc); ("plugin", plugin_rpc); ("fn", fn_rpc); ("args", args_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.call_plugin ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~plugin ~fn ~args))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.call_plugin ~__context:(Context.check_for_foreign_database ~__context)  ~vm ~plugin ~fn ~args) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_has_vendor_device" | "VM_set_has_vendor_device" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_has_vendor_device ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_has_vendor_device ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.import" | "VM_import" -> 
        begin match __params with
        | [session_id_rpc; url_rpc; sr_rpc; full_restore_rpc; force_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let url = string_of_rpc url_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            let full_restore = bool_of_rpc full_restore_rpc in
            let force = bool_of_rpc force_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("url", url_rpc); ("sr", sr_rpc); ("full_restore", full_restore_rpc); ("force", force_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.import ~__context:(Context.check_for_foreign_database ~__context)  ~url ~sr ~full_restore ~force))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.import ~__context:(Context.check_for_foreign_database ~__context)  ~url ~sr ~full_restore ~force) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_actions_after_crash" | "VM_set_actions_after_crash" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = on_crash_behaviour_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_actions_after_crash ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_actions_after_crash ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_domain_type" | "VM_set_domain_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = domain_type_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_domain_type ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_domain_type ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_HVM_boot_policy" | "VM_set_HVM_boot_policy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_HVM_boot_policy ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_HVM_boot_policy ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.set_NVRAM_EFI_variables" | "VM_set_NVRAM_EFI_variables" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM.set_NVRAM_EFI_variables ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM.set_NVRAM_EFI_variables ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_all" | "VM_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_all_records_where" | "VM_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_to_vM_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM.get_all_records" | "VM_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_to_vM_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_record" | "VM_metrics_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vM_metrics_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_by_uuid" | "VM_metrics_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_metrics x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_uuid" | "VM_metrics_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_memory_actual" | "VM_metrics_get_memory_actual" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_memory_actual ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_memory_actual";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_VCPUs_number" | "VM_metrics_get_VCPUs_number" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_VCPUs_number ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_VCPUs_number";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_VCPUs_utilisation" | "VM_metrics_get_VCPUs_utilisation" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_VCPUs_CPU" | "VM_metrics_get_VCPUs_CPU" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64_to_int64_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_VCPUs_CPU ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_VCPUs_CPU";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_VCPUs_params" | "VM_metrics_get_VCPUs_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_VCPUs_params ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_VCPUs_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_VCPUs_flags" | "VM_metrics_get_VCPUs_flags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64_to_string_set_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_VCPUs_flags ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_VCPUs_flags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_state" | "VM_metrics_get_state" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_state ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_state";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_start_time" | "VM_metrics_get_start_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_start_time ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_start_time";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_install_time" | "VM_metrics_get_install_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_install_time ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_install_time";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_last_updated" | "VM_metrics_get_last_updated" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_last_updated ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_last_updated";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_other_config" | "VM_metrics_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_hvm" | "VM_metrics_get_hvm" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_hvm ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_hvm";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_nested_virt" | "VM_metrics_get_nested_virt" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_nested_virt ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_nested_virt";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_nomigrate" | "VM_metrics_get_nomigrate" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_nomigrate ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_nomigrate";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_current_domain_type" | "VM_metrics_get_current_domain_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_domain_type x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_current_domain_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_current_domain_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.set_other_config" | "VM_metrics_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM_metrics.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.add_to_other_config" | "VM_metrics_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM_metrics.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.remove_from_other_config" | "VM_metrics_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM_metrics.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_all" | "VM_metrics_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_metrics_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_all_records_where" | "VM_metrics_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_metrics_to_vM_metrics_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_metrics.get_all_records" | "VM_metrics_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_metrics_to_vM_metrics_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_metrics.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_metrics.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_record" | "VM_guest_metrics_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vM_guest_metrics_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_by_uuid" | "VM_guest_metrics_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_guest_metrics x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_uuid" | "VM_guest_metrics_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_os_version" | "VM_guest_metrics_get_os_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_os_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_os_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_PV_drivers_version" | "VM_guest_metrics_get_PV_drivers_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_PV_drivers_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_PV_drivers_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_PV_drivers_up_to_date" | "VM_guest_metrics_get_PV_drivers_up_to_date" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_PV_drivers_up_to_date ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_PV_drivers_up_to_date";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_memory" | "VM_guest_metrics_get_memory" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_disks" | "VM_guest_metrics_get_disks" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_networks" | "VM_guest_metrics_get_networks" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_networks ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_networks";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_other" | "VM_guest_metrics_get_other" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_other ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_other";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_last_updated" | "VM_guest_metrics_get_last_updated" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_last_updated ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_last_updated";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_other_config" | "VM_guest_metrics_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_live" | "VM_guest_metrics_get_live" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_live ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_live";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_can_use_hotplug_vbd" | "VM_guest_metrics_get_can_use_hotplug_vbd" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_tristate_type x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_can_use_hotplug_vbd ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_can_use_hotplug_vbd";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_can_use_hotplug_vif" | "VM_guest_metrics_get_can_use_hotplug_vif" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_tristate_type x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_can_use_hotplug_vif ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_can_use_hotplug_vif";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_PV_drivers_detected" | "VM_guest_metrics_get_PV_drivers_detected" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_PV_drivers_detected ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_PV_drivers_detected";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.set_other_config" | "VM_guest_metrics_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM_guest_metrics.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.add_to_other_config" | "VM_guest_metrics_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM_guest_metrics.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.remove_from_other_config" | "VM_guest_metrics_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_guest_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM_guest_metrics.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_all" | "VM_guest_metrics_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_guest_metrics_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_all_records_where" | "VM_guest_metrics_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_guest_metrics_to_vM_guest_metrics_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_guest_metrics.get_all_records" | "VM_guest_metrics_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_guest_metrics_to_vM_guest_metrics_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_guest_metrics.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_guest_metrics.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_record" | "VMPP_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_by_uuid" | "VMPP_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.create" | "VMPP_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.destroy" | "VMPP_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_by_name_label" | "VMPP_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_uuid" | "VMPP_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_name_label" | "VMPP_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMPP_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMPP.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMPP.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_name_description" | "VMPP_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMPP_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMPP.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMPP.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_is_policy_enabled" | "VMPP_get_is_policy_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_backup_type" | "VMPP_get_backup_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_backup_retention_value" | "VMPP_get_backup_retention_value" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_backup_frequency" | "VMPP_get_backup_frequency" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_backup_schedule" | "VMPP_get_backup_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_is_backup_running" | "VMPP_get_is_backup_running" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_backup_last_run_time" | "VMPP_get_backup_last_run_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_archive_target_type" | "VMPP_get_archive_target_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_archive_target_config" | "VMPP_get_archive_target_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_archive_frequency" | "VMPP_get_archive_frequency" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_archive_schedule" | "VMPP_get_archive_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_is_archive_running" | "VMPP_get_is_archive_running" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_archive_last_run_time" | "VMPP_get_archive_last_run_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_VMs" | "VMPP_get_VMs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_is_alarm_enabled" | "VMPP_get_is_alarm_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_alarm_config" | "VMPP_get_alarm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_recent_alerts" | "VMPP_get_recent_alerts" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_name_label" | "VMPP_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMPP_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMPP.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VMPP.set_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_name_description" | "VMPP_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMPP_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMPP.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VMPP.set_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_is_policy_enabled" | "VMPP_set_is_policy_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_backup_type" | "VMPP_set_backup_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.protect_now" | "VMPP_protect_now" -> 
        begin match __params with
        | [session_id_rpc; vmpp_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.archive_now" | "VMPP_archive_now" -> 
        begin match __params with
        | [session_id_rpc; snapshot_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.create_alert" | "VMPP_create_alert" -> 
        begin match __params with
        | [session_id_rpc; vmpp_rpc; name_rpc; priority_rpc; body_rpc; data_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "5" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_alerts" | "VMPP_get_alerts" -> 
        begin match __params with
        | [session_id_rpc; vmpp_rpc; hours_from_now_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_backup_retention_value" | "VMPP_set_backup_retention_value" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_is_backup_running" | "VMPP_set_is_backup_running" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_is_archive_running" | "VMPP_set_is_archive_running" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_backup_frequency" | "VMPP_set_backup_frequency" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_backup_schedule" | "VMPP_set_backup_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_archive_frequency" | "VMPP_set_archive_frequency" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_archive_schedule" | "VMPP_set_archive_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_archive_target_type" | "VMPP_set_archive_target_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_archive_target_config" | "VMPP_set_archive_target_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_is_alarm_enabled" | "VMPP_set_is_alarm_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_alarm_config" | "VMPP_set_alarm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.add_to_backup_schedule" | "VMPP_add_to_backup_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.add_to_archive_target_config" | "VMPP_add_to_archive_target_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.add_to_archive_schedule" | "VMPP_add_to_archive_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.add_to_alarm_config" | "VMPP_add_to_alarm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.remove_from_backup_schedule" | "VMPP_remove_from_backup_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.remove_from_archive_target_config" | "VMPP_remove_from_archive_target_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.remove_from_archive_schedule" | "VMPP_remove_from_archive_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.remove_from_alarm_config" | "VMPP_remove_from_alarm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_backup_last_run_time" | "VMPP_set_backup_last_run_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.set_archive_last_run_time" | "VMPP_set_archive_last_run_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_all" | "VMPP_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_all_records_where" | "VMPP_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMPP.get_all_records" | "VMPP_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_record" | "VMSS_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vMSS_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_by_uuid" | "VMSS_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VMSS x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.create" | "VMSS_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let name_label = string_of_rpc ((List.assoc_opt "name_label" __structure) |> Option.value ~default:(Rpc.String "")) in
            let name_description = string_of_rpc ((List.assoc_opt "name_description" __structure) |> Option.value ~default:(Rpc.String "")) in
            let enabled = bool_of_rpc ((List.assoc_opt "enabled" __structure) |> Option.value ~default:(Rpc.Bool true)) in
            let _type = vmss_type_of_rpc (my_assoc "type" __structure) in
            let retained_snapshots = int64_of_rpc ((List.assoc_opt "retained_snapshots" __structure) |> Option.value ~default:(Rpc.Int (7L))) in
            let frequency = vmss_frequency_of_rpc (my_assoc "frequency" __structure) in
            let schedule = string_to_string_map_of_rpc ((List.assoc_opt "schedule" __structure) |> Option.value ~default:(Rpc.Dict [])) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VMSS x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VMSS.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~enabled ~_type ~retained_snapshots ~frequency ~schedule))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VMSS.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~enabled ~_type ~retained_snapshots ~frequency ~schedule) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.destroy" | "VMSS_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VMSS.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VMSS.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_by_name_label" | "VMSS_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VMSS_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_uuid" | "VMSS_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_name_label" | "VMSS_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_name_description" | "VMSS_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_enabled" | "VMSS_get_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_type" | "VMSS_get_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vmss_type x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_retained_snapshots" | "VMSS_get_retained_snapshots" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_retained_snapshots ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_retained_snapshots";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_frequency" | "VMSS_get_frequency" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vmss_frequency x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_frequency ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_frequency";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_schedule" | "VMSS_get_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_schedule ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_schedule";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_last_run_time" | "VMSS_get_last_run_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_last_run_time ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_last_run_time";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_VMs" | "VMSS_get_VMs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_VMs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_VMs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.set_name_label" | "VMSS_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VMSS.set_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.set_name_description" | "VMSS_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VMSS.set_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.set_enabled" | "VMSS_set_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.set_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VMSS.set_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.snapshot_now" | "VMSS_snapshot_now" -> 
        begin match __params with
        | [session_id_rpc; vmss_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vmss = ref_VMSS_of_rpc vmss_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vmss", vmss_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VMSS.snapshot_now ~__context:(Context.check_for_foreign_database ~__context)  ~vmss))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VMSS.snapshot_now ~__context:(Context.check_for_foreign_database ~__context)  ~vmss) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.set_retained_snapshots" | "VMSS_set_retained_snapshots" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VMSS.set_retained_snapshots ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VMSS.set_retained_snapshots ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.set_frequency" | "VMSS_set_frequency" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            let value = vmss_frequency_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VMSS.set_frequency ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VMSS.set_frequency ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.set_schedule" | "VMSS_set_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VMSS.set_schedule ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VMSS.set_schedule ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.add_to_schedule" | "VMSS_add_to_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VMSS.add_to_schedule ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VMSS.add_to_schedule ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.remove_from_schedule" | "VMSS_remove_from_schedule" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VMSS.remove_from_schedule ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VMSS.remove_from_schedule ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.set_last_run_time" | "VMSS_set_last_run_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            let value = datetime_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VMSS.set_last_run_time ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VMSS.set_last_run_time ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.set_type" | "VMSS_set_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VMSS_of_rpc self_rpc in
            let value = vmss_type_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VMSS.set_type ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VMSS.set_type ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_all" | "VMSS_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VMSS_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_all_records_where" | "VMSS_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VMSS_to_vMSS_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VMSS.get_all_records" | "VMSS_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VMSS_to_vMSS_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VMSS.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VMSS.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_record" | "VM_appliance_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vM_appliance_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_by_uuid" | "VM_appliance_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_appliance x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.create" | "VM_appliance_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let name_label = string_of_rpc ((List.assoc_opt "name_label" __structure) |> Option.value ~default:(Rpc.String "")) in
            let name_description = string_of_rpc ((List.assoc_opt "name_description" __structure) |> Option.value ~default:(Rpc.String "")) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_appliance x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM_appliance.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM_appliance.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.destroy" | "VM_appliance_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM_appliance.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM_appliance.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_by_name_label" | "VM_appliance_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_appliance_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_uuid" | "VM_appliance_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_name_label" | "VM_appliance_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_name_description" | "VM_appliance_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_allowed_operations" | "VM_appliance_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vm_appliance_operation_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_current_operations" | "VM_appliance_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_vm_appliance_operation_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_VMs" | "VM_appliance_get_VMs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_VMs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_VMs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.set_name_label" | "VM_appliance_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM_appliance.set_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.set_name_description" | "VM_appliance_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VM_appliance.set_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.start" | "VM_appliance_start" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; paused_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            let paused = bool_of_rpc paused_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("paused", paused_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM_appliance.start ~__context:(Context.check_for_foreign_database ~__context)  ~self ~paused))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM_appliance.start ~__context:(Context.check_for_foreign_database ~__context)  ~self ~paused) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.clean_shutdown" | "VM_appliance_clean_shutdown" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM_appliance.clean_shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM_appliance.clean_shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.hard_shutdown" | "VM_appliance_hard_shutdown" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM_appliance.hard_shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM_appliance.hard_shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.shutdown" | "VM_appliance_shutdown" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM_appliance.shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM_appliance.shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.assert_can_be_recovered" | "VM_appliance_assert_can_be_recovered" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; session_to_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            let session_to = ref_session_of_rpc session_to_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("session_to", session_to_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM_appliance.assert_can_be_recovered ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM_appliance.assert_can_be_recovered ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_SRs_required_for_recovery" | "VM_appliance_get_SRs_required_for_recovery" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; session_to_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            let session_to = ref_session_of_rpc session_to_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("session_to", session_to_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM_appliance.get_SRs_required_for_recovery ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM_appliance.get_SRs_required_for_recovery ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.recover" | "VM_appliance_recover" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; session_to_rpc; force_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VM_appliance_of_rpc self_rpc in
            let session_to = ref_session_of_rpc session_to_rpc in
            let force = bool_of_rpc force_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("session_to", session_to_rpc); ("force", force_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VM_appliance.recover ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to ~force))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VM_appliance.recover ~__context:(Context.check_for_foreign_database ~__context)  ~self ~session_to ~force) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_all" | "VM_appliance_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_appliance_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_all_records_where" | "VM_appliance_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_appliance_to_vM_appliance_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VM_appliance.get_all_records" | "VM_appliance_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_appliance_to_vM_appliance_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VM_appliance.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VM_appliance.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "DR_task.get_record" | "DR_task_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_DR_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_dR_task_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.DR_task.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "DR_task.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "DR_task.get_by_uuid" | "DR_task_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_DR_task x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.DR_task.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "DR_task.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "DR_task.get_uuid" | "DR_task_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_DR_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.DR_task.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "DR_task.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "DR_task.get_introduced_SRs" | "DR_task_get_introduced_SRs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_DR_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.DR_task.get_introduced_SRs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "DR_task.get_introduced_SRs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "DR_task.create" | "DR_task_create" -> 
        begin match __params with
        | [session_id_rpc; _type_rpc; device_config_rpc; whitelist_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let _type = string_of_rpc _type_rpc in
            let device_config = string_to_string_map_of_rpc device_config_rpc in
            let whitelist = string_set_of_rpc whitelist_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("_type", _type_rpc); ("device_config", device_config_rpc); ("whitelist", whitelist_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_DR_task x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.DR_task.create ~__context:(Context.check_for_foreign_database ~__context)  ~_type ~device_config ~whitelist))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.DR_task.create ~__context:(Context.check_for_foreign_database ~__context)  ~_type ~device_config ~whitelist) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "DR_task.destroy" | "DR_task_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_DR_task_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.DR_task.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.DR_task.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "DR_task.get_all" | "DR_task_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_DR_task_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.DR_task.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "DR_task.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "DR_task.get_all_records_where" | "DR_task_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_DR_task_to_dR_task_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.DR_task.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "DR_task.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "DR_task.get_all_records" | "DR_task_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_DR_task_to_dR_task_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.DR_task.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "DR_task.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_record" | "host_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_host_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_by_uuid" | "host_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_by_name_label" | "host_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_uuid" | "host_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_name_label" | "host_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_name_description" | "host_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_memory_overhead" | "host_get_memory_overhead" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_memory_overhead ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_memory_overhead";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_allowed_operations" | "host_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_host_allowed_operations_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_current_operations" | "host_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_host_allowed_operations_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_API_version_major" | "host_get_API_version_major" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_API_version_major ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_API_version_major";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_API_version_minor" | "host_get_API_version_minor" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_API_version_minor ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_API_version_minor";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_API_version_vendor" | "host_get_API_version_vendor" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_API_version_vendor ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_API_version_vendor";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_API_version_vendor_implementation" | "host_get_API_version_vendor_implementation" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_API_version_vendor_implementation ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_API_version_vendor_implementation";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_enabled" | "host_get_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_software_version" | "host_get_software_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_software_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_software_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_other_config" | "host_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_capabilities" | "host_get_capabilities" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_capabilities ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_capabilities";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_cpu_configuration" | "host_get_cpu_configuration" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_cpu_configuration ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_cpu_configuration";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_sched_policy" | "host_get_sched_policy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_sched_policy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_sched_policy";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_supported_bootloaders" | "host_get_supported_bootloaders" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_supported_bootloaders ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_supported_bootloaders";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_resident_VMs" | "host_get_resident_VMs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_resident_VMs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_resident_VMs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_logging" | "host_get_logging" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_logging ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_logging";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_PIFs" | "host_get_PIFs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_PIFs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_PIFs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_suspend_image_sr" | "host_get_suspend_image_sr" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_suspend_image_sr ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_suspend_image_sr";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_crash_dump_sr" | "host_get_crash_dump_sr" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_crash_dump_sr ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_crash_dump_sr";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_crashdumps" | "host_get_crashdumps" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_crashdump_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_crashdumps ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_crashdumps";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_patches" | "host_get_patches" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_patch_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_patches ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_patches";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_updates" | "host_get_updates" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_update_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_updates ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_updates";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_PBDs" | "host_get_PBDs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PBD_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_PBDs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_PBDs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_host_CPUs" | "host_get_host_CPUs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_cpu_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_host_CPUs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_host_CPUs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_cpu_info" | "host_get_cpu_info" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_cpu_info ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_cpu_info";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_hostname" | "host_get_hostname" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_hostname ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_hostname";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_address" | "host_get_address" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_address ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_address";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_metrics" | "host_get_metrics" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_metrics x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_metrics ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_metrics";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_license_params" | "host_get_license_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_license_params ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_license_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_ha_statefiles" | "host_get_ha_statefiles" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_ha_statefiles ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_ha_statefiles";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_ha_network_peers" | "host_get_ha_network_peers" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_ha_network_peers ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_ha_network_peers";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_blobs" | "host_get_blobs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_ref_blob_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_blobs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_blobs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_tags" | "host_get_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_external_auth_type" | "host_get_external_auth_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_external_auth_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_external_auth_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_external_auth_service_name" | "host_get_external_auth_service_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_external_auth_service_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_external_auth_service_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_external_auth_configuration" | "host_get_external_auth_configuration" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_external_auth_configuration ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_external_auth_configuration";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_edition" | "host_get_edition" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_edition ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_edition";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_license_server" | "host_get_license_server" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_license_server ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_license_server";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_bios_strings" | "host_get_bios_strings" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_bios_strings ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_bios_strings";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_power_on_mode" | "host_get_power_on_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_power_on_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_power_on_mode";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_power_on_config" | "host_get_power_on_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_power_on_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_power_on_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_local_cache_sr" | "host_get_local_cache_sr" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_local_cache_sr ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_local_cache_sr";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_chipset_info" | "host_get_chipset_info" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_chipset_info ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_chipset_info";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_PCIs" | "host_get_PCIs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PCI_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_PCIs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_PCIs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_PGPUs" | "host_get_PGPUs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PGPU_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_PGPUs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_PGPUs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_PUSBs" | "host_get_PUSBs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PUSB_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_PUSBs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_PUSBs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_ssl_legacy" | "host_get_ssl_legacy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_ssl_legacy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_ssl_legacy";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_guest_VCPUs_params" | "host_get_guest_VCPUs_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_guest_VCPUs_params ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_guest_VCPUs_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_display" | "host_get_display" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_host_display x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_display ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_display";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_virtual_hardware_platform_versions" | "host_get_virtual_hardware_platform_versions" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_virtual_hardware_platform_versions ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_virtual_hardware_platform_versions";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_control_domain" | "host_get_control_domain" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_control_domain ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_control_domain";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_updates_requiring_reboot" | "host_get_updates_requiring_reboot" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_update_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_updates_requiring_reboot ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_updates_requiring_reboot";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_features" | "host_get_features" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Feature_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_features ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_features";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_iscsi_iqn" | "host_get_iscsi_iqn" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_iscsi_iqn ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_iscsi_iqn";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_multipathing" | "host_get_multipathing" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_multipathing ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_multipathing";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_uefi_certificates" | "host_get_uefi_certificates" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_uefi_certificates ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_uefi_certificates";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_certificates" | "host_get_certificates" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Certificate_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_certificates ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_certificates";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_editions" | "host_get_editions" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_editions ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_editions";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_https_only" | "host_get_https_only" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_https_only ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_https_only";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_name_label" | "host_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_name_description" | "host_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_other_config" | "host_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.add_to_other_config" | "host_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = ["folder"; "XenCenter.CustomFields.*"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.remove_from_other_config" | "host_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = ["folder"; "XenCenter.CustomFields.*"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_logging" | "host_set_logging" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_logging ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_logging";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.add_to_logging" | "host_add_to_logging" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.add_to_logging ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.add_to_logging";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.remove_from_logging" | "host_remove_from_logging" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.remove_from_logging ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.remove_from_logging";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_suspend_image_sr" | "host_set_suspend_image_sr" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = ref_SR_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_suspend_image_sr ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_suspend_image_sr";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_crash_dump_sr" | "host_set_crash_dump_sr" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = ref_SR_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_crash_dump_sr ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_crash_dump_sr";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_hostname" | "host_set_hostname" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_hostname ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_hostname";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_address" | "host_set_address" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_address ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_address";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_tags" | "host_set_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_set_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.add_tags" | "host_add_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.add_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.add_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.remove_tags" | "host_remove_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.remove_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.remove_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_license_server" | "host_set_license_server" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_license_server ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_license_server";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.add_to_license_server" | "host_add_to_license_server" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.add_to_license_server ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.add_to_license_server";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.remove_from_license_server" | "host_remove_from_license_server" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.remove_from_license_server ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.remove_from_license_server";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_guest_VCPUs_params" | "host_set_guest_VCPUs_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_guest_VCPUs_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_guest_VCPUs_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.add_to_guest_VCPUs_params" | "host_add_to_guest_VCPUs_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.add_to_guest_VCPUs_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.add_to_guest_VCPUs_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.remove_from_guest_VCPUs_params" | "host_remove_from_guest_VCPUs_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.remove_from_guest_VCPUs_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.remove_from_guest_VCPUs_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_display" | "host_set_display" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = host_display_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.set_display ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host.set_display";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.disable" | "host_disable" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.disable ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.disable ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.enable" | "host_enable" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.enable ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.enable ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.shutdown" | "host_shutdown" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.shutdown ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.reboot" | "host_reboot" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.reboot ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.reboot ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.prepare_for_poweroff" | "host_prepare_for_poweroff" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.prepare_for_poweroff ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.prepare_for_poweroff ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.dmesg" | "host_dmesg" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.dmesg ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.dmesg ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.dmesg_clear" | "host_dmesg_clear" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.dmesg_clear ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.dmesg_clear ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_log" | "host_get_log" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_log ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_log ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.send_debug_keys" | "host_send_debug_keys" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; keys_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let keys = string_of_rpc keys_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("keys", keys_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.send_debug_keys ~__context:(Context.check_for_foreign_database ~__context)  ~host ~keys))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.send_debug_keys ~__context:(Context.check_for_foreign_database ~__context)  ~host ~keys) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.bugreport_upload" | "host_bugreport_upload" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; url_rpc; options_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let url = string_of_rpc url_rpc in
            let options = string_to_string_map_of_rpc options_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("url", url_rpc); ("options", options_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.bugreport_upload ~__context:(Context.check_for_foreign_database ~__context)  ~host ~url ~options))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.bugreport_upload ~__context:(Context.check_for_foreign_database ~__context)  ~host ~url ~options) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.list_methods" | "host_list_methods" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.list_methods ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.list_methods ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host.license_apply" | "host_license_apply" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; contents_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.license_add" | "host_license_add" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; contents_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let contents = string_of_rpc contents_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("contents", contents_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.license_add ~__context:(Context.check_for_foreign_database ~__context)  ~host ~contents))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.license_add ~__context:(Context.check_for_foreign_database ~__context)  ~host ~contents) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.license_remove" | "host_license_remove" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.license_remove ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.license_remove ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.create" | "host_create" -> 
        begin match __params with
        | session_id_rpc :: uuid_rpc :: name_label_rpc :: name_description_rpc :: hostname_rpc :: address_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let external_auth_type_rpc = try List.nth default_args 0 with _ -> Rpc.String "" in
            let external_auth_service_name_rpc = try List.nth default_args 1 with _ -> Rpc.String "" in
            let external_auth_configuration_rpc = try List.nth default_args 2 with _ -> Rpc.Dict [] in
            let license_params_rpc = try List.nth default_args 3 with _ -> Rpc.Dict [] in
            let edition_rpc = try List.nth default_args 4 with _ -> Rpc.String "" in
            let license_server_rpc = try List.nth default_args 5 with _ -> Rpc.Dict [("address",Rpc.String "localhost");("port",Rpc.String "27000")] in
            let local_cache_sr_rpc = try List.nth default_args 6 with _ -> Rpc.String "OpaqueRef:NULL" in
            let chipset_info_rpc = try List.nth default_args 7 with _ -> Rpc.Dict [] in
            let ssl_legacy_rpc = try List.nth default_args 8 with _ -> Rpc.Bool true in
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            let name_label = string_of_rpc name_label_rpc in
            let name_description = string_of_rpc name_description_rpc in
            let hostname = string_of_rpc hostname_rpc in
            let address = string_of_rpc address_rpc in
            let external_auth_type = string_of_rpc external_auth_type_rpc in
            let external_auth_service_name = string_of_rpc external_auth_service_name_rpc in
            let external_auth_configuration = string_to_string_map_of_rpc external_auth_configuration_rpc in
            let license_params = string_to_string_map_of_rpc license_params_rpc in
            let edition = string_of_rpc edition_rpc in
            let license_server = string_to_string_map_of_rpc license_server_rpc in
            let local_cache_sr = ref_SR_of_rpc local_cache_sr_rpc in
            let chipset_info = string_to_string_map_of_rpc chipset_info_rpc in
            let ssl_legacy = bool_of_rpc ssl_legacy_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc); ("name_label", name_label_rpc); ("name_description", name_description_rpc); ("hostname", hostname_rpc); ("address", address_rpc); ("external_auth_type", external_auth_type_rpc); ("external_auth_service_name", external_auth_service_name_rpc); ("external_auth_configuration", external_auth_configuration_rpc); ("license_params", license_params_rpc); ("edition", edition_rpc); ("license_server", license_server_rpc); ("local_cache_sr", local_cache_sr_rpc); ("chipset_info", chipset_info_rpc); ("ssl_legacy", ssl_legacy_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.create ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~name_label ~name_description ~hostname ~address ~external_auth_type ~external_auth_service_name ~external_auth_configuration ~license_params ~edition ~license_server ~local_cache_sr ~chipset_info ~ssl_legacy))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.create ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~name_label ~name_description ~hostname ~address ~external_auth_type ~external_auth_service_name ~external_auth_configuration ~license_params ~edition ~license_server ~local_cache_sr ~chipset_info ~ssl_legacy) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "5" (string_of_int ((List.length __params) - 1))
        end
    | "host.destroy" | "host_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.power_on" | "host_power_on" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.power_on ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.power_on ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_license_params" | "host_set_license_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.set_license_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.set_license_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.emergency_ha_disable" | "host_emergency_ha_disable" -> 
        begin match __params with
        | session_id_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let soft_rpc = try List.nth default_args 0 with _ -> Rpc.Bool false in
            let session_id = ref_session_of_rpc session_id_rpc in
            let soft = bool_of_rpc soft_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("soft", soft_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.emergency_ha_disable ~__context:(Context.check_for_foreign_database ~__context)  ~soft))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.emergency_ha_disable ~__context:(Context.check_for_foreign_database ~__context)  ~soft) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host.ha_disarm_fencing" | "host_ha_disarm_fencing" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.ha_disarm_fencing ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.ha_disarm_fencing ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.preconfigure_ha" | "host_preconfigure_ha" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; statefiles_rpc; metadata_vdi_rpc; generation_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let statefiles = ref_VDI_set_of_rpc statefiles_rpc in
            let metadata_vdi = ref_VDI_of_rpc metadata_vdi_rpc in
            let generation = string_of_rpc generation_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("statefiles", statefiles_rpc); ("metadata_vdi", metadata_vdi_rpc); ("generation", generation_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.preconfigure_ha ~__context:(Context.check_for_foreign_database ~__context)  ~host ~statefiles ~metadata_vdi ~generation))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.preconfigure_ha ~__context:(Context.check_for_foreign_database ~__context)  ~host ~statefiles ~metadata_vdi ~generation) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "host.ha_join_liveset" | "host_ha_join_liveset" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.ha_join_liveset ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.ha_join_liveset ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.ha_disable_failover_decisions" | "host_ha_disable_failover_decisions" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.ha_disable_failover_decisions ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.ha_disable_failover_decisions ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.ha_wait_for_shutdown_via_statefile" | "host_ha_wait_for_shutdown_via_statefile" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.ha_wait_for_shutdown_via_statefile ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.ha_wait_for_shutdown_via_statefile ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.ha_stop_daemon" | "host_ha_stop_daemon" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.ha_stop_daemon ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.ha_stop_daemon ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.ha_release_resources" | "host_ha_release_resources" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.ha_release_resources ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.ha_release_resources ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.ha_xapi_healthcheck" | "host_ha_xapi_healthcheck" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.ha_xapi_healthcheck ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.ha_xapi_healthcheck ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host.local_assert_healthy" | "host_local_assert_healthy" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.local_assert_healthy ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.local_assert_healthy ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host.request_backup" | "host_request_backup" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; generation_rpc; force_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let generation = int64_of_rpc generation_rpc in
            let force = bool_of_rpc force_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("generation", generation_rpc); ("force", force_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.request_backup ~__context:(Context.check_for_foreign_database ~__context)  ~host ~generation ~force))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.request_backup ~__context:(Context.check_for_foreign_database ~__context)  ~host ~generation ~force) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.request_config_file_sync" | "host_request_config_file_sync" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; hash_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let hash = string_of_rpc hash_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("hash", hash_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.request_config_file_sync ~__context:(Context.check_for_foreign_database ~__context)  ~host ~hash))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.request_config_file_sync ~__context:(Context.check_for_foreign_database ~__context)  ~host ~hash) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.propose_new_master" | "host_propose_new_master" -> 
        begin match __params with
        | [session_id_rpc; address_rpc; manual_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let address = string_of_rpc address_rpc in
            let manual = bool_of_rpc manual_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("address", address_rpc); ("manual", manual_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.propose_new_master ~__context:(Context.check_for_foreign_database ~__context)  ~address ~manual))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.propose_new_master ~__context:(Context.check_for_foreign_database ~__context)  ~address ~manual) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.commit_new_master" | "host_commit_new_master" -> 
        begin match __params with
        | [session_id_rpc; address_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let address = string_of_rpc address_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("address", address_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.commit_new_master ~__context:(Context.check_for_foreign_database ~__context)  ~address))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.commit_new_master ~__context:(Context.check_for_foreign_database ~__context)  ~address) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.abort_new_master" | "host_abort_new_master" -> 
        begin match __params with
        | [session_id_rpc; address_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let address = string_of_rpc address_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("address", address_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.abort_new_master ~__context:(Context.check_for_foreign_database ~__context)  ~address))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.abort_new_master ~__context:(Context.check_for_foreign_database ~__context)  ~address) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_data_sources" | "host_get_data_sources" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_data_source_t_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_data_sources ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_data_sources ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.record_data_source" | "host_record_data_source" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; data_source_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let data_source = string_of_rpc data_source_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("data_source", data_source_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.record_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~host ~data_source))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.record_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~host ~data_source) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.query_data_source" | "host_query_data_source" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; data_source_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let data_source = string_of_rpc data_source_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("data_source", data_source_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_float x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.query_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~host ~data_source))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.query_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~host ~data_source) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.forget_data_source_archives" | "host_forget_data_source_archives" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; data_source_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let data_source = string_of_rpc data_source_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("data_source", data_source_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.forget_data_source_archives ~__context:(Context.check_for_foreign_database ~__context)  ~host ~data_source))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.forget_data_source_archives ~__context:(Context.check_for_foreign_database ~__context)  ~host ~data_source) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.assert_can_evacuate" | "host_assert_can_evacuate" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.assert_can_evacuate ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.assert_can_evacuate ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_vms_which_prevent_evacuation" | "host_get_vms_which_prevent_evacuation" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_to_string_set_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_vms_which_prevent_evacuation ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_vms_which_prevent_evacuation ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_uncooperative_resident_VMs" | "host_get_uncooperative_resident_VMs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_uncooperative_resident_VMs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_uncooperative_resident_VMs ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_uncooperative_domains" | "host_get_uncooperative_domains" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_uncooperative_domains ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_uncooperative_domains ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.evacuate" | "host_evacuate" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.evacuate ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.evacuate ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.signal_networking_change" | "host_signal_networking_change" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.signal_networking_change ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.signal_networking_change ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host.notify" | "host_notify" -> 
        begin match __params with
        | [session_id_rpc; ty_rpc; params_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let ty = string_of_rpc ty_rpc in
            let params = string_of_rpc params_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("ty", ty_rpc); ("params", params_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.notify ~__context:(Context.check_for_foreign_database ~__context)  ~ty ~params))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.notify ~__context:(Context.check_for_foreign_database ~__context)  ~ty ~params) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.syslog_reconfigure" | "host_syslog_reconfigure" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.syslog_reconfigure ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.syslog_reconfigure ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.management_reconfigure" | "host_management_reconfigure" -> 
        begin match __params with
        | [session_id_rpc; pif_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let pif = ref_PIF_of_rpc pif_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("pif", pif_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.management_reconfigure ~__context:(Context.check_for_foreign_database ~__context)  ~pif))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.management_reconfigure ~__context:(Context.check_for_foreign_database ~__context)  ~pif) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.local_management_reconfigure" | "host_local_management_reconfigure" -> 
        begin match __params with
        | [session_id_rpc; interface_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let interface = string_of_rpc interface_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("interface", interface_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.local_management_reconfigure ~__context:(Context.check_for_foreign_database ~__context)  ~interface))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.local_management_reconfigure ~__context:(Context.check_for_foreign_database ~__context)  ~interface) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.management_disable" | "host_management_disable" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.management_disable ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.management_disable ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_management_interface" | "host_get_management_interface" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_management_interface ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_management_interface ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_system_status_capabilities" | "host_get_system_status_capabilities" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_system_status_capabilities ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_system_status_capabilities ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_diagnostic_timing_stats" | "host_get_diagnostic_timing_stats" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_diagnostic_timing_stats ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_diagnostic_timing_stats ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.restart_agent" | "host_restart_agent" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.restart_agent ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.restart_agent ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.shutdown_agent" | "host_shutdown_agent" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.shutdown_agent ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.shutdown_agent ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_hostname_live" | "host_set_hostname_live" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; hostname_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let hostname = string_of_rpc hostname_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("hostname", hostname_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.set_hostname_live ~__context:(Context.check_for_foreign_database ~__context)  ~host ~hostname))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.set_hostname_live ~__context:(Context.check_for_foreign_database ~__context)  ~host ~hostname) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.is_in_emergency_mode" | "host_is_in_emergency_mode" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.is_in_emergency_mode ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.is_in_emergency_mode ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host.compute_free_memory" | "host_compute_free_memory" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.compute_free_memory ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.compute_free_memory ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.compute_memory_overhead" | "host_compute_memory_overhead" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.compute_memory_overhead ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.compute_memory_overhead ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.tickle_heartbeat" | "host_tickle_heartbeat" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; stuff_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let stuff = string_to_string_map_of_rpc stuff_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("stuff", stuff_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.tickle_heartbeat ~__context:(Context.check_for_foreign_database ~__context)  ~host ~stuff))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.tickle_heartbeat ~__context:(Context.check_for_foreign_database ~__context)  ~host ~stuff) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.sync_data" | "host_sync_data" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.sync_data ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.sync_data ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.backup_rrds" | "host_backup_rrds" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; delay_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let delay = float_of_rpc delay_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("delay", delay_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.backup_rrds ~__context:(Context.check_for_foreign_database ~__context)  ~host ~delay))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.backup_rrds ~__context:(Context.check_for_foreign_database ~__context)  ~host ~delay) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.create_new_blob" | "host_create_new_blob" -> 
        begin match __params with
        | session_id_rpc :: host_rpc :: name_rpc :: mime_type_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let public_rpc = try List.nth default_args 0 with _ -> Rpc.Bool false in
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let name = string_of_rpc name_rpc in
            let mime_type = string_of_rpc mime_type_rpc in
            let public = bool_of_rpc public_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("name", name_rpc); ("mime_type", mime_type_rpc); ("public", public_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_blob x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.create_new_blob ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name ~mime_type ~public))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.create_new_blob ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name ~mime_type ~public) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.call_plugin" | "host_call_plugin" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; plugin_rpc; fn_rpc; args_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let plugin = string_of_rpc plugin_rpc in
            let fn = string_of_rpc fn_rpc in
            let args = string_to_string_map_of_rpc args_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("plugin", plugin_rpc); ("fn", fn_rpc); ("args", args_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.call_plugin ~__context:(Context.check_for_foreign_database ~__context)  ~host ~plugin ~fn ~args))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.call_plugin ~__context:(Context.check_for_foreign_database ~__context)  ~host ~plugin ~fn ~args) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "host.has_extension" | "host_has_extension" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; name_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let name = string_of_rpc name_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("name", name_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.has_extension ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.has_extension ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.call_extension" | "host_call_extension" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; call_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let call = string_of_rpc call_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("call", call_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.call_extension ~__context:(Context.check_for_foreign_database ~__context)  ~host ~call))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.call_extension ~__context:(Context.check_for_foreign_database ~__context)  ~host ~call) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_servertime" | "host_get_servertime" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_servertime ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_servertime ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_server_localtime" | "host_get_server_localtime" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_server_localtime ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_server_localtime ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.enable_binary_storage" | "host_enable_binary_storage" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.enable_binary_storage ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.enable_binary_storage ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.disable_binary_storage" | "host_disable_binary_storage" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.disable_binary_storage ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.disable_binary_storage ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.enable_external_auth" | "host_enable_external_auth" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; config_rpc; service_name_rpc; auth_type_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let config = string_to_string_map_of_rpc config_rpc in
            let service_name = string_of_rpc service_name_rpc in
            let auth_type = string_of_rpc auth_type_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("config", config_rpc); ("service_name", service_name_rpc); ("auth_type", auth_type_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.enable_external_auth ~__context:(Context.check_for_foreign_database ~__context)  ~host ~config ~service_name ~auth_type))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.enable_external_auth ~__context:(Context.check_for_foreign_database ~__context)  ~host ~config ~service_name ~auth_type) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "host.disable_external_auth" | "host_disable_external_auth" -> 
        begin match __params with
        | session_id_rpc :: host_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let config_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let config = string_to_string_map_of_rpc config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("config", config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.disable_external_auth ~__context:(Context.check_for_foreign_database ~__context)  ~host ~config))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.disable_external_auth ~__context:(Context.check_for_foreign_database ~__context)  ~host ~config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.retrieve_wlb_evacuate_recommendations" | "host_retrieve_wlb_evacuate_recommendations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM_to_string_set_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.retrieve_wlb_evacuate_recommendations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.retrieve_wlb_evacuate_recommendations ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.certificate_install" | "host_certificate_install" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; name_rpc; cert_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let name = string_of_rpc name_rpc in
            let cert = string_of_rpc cert_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("name", name_rpc); ("cert", cert_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.certificate_install ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name ~cert))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.certificate_install ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name ~cert) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.certificate_uninstall" | "host_certificate_uninstall" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; name_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let name = string_of_rpc name_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("name", name_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.certificate_uninstall ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.certificate_uninstall ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.certificate_list" | "host_certificate_list" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.certificate_list ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.certificate_list ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.crl_install" | "host_crl_install" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; name_rpc; crl_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let name = string_of_rpc name_rpc in
            let crl = string_of_rpc crl_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("name", name_rpc); ("crl", crl_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.crl_install ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name ~crl))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.crl_install ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name ~crl) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.crl_uninstall" | "host_crl_uninstall" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; name_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let name = string_of_rpc name_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("name", name_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.crl_uninstall ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.crl_uninstall ~__context:(Context.check_for_foreign_database ~__context)  ~host ~name) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.crl_list" | "host_crl_list" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.crl_list ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.crl_list ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.certificate_sync" | "host_certificate_sync" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.certificate_sync ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.certificate_sync ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_server_certificate" | "host_get_server_certificate" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_server_certificate ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_server_certificate ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.install_server_certificate" | "host_install_server_certificate" -> 
        begin match __params with
        | session_id_rpc :: host_rpc :: certificate_rpc :: private_key_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let certificate_chain_rpc = try List.nth default_args 0 with _ -> Rpc.String "" in
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let certificate = string_of_rpc certificate_rpc in
            let private_key = string_of_rpc private_key_rpc in
            let certificate_chain = string_of_rpc certificate_chain_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("certificate", certificate_rpc); ("private_key", private_key_rpc); ("certificate_chain", certificate_chain_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.install_server_certificate ~__context:(Context.check_for_foreign_database ~__context)  ~host ~certificate ~private_key ~certificate_chain))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.install_server_certificate ~__context:(Context.check_for_foreign_database ~__context)  ~host ~certificate ~private_key ~certificate_chain) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.emergency_reset_server_certificate" | "host_emergency_reset_server_certificate" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.emergency_reset_server_certificate ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.emergency_reset_server_certificate ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host.update_pool_secret" | "host_update_pool_secret" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; pool_secret_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let pool_secret = secretstring_of_rpc pool_secret_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("pool_secret", pool_secret_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.update_pool_secret ~__context:(Context.check_for_foreign_database ~__context)  ~host ~pool_secret))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.update_pool_secret ~__context:(Context.check_for_foreign_database ~__context)  ~host ~pool_secret) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.update_master" | "host_update_master" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; master_address_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let master_address = string_of_rpc master_address_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("master_address", master_address_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.update_master ~__context:(Context.check_for_foreign_database ~__context)  ~host ~master_address))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.update_master ~__context:(Context.check_for_foreign_database ~__context)  ~host ~master_address) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.attach_static_vdis" | "host_attach_static_vdis" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; vdi_reason_map_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let vdi_reason_map = ref_VDI_to_string_map_of_rpc vdi_reason_map_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("vdi_reason_map", vdi_reason_map_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.attach_static_vdis ~__context:(Context.check_for_foreign_database ~__context)  ~host ~vdi_reason_map))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.attach_static_vdis ~__context:(Context.check_for_foreign_database ~__context)  ~host ~vdi_reason_map) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.detach_static_vdis" | "host_detach_static_vdis" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; vdis_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let vdis = ref_VDI_set_of_rpc vdis_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("vdis", vdis_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.detach_static_vdis ~__context:(Context.check_for_foreign_database ~__context)  ~host ~vdis))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.detach_static_vdis ~__context:(Context.check_for_foreign_database ~__context)  ~host ~vdis) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_localdb_key" | "host_set_localdb_key" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; key_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.set_localdb_key ~__context:(Context.check_for_foreign_database ~__context)  ~host ~key ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.set_localdb_key ~__context:(Context.check_for_foreign_database ~__context)  ~host ~key ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.apply_edition" | "host_apply_edition" -> 
        begin match __params with
        | session_id_rpc :: host_rpc :: edition_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let force_rpc = try List.nth default_args 0 with _ -> Rpc.Bool false in
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let edition = string_of_rpc edition_rpc in
            let force = bool_of_rpc force_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("edition", edition_rpc); ("force", force_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.apply_edition ~__context:(Context.check_for_foreign_database ~__context)  ~host ~edition ~force))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.apply_edition ~__context:(Context.check_for_foreign_database ~__context)  ~host ~edition ~force) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.refresh_pack_info" | "host_refresh_pack_info" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.refresh_pack_info ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.refresh_pack_info ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_power_on_mode" | "host_set_power_on_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; power_on_mode_rpc; power_on_config_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let power_on_mode = string_of_rpc power_on_mode_rpc in
            let power_on_config = string_to_string_map_of_rpc power_on_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("power_on_mode", power_on_mode_rpc); ("power_on_config", power_on_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.set_power_on_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self ~power_on_mode ~power_on_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.set_power_on_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self ~power_on_mode ~power_on_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_cpu_features" | "host_set_cpu_features" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; features_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.reset_cpu_features" | "host_reset_cpu_features" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.reset_networking" | "host_reset_networking" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.reset_networking ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.reset_networking ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.enable_local_storage_caching" | "host_enable_local_storage_caching" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.enable_local_storage_caching ~__context:(Context.check_for_foreign_database ~__context)  ~host ~sr))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.enable_local_storage_caching ~__context:(Context.check_for_foreign_database ~__context)  ~host ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.disable_local_storage_caching" | "host_disable_local_storage_caching" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.disable_local_storage_caching ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.disable_local_storage_caching ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_sm_diagnostics" | "host_get_sm_diagnostics" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_sm_diagnostics ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_sm_diagnostics ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_thread_diagnostics" | "host_get_thread_diagnostics" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_thread_diagnostics ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_thread_diagnostics ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.sm_dp_destroy" | "host_sm_dp_destroy" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; dp_rpc; allow_leak_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let dp = string_of_rpc dp_rpc in
            let allow_leak = bool_of_rpc allow_leak_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("dp", dp_rpc); ("allow_leak", allow_leak_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.sm_dp_destroy ~__context:(Context.check_for_foreign_database ~__context)  ~host ~dp ~allow_leak))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.sm_dp_destroy ~__context:(Context.check_for_foreign_database ~__context)  ~host ~dp ~allow_leak) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.sync_vlans" | "host_sync_vlans" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.sync_vlans ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.sync_vlans ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.sync_tunnels" | "host_sync_tunnels" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.sync_tunnels ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.sync_tunnels ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.sync_pif_currently_attached" | "host_sync_pif_currently_attached" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; bridges_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let bridges = string_set_of_rpc bridges_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("bridges", bridges_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.sync_pif_currently_attached ~__context:(Context.check_for_foreign_database ~__context)  ~host ~bridges))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.sync_pif_currently_attached ~__context:(Context.check_for_foreign_database ~__context)  ~host ~bridges) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.migrate_receive" | "host_migrate_receive" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; network_rpc; options_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let network = ref_network_of_rpc network_rpc in
            let options = string_to_string_map_of_rpc options_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("network", network_rpc); ("options", options_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.migrate_receive ~__context:(Context.check_for_foreign_database ~__context)  ~host ~network ~options))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.migrate_receive ~__context:(Context.check_for_foreign_database ~__context)  ~host ~network ~options) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.declare_dead" | "host_declare_dead" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.declare_dead ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.declare_dead ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.enable_display" | "host_enable_display" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_host_display x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.enable_display ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.enable_display ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.disable_display" | "host_disable_display" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_host_display x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.disable_display ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.disable_display ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_ssl_legacy" | "host_set_ssl_legacy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.set_ssl_legacy ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.set_ssl_legacy ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.apply_guest_agent_config" | "host_apply_guest_agent_config" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.apply_guest_agent_config ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.apply_guest_agent_config ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.mxgpu_vf_setup" | "host_mxgpu_vf_setup" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.mxgpu_vf_setup ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.mxgpu_vf_setup ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.nvidia_vf_setup" | "host_nvidia_vf_setup" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; pf_rpc; enable_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let pf = ref_PCI_of_rpc pf_rpc in
            let enable = bool_of_rpc enable_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("pf", pf_rpc); ("enable", enable_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.nvidia_vf_setup ~__context:(Context.check_for_foreign_database ~__context)  ~host ~pf ~enable))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.nvidia_vf_setup ~__context:(Context.check_for_foreign_database ~__context)  ~host ~pf ~enable) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.allocate_resources_for_vm" | "host_allocate_resources_for_vm" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; vm_rpc; live_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            let live = bool_of_rpc live_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("vm", vm_rpc); ("live", live_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.allocate_resources_for_vm ~__context:(Context.check_for_foreign_database ~__context)  ~self ~vm ~live))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.allocate_resources_for_vm ~__context:(Context.check_for_foreign_database ~__context)  ~self ~vm ~live) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_iscsi_iqn" | "host_set_iscsi_iqn" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.set_iscsi_iqn ~__context:(Context.check_for_foreign_database ~__context)  ~host ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.set_iscsi_iqn ~__context:(Context.check_for_foreign_database ~__context)  ~host ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_multipathing" | "host_set_multipathing" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.set_multipathing ~__context:(Context.check_for_foreign_database ~__context)  ~host ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.set_multipathing ~__context:(Context.check_for_foreign_database ~__context)  ~host ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_uefi_certificates" | "host_set_uefi_certificates" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.set_uefi_certificates ~__context:(Context.check_for_foreign_database ~__context)  ~host ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.set_uefi_certificates ~__context:(Context.check_for_foreign_database ~__context)  ~host ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.notify_accept_new_pool_secret" | "host_notify_accept_new_pool_secret" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; old_ps_rpc; new_ps_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let old_ps = secretstring_of_rpc old_ps_rpc in
            let new_ps = secretstring_of_rpc new_ps_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("old_ps", old_ps_rpc); ("new_ps", new_ps_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.notify_accept_new_pool_secret ~__context:(Context.check_for_foreign_database ~__context)  ~host ~old_ps ~new_ps))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.notify_accept_new_pool_secret ~__context:(Context.check_for_foreign_database ~__context)  ~host ~old_ps ~new_ps) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.notify_send_new_pool_secret" | "host_notify_send_new_pool_secret" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; old_ps_rpc; new_ps_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let old_ps = secretstring_of_rpc old_ps_rpc in
            let new_ps = secretstring_of_rpc new_ps_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("old_ps", old_ps_rpc); ("new_ps", new_ps_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.notify_send_new_pool_secret ~__context:(Context.check_for_foreign_database ~__context)  ~host ~old_ps ~new_ps))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.notify_send_new_pool_secret ~__context:(Context.check_for_foreign_database ~__context)  ~host ~old_ps ~new_ps) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.cleanup_pool_secret" | "host_cleanup_pool_secret" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; old_ps_rpc; new_ps_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let old_ps = secretstring_of_rpc old_ps_rpc in
            let new_ps = secretstring_of_rpc new_ps_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("old_ps", old_ps_rpc); ("new_ps", new_ps_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.cleanup_pool_secret ~__context:(Context.check_for_foreign_database ~__context)  ~host ~old_ps ~new_ps))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.cleanup_pool_secret ~__context:(Context.check_for_foreign_database ~__context)  ~host ~old_ps ~new_ps) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_https_only" | "host_set_https_only" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.set_https_only ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.set_https_only ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.set_sched_gran" | "host_set_sched_gran" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            let value = host_sched_gran_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.set_sched_gran ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.set_sched_gran ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_sched_gran" | "host_get_sched_gran" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_host_sched_gran x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host.get_sched_gran ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.get_sched_gran ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_all" | "host_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_all_records_where" | "host_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_to_host_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host.get_all_records" | "host_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_to_host_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.get_record" | "host_crashdump_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_host_crashdump_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_crashdump.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.get_by_uuid" | "host_crashdump_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_crashdump x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_crashdump.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.get_uuid" | "host_crashdump_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_crashdump.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.get_host" | "host_crashdump_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_crashdump.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.get_timestamp" | "host_crashdump_get_timestamp" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.get_timestamp ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_crashdump.get_timestamp";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.get_size" | "host_crashdump_get_size" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.get_size ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_crashdump.get_size";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.get_other_config" | "host_crashdump_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_crashdump.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.set_other_config" | "host_crashdump_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_crashdump_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_crashdump.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.add_to_other_config" | "host_crashdump_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_crashdump_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_crashdump.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.remove_from_other_config" | "host_crashdump_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_crashdump_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_crashdump.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.destroy" | "host_crashdump_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host_crashdump.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host_crashdump.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.upload" | "host_crashdump_upload" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; url_rpc; options_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_crashdump_of_rpc self_rpc in
            let url = string_of_rpc url_rpc in
            let options = string_to_string_map_of_rpc options_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("url", url_rpc); ("options", options_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host_crashdump.upload ~__context:(Context.check_for_foreign_database ~__context)  ~self ~url ~options))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host_crashdump.upload ~__context:(Context.check_for_foreign_database ~__context)  ~self ~url ~options) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.get_all" | "host_crashdump_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_crashdump_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_crashdump.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.get_all_records_where" | "host_crashdump_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_crashdump_to_host_crashdump_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_crashdump.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_crashdump.get_all_records" | "host_crashdump_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_crashdump_to_host_crashdump_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_crashdump.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_crashdump.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_record" | "host_patch_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_host_patch_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_by_uuid" | "host_patch_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_patch x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_by_name_label" | "host_patch_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_patch_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_uuid" | "host_patch_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_name_label" | "host_patch_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_name_description" | "host_patch_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_version" | "host_patch_get_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_host" | "host_patch_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_applied" | "host_patch_get_applied" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_applied ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_applied";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_timestamp_applied" | "host_patch_get_timestamp_applied" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_timestamp_applied ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_timestamp_applied";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_size" | "host_patch_get_size" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_size ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_size";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_pool_patch" | "host_patch_get_pool_patch" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool_patch x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_pool_patch ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_pool_patch";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_other_config" | "host_patch_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.set_other_config" | "host_patch_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_patch.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.add_to_other_config" | "host_patch_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_patch.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.remove_from_other_config" | "host_patch_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_patch.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.destroy" | "host_patch_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host_patch.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host_patch.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.apply" | "host_patch_apply" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_patch_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Host_patch.apply ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host_patch.apply ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_all" | "host_patch_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_patch_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_all_records_where" | "host_patch_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_patch_to_host_patch_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_patch.get_all_records" | "host_patch_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_patch_to_host_patch_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_patch.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_patch.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.get_record" | "host_metrics_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_host_metrics_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_metrics.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.get_by_uuid" | "host_metrics_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_metrics x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_metrics.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.get_uuid" | "host_metrics_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_metrics.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.get_memory_total" | "host_metrics_get_memory_total" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.get_memory_total ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_metrics.get_memory_total";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.get_memory_free" | "host_metrics_get_memory_free" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.get_live" | "host_metrics_get_live" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.get_live ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_metrics.get_live";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.get_last_updated" | "host_metrics_get_last_updated" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.get_last_updated ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_metrics.get_last_updated";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.get_other_config" | "host_metrics_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_metrics.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.set_other_config" | "host_metrics_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_metrics_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_metrics.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.add_to_other_config" | "host_metrics_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_metrics.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.remove_from_other_config" | "host_metrics_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_metrics.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.get_all" | "host_metrics_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_metrics_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_metrics.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.get_all_records_where" | "host_metrics_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_metrics_to_host_metrics_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_metrics.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_metrics.get_all_records" | "host_metrics_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_metrics_to_host_metrics_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_metrics.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_metrics.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_record" | "host_cpu_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_host_cpu_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_by_uuid" | "host_cpu_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_cpu x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_uuid" | "host_cpu_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_host" | "host_cpu_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_number" | "host_cpu_get_number" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_number ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_number";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_vendor" | "host_cpu_get_vendor" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_vendor ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_vendor";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_speed" | "host_cpu_get_speed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_speed ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_speed";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_modelname" | "host_cpu_get_modelname" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_modelname ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_modelname";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_family" | "host_cpu_get_family" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_family ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_family";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_model" | "host_cpu_get_model" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_model ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_model";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_stepping" | "host_cpu_get_stepping" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_stepping ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_stepping";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_flags" | "host_cpu_get_flags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_flags ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_flags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_features" | "host_cpu_get_features" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_features ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_features";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_utilisation" | "host_cpu_get_utilisation" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_float x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_utilisation ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_utilisation";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_other_config" | "host_cpu_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.set_other_config" | "host_cpu_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_cpu.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.add_to_other_config" | "host_cpu_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_cpu.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.remove_from_other_config" | "host_cpu_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_host_cpu_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "host_cpu.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_all" | "host_cpu_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_cpu_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_all_records_where" | "host_cpu_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_cpu_to_host_cpu_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "host_cpu.get_all_records" | "host_cpu_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_cpu_to_host_cpu_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Host_cpu.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "host_cpu.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_record" | "network_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_network_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_by_uuid" | "network_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.create" | "network_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let name_label = string_of_rpc ((List.assoc_opt "name_label" __structure) |> Option.value ~default:(Rpc.String "")) in
            let name_description = string_of_rpc ((List.assoc_opt "name_description" __structure) |> Option.value ~default:(Rpc.String "")) in
            let mTU = int64_of_rpc ((List.assoc_opt "MTU" __structure) |> Option.value ~default:(Rpc.Int (1500L))) in
            let other_config = string_to_string_map_of_rpc (my_assoc "other_config" __structure) in
            let bridge = string_of_rpc ((List.assoc_opt "bridge" __structure) |> Option.value ~default:(Rpc.String "")) in
            let managed = bool_of_rpc ((List.assoc_opt "managed" __structure) |> Option.value ~default:(Rpc.Bool true)) in
            let tags = string_set_of_rpc ((List.assoc_opt "tags" __structure) |> Option.value ~default:(Rpc.Enum [])) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~mTU ~other_config ~bridge ~managed ~tags))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~mTU ~other_config ~bridge ~managed ~tags) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.destroy" | "network_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_by_name_label" | "network_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_uuid" | "network_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_name_label" | "network_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_name_description" | "network_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_allowed_operations" | "network_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_network_operations_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_current_operations" | "network_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_network_operations_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_VIFs" | "network_get_VIFs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VIF_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_VIFs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_VIFs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_PIFs" | "network_get_PIFs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_PIFs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_PIFs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_MTU" | "network_get_MTU" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_MTU ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_MTU";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_other_config" | "network_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_bridge" | "network_get_bridge" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_bridge ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_bridge";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_managed" | "network_get_managed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_managed ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_managed";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_blobs" | "network_get_blobs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_ref_blob_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_blobs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_blobs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_tags" | "network_get_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_default_locking_mode" | "network_get_default_locking_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_network_default_locking_mode x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_default_locking_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_default_locking_mode";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_assigned_ips" | "network_get_assigned_ips" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VIF_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_assigned_ips ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_assigned_ips";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_purpose" | "network_get_purpose" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_network_purpose_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_purpose ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_purpose";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.set_name_label" | "network_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "network.set_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.set_name_description" | "network_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "network.set_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.set_MTU" | "network_set_MTU" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.set_MTU ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "network.set_MTU";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.set_other_config" | "network_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "network.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.add_to_other_config" | "network_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = ["folder"; "XenCenter.CustomFields.*"; "XenCenterCreateInProgress"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "network.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "network.remove_from_other_config" | "network_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = ["folder"; "XenCenter.CustomFields.*"; "XenCenterCreateInProgress"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "network.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.set_tags" | "network_set_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            let value = string_set_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.set_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "network.set_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.add_tags" | "network_add_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.add_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "network.add_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.remove_tags" | "network_remove_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.remove_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "network.remove_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.attach" | "network_attach" -> 
        begin match __params with
        | [session_id_rpc; network_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let network = ref_network_of_rpc network_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("network", network_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network.attach ~__context:(Context.check_for_foreign_database ~__context)  ~network ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network.attach ~__context:(Context.check_for_foreign_database ~__context)  ~network ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.pool_introduce" | "network_pool_introduce" -> 
        begin match __params with
        | [session_id_rpc; name_label_rpc; name_description_rpc; mTU_rpc; other_config_rpc; bridge_rpc; managed_rpc; purpose_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let name_label = string_of_rpc name_label_rpc in
            let name_description = string_of_rpc name_description_rpc in
            let mTU = int64_of_rpc mTU_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            let bridge = string_of_rpc bridge_rpc in
            let managed = bool_of_rpc managed_rpc in
            let purpose = network_purpose_set_of_rpc purpose_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("name_label", name_label_rpc); ("name_description", name_description_rpc); ("mTU", mTU_rpc); ("other_config", other_config_rpc); ("bridge", bridge_rpc); ("managed", managed_rpc); ("purpose", purpose_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network.pool_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~mTU ~other_config ~bridge ~managed ~purpose))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network.pool_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~mTU ~other_config ~bridge ~managed ~purpose) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "7" (string_of_int ((List.length __params) - 1))
        end
    | "network.create_new_blob" | "network_create_new_blob" -> 
        begin match __params with
        | session_id_rpc :: network_rpc :: name_rpc :: mime_type_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let public_rpc = try List.nth default_args 0 with _ -> Rpc.Bool false in
            let session_id = ref_session_of_rpc session_id_rpc in
            let network = ref_network_of_rpc network_rpc in
            let name = string_of_rpc name_rpc in
            let mime_type = string_of_rpc mime_type_rpc in
            let public = bool_of_rpc public_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("network", network_rpc); ("name", name_rpc); ("mime_type", mime_type_rpc); ("public", public_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_blob x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network.create_new_blob ~__context:(Context.check_for_foreign_database ~__context)  ~network ~name ~mime_type ~public))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network.create_new_blob ~__context:(Context.check_for_foreign_database ~__context)  ~network ~name ~mime_type ~public) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "network.set_default_locking_mode" | "network_set_default_locking_mode" -> 
        begin match __params with
        | [session_id_rpc; network_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let network = ref_network_of_rpc network_rpc in
            let value = network_default_locking_mode_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("network", network_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network.set_default_locking_mode ~__context:(Context.check_for_foreign_database ~__context)  ~network ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network.set_default_locking_mode ~__context:(Context.check_for_foreign_database ~__context)  ~network ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.attach_for_vm" | "network_attach_for_vm" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network.attach_for_vm ~__context:(Context.check_for_foreign_database ~__context)  ~host ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network.attach_for_vm ~__context:(Context.check_for_foreign_database ~__context)  ~host ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.detach_for_vm" | "network_detach_for_vm" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; vm_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let vm = ref_VM_of_rpc vm_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("vm", vm_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network.detach_for_vm ~__context:(Context.check_for_foreign_database ~__context)  ~host ~vm))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network.detach_for_vm ~__context:(Context.check_for_foreign_database ~__context)  ~host ~vm) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.add_purpose" | "network_add_purpose" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            let value = network_purpose_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network.add_purpose ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network.add_purpose ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.remove_purpose" | "network_remove_purpose" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_of_rpc self_rpc in
            let value = network_purpose_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network.remove_purpose ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network.remove_purpose ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_all" | "network_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_all_records_where" | "network_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network_to_network_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network.get_all_records" | "network_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network_to_network_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_record" | "VIF_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vIF_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_by_uuid" | "VIF_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.create" | "VIF_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let device = string_of_rpc (my_assoc "device" __structure) in
            let network = ref_network_of_rpc (my_assoc "network" __structure) in
            let vM = ref_VM_of_rpc (my_assoc "VM" __structure) in
            let mAC = string_of_rpc (my_assoc "MAC" __structure) in
            let mTU = int64_of_rpc (my_assoc "MTU" __structure) in
            let other_config = string_to_string_map_of_rpc (my_assoc "other_config" __structure) in
            let currently_attached = bool_of_rpc ((List.assoc_opt "currently_attached" __structure) |> Option.value ~default:(Rpc.Bool false)) in
            let qos_algorithm_type = string_of_rpc (my_assoc "qos_algorithm_type" __structure) in
            let qos_algorithm_params = string_to_string_map_of_rpc (my_assoc "qos_algorithm_params" __structure) in
            let locking_mode = vif_locking_mode_of_rpc ((List.assoc_opt "locking_mode" __structure) |> Option.value ~default:(Rpc.String "network_default")) in
            let ipv4_allowed = string_set_of_rpc ((List.assoc_opt "ipv4_allowed" __structure) |> Option.value ~default:(Rpc.Enum [])) in
            let ipv6_allowed = string_set_of_rpc ((List.assoc_opt "ipv6_allowed" __structure) |> Option.value ~default:(Rpc.Enum [])) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.create ~__context:(Context.check_for_foreign_database ~__context)  ~device ~network ~vM ~mAC ~mTU ~other_config ~currently_attached ~qos_algorithm_type ~qos_algorithm_params ~locking_mode ~ipv4_allowed ~ipv6_allowed))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.create ~__context:(Context.check_for_foreign_database ~__context)  ~device ~network ~vM ~mAC ~mTU ~other_config ~currently_attached ~qos_algorithm_type ~qos_algorithm_params ~locking_mode ~ipv4_allowed ~ipv6_allowed) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.destroy" | "VIF_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_uuid" | "VIF_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_allowed_operations" | "VIF_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vif_operations_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_current_operations" | "VIF_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_vif_operations_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_device" | "VIF_get_device" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_device ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_device";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_network" | "VIF_get_network" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_network ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_network";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_VM" | "VIF_get_VM" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_VM ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_VM";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_MAC" | "VIF_get_MAC" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_MAC ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_MAC";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_MTU" | "VIF_get_MTU" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_MTU ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_MTU";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_other_config" | "VIF_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_currently_attached" | "VIF_get_currently_attached" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_currently_attached ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_currently_attached";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_status_code" | "VIF_get_status_code" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_status_code ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_status_code";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_status_detail" | "VIF_get_status_detail" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_status_detail ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_status_detail";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_runtime_properties" | "VIF_get_runtime_properties" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_runtime_properties ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_runtime_properties";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_qos_algorithm_type" | "VIF_get_qos_algorithm_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_qos_algorithm_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_qos_algorithm_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_qos_algorithm_params" | "VIF_get_qos_algorithm_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_qos_algorithm_params ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_qos_algorithm_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_qos_supported_algorithms" | "VIF_get_qos_supported_algorithms" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_qos_supported_algorithms ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_qos_supported_algorithms";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_metrics" | "VIF_get_metrics" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_MAC_autogenerated" | "VIF_get_MAC_autogenerated" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_MAC_autogenerated ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_MAC_autogenerated";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_locking_mode" | "VIF_get_locking_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vif_locking_mode x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_locking_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_locking_mode";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_ipv4_allowed" | "VIF_get_ipv4_allowed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_ipv4_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_ipv4_allowed";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_ipv6_allowed" | "VIF_get_ipv6_allowed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_ipv6_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_ipv6_allowed";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_ipv4_configuration_mode" | "VIF_get_ipv4_configuration_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vif_ipv4_configuration_mode x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_ipv4_configuration_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_ipv4_configuration_mode";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_ipv4_addresses" | "VIF_get_ipv4_addresses" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_ipv4_addresses ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_ipv4_addresses";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_ipv4_gateway" | "VIF_get_ipv4_gateway" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_ipv4_gateway ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_ipv4_gateway";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_ipv6_configuration_mode" | "VIF_get_ipv6_configuration_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vif_ipv6_configuration_mode x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_ipv6_configuration_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_ipv6_configuration_mode";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_ipv6_addresses" | "VIF_get_ipv6_addresses" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_ipv6_addresses ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_ipv6_addresses";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_ipv6_gateway" | "VIF_get_ipv6_gateway" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_ipv6_gateway ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_ipv6_gateway";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.set_other_config" | "VIF_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VIF.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.add_to_other_config" | "VIF_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VIF.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.remove_from_other_config" | "VIF_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VIF.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.set_qos_algorithm_type" | "VIF_set_qos_algorithm_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.set_qos_algorithm_type ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VIF.set_qos_algorithm_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.set_qos_algorithm_params" | "VIF_set_qos_algorithm_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.set_qos_algorithm_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VIF.set_qos_algorithm_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.add_to_qos_algorithm_params" | "VIF_add_to_qos_algorithm_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.add_to_qos_algorithm_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VIF.add_to_qos_algorithm_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.remove_from_qos_algorithm_params" | "VIF_remove_from_qos_algorithm_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.remove_from_qos_algorithm_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VIF.remove_from_qos_algorithm_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.plug" | "VIF_plug" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.plug ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.plug ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.unplug" | "VIF_unplug" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.unplug_force" | "VIF_unplug_force" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.unplug_force ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.unplug_force ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.move" | "VIF_move" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; network_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let network = ref_network_of_rpc network_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("network", network_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.move ~__context:(Context.check_for_foreign_database ~__context)  ~self ~network))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.move ~__context:(Context.check_for_foreign_database ~__context)  ~self ~network) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.set_locking_mode" | "VIF_set_locking_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let value = vif_locking_mode_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.set_locking_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.set_locking_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.set_ipv4_allowed" | "VIF_set_ipv4_allowed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let value = string_set_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.set_ipv4_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.set_ipv4_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.add_ipv4_allowed" | "VIF_add_ipv4_allowed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.add_ipv4_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.add_ipv4_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.remove_ipv4_allowed" | "VIF_remove_ipv4_allowed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.remove_ipv4_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.remove_ipv4_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.set_ipv6_allowed" | "VIF_set_ipv6_allowed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let value = string_set_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.set_ipv6_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.set_ipv6_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.add_ipv6_allowed" | "VIF_add_ipv6_allowed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.add_ipv6_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.add_ipv6_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.remove_ipv6_allowed" | "VIF_remove_ipv6_allowed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.remove_ipv6_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.remove_ipv6_allowed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.configure_ipv4" | "VIF_configure_ipv4" -> 
        begin match __params with
        | session_id_rpc :: self_rpc :: mode_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let address_rpc = try List.nth default_args 0 with _ -> Rpc.String "" in
            let gateway_rpc = try List.nth default_args 1 with _ -> Rpc.String "" in
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let mode = vif_ipv4_configuration_mode_of_rpc mode_rpc in
            let address = string_of_rpc address_rpc in
            let gateway = string_of_rpc gateway_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("mode", mode_rpc); ("address", address_rpc); ("gateway", gateway_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.configure_ipv4 ~__context:(Context.check_for_foreign_database ~__context)  ~self ~mode ~address ~gateway))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.configure_ipv4 ~__context:(Context.check_for_foreign_database ~__context)  ~self ~mode ~address ~gateway) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.configure_ipv6" | "VIF_configure_ipv6" -> 
        begin match __params with
        | session_id_rpc :: self_rpc :: mode_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let address_rpc = try List.nth default_args 0 with _ -> Rpc.String "" in
            let gateway_rpc = try List.nth default_args 1 with _ -> Rpc.String "" in
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_of_rpc self_rpc in
            let mode = vif_ipv6_configuration_mode_of_rpc mode_rpc in
            let address = string_of_rpc address_rpc in
            let gateway = string_of_rpc gateway_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("mode", mode_rpc); ("address", address_rpc); ("gateway", gateway_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VIF.configure_ipv6 ~__context:(Context.check_for_foreign_database ~__context)  ~self ~mode ~address ~gateway))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VIF.configure_ipv6 ~__context:(Context.check_for_foreign_database ~__context)  ~self ~mode ~address ~gateway) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_all" | "VIF_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VIF_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_all_records_where" | "VIF_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VIF_to_vIF_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF.get_all_records" | "VIF_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VIF_to_vIF_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.get_record" | "VIF_metrics_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.get_by_uuid" | "VIF_metrics_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.get_uuid" | "VIF_metrics_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF_metrics.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF_metrics.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.get_io_read_kbs" | "VIF_metrics_get_io_read_kbs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.get_io_write_kbs" | "VIF_metrics_get_io_write_kbs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.get_last_updated" | "VIF_metrics_get_last_updated" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF_metrics.get_last_updated ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF_metrics.get_last_updated";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.get_other_config" | "VIF_metrics_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF_metrics.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VIF_metrics.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.set_other_config" | "VIF_metrics_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_metrics_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF_metrics.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VIF_metrics.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.add_to_other_config" | "VIF_metrics_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF_metrics.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VIF_metrics.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.remove_from_other_config" | "VIF_metrics_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VIF_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VIF_metrics.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VIF_metrics.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.get_all" | "VIF_metrics_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.get_all_records_where" | "VIF_metrics_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VIF_metrics.get_all_records" | "VIF_metrics_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_record" | "PIF_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pIF_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_by_uuid" | "PIF_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_uuid" | "PIF_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_device" | "PIF_get_device" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_device ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_device";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_network" | "PIF_get_network" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_network ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_network";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_host" | "PIF_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_MAC" | "PIF_get_MAC" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_MAC ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_MAC";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_MTU" | "PIF_get_MTU" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_MTU ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_MTU";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_VLAN" | "PIF_get_VLAN" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_VLAN ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_VLAN";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_metrics" | "PIF_get_metrics" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_metrics x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_metrics ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_metrics";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_physical" | "PIF_get_physical" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_physical ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_physical";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_currently_attached" | "PIF_get_currently_attached" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_currently_attached ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_currently_attached";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_ip_configuration_mode" | "PIF_get_ip_configuration_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ip_configuration_mode x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_ip_configuration_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_ip_configuration_mode";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_IP" | "PIF_get_IP" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_IP ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_IP";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_netmask" | "PIF_get_netmask" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_netmask ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_netmask";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_gateway" | "PIF_get_gateway" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_gateway ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_gateway";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_DNS" | "PIF_get_DNS" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_DNS ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_DNS";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_bond_slave_of" | "PIF_get_bond_slave_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Bond x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_bond_slave_of ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_bond_slave_of";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_bond_master_of" | "PIF_get_bond_master_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Bond_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_bond_master_of ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_bond_master_of";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_VLAN_master_of" | "PIF_get_VLAN_master_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VLAN x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_VLAN_master_of ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_VLAN_master_of";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_VLAN_slave_of" | "PIF_get_VLAN_slave_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VLAN_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_VLAN_slave_of ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_VLAN_slave_of";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_management" | "PIF_get_management" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_management ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_management";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_other_config" | "PIF_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_disallow_unplug" | "PIF_get_disallow_unplug" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_disallow_unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_disallow_unplug";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_tunnel_access_PIF_of" | "PIF_get_tunnel_access_PIF_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_tunnel_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_tunnel_access_PIF_of ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_tunnel_access_PIF_of";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_tunnel_transport_PIF_of" | "PIF_get_tunnel_transport_PIF_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_tunnel_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_tunnel_transport_PIF_of ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_tunnel_transport_PIF_of";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_ipv6_configuration_mode" | "PIF_get_ipv6_configuration_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ipv6_configuration_mode x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_ipv6_configuration_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_ipv6_configuration_mode";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_IPv6" | "PIF_get_IPv6" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_IPv6 ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_IPv6";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_ipv6_gateway" | "PIF_get_ipv6_gateway" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_ipv6_gateway ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_ipv6_gateway";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_primary_address_type" | "PIF_get_primary_address_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_primary_address_type x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_primary_address_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_primary_address_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_managed" | "PIF_get_managed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_managed ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_managed";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_properties" | "PIF_get_properties" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_properties ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_properties";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_capabilities" | "PIF_get_capabilities" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_capabilities ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_capabilities";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_igmp_snooping_status" | "PIF_get_igmp_snooping_status" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pif_igmp_status x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_igmp_snooping_status ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_igmp_snooping_status";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_sriov_physical_PIF_of" | "PIF_get_sriov_physical_PIF_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network_sriov_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_sriov_physical_PIF_of ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_sriov_physical_PIF_of";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_sriov_logical_PIF_of" | "PIF_get_sriov_logical_PIF_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network_sriov_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_sriov_logical_PIF_of ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_sriov_logical_PIF_of";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_PCI" | "PIF_get_PCI" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PCI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_PCI ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_PCI";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.set_other_config" | "PIF_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PIF.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.add_to_other_config" | "PIF_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PIF.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.remove_from_other_config" | "PIF_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PIF.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.create_VLAN" | "PIF_create_VLAN" -> 
        begin match __params with
        | [session_id_rpc; device_rpc; network_rpc; host_rpc; vLAN_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let device = string_of_rpc device_rpc in
            let network = ref_network_of_rpc network_rpc in
            let host = ref_host_of_rpc host_rpc in
            let vLAN = int64_of_rpc vLAN_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("device", device_rpc); ("network", network_rpc); ("host", host_rpc); ("vLAN", vLAN_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.create_VLAN ~__context:(Context.check_for_foreign_database ~__context)  ~device ~network ~host ~vLAN))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.create_VLAN ~__context:(Context.check_for_foreign_database ~__context)  ~device ~network ~host ~vLAN) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.destroy" | "PIF_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.reconfigure_ip" | "PIF_reconfigure_ip" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; mode_rpc; iP_rpc; netmask_rpc; gateway_rpc; dNS_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            let mode = ip_configuration_mode_of_rpc mode_rpc in
            let iP = string_of_rpc iP_rpc in
            let netmask = string_of_rpc netmask_rpc in
            let gateway = string_of_rpc gateway_rpc in
            let dNS = string_of_rpc dNS_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("mode", mode_rpc); ("iP", iP_rpc); ("netmask", netmask_rpc); ("gateway", gateway_rpc); ("dNS", dNS_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.reconfigure_ip ~__context:(Context.check_for_foreign_database ~__context)  ~self ~mode ~iP ~netmask ~gateway ~dNS))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.reconfigure_ip ~__context:(Context.check_for_foreign_database ~__context)  ~self ~mode ~iP ~netmask ~gateway ~dNS) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "6" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.reconfigure_ipv6" | "PIF_reconfigure_ipv6" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; mode_rpc; iPv6_rpc; gateway_rpc; dNS_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            let mode = ipv6_configuration_mode_of_rpc mode_rpc in
            let iPv6 = string_of_rpc iPv6_rpc in
            let gateway = string_of_rpc gateway_rpc in
            let dNS = string_of_rpc dNS_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("mode", mode_rpc); ("iPv6", iPv6_rpc); ("gateway", gateway_rpc); ("dNS", dNS_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.reconfigure_ipv6 ~__context:(Context.check_for_foreign_database ~__context)  ~self ~mode ~iPv6 ~gateway ~dNS))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.reconfigure_ipv6 ~__context:(Context.check_for_foreign_database ~__context)  ~self ~mode ~iPv6 ~gateway ~dNS) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "5" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.set_primary_address_type" | "PIF_set_primary_address_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; primary_address_type_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            let primary_address_type = primary_address_type_of_rpc primary_address_type_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("primary_address_type", primary_address_type_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.set_primary_address_type ~__context:(Context.check_for_foreign_database ~__context)  ~self ~primary_address_type))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.set_primary_address_type ~__context:(Context.check_for_foreign_database ~__context)  ~self ~primary_address_type) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.scan" | "PIF_scan" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.scan ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.scan ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.introduce" | "PIF_introduce" -> 
        begin match __params with
        | session_id_rpc :: host_rpc :: mAC_rpc :: device_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let managed_rpc = try List.nth default_args 0 with _ -> Rpc.Bool true in
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let mAC = string_of_rpc mAC_rpc in
            let device = string_of_rpc device_rpc in
            let managed = bool_of_rpc managed_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("mAC", mAC_rpc); ("device", device_rpc); ("managed", managed_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~host ~mAC ~device ~managed))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~host ~mAC ~device ~managed) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.forget" | "PIF_forget" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.forget ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.forget ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.unplug" | "PIF_unplug" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.set_disallow_unplug" | "PIF_set_disallow_unplug" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.set_disallow_unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.set_disallow_unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.plug" | "PIF_plug" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.plug ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.plug ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.pool_introduce" | "PIF_pool_introduce" -> 
        begin match __params with
        | session_id_rpc :: device_rpc :: network_rpc :: host_rpc :: mAC_rpc :: mTU_rpc :: vLAN_rpc :: physical_rpc :: ip_configuration_mode_rpc :: iP_rpc :: netmask_rpc :: gateway_rpc :: dNS_rpc :: bond_slave_of_rpc :: vLAN_master_of_rpc :: management_rpc :: other_config_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let disallow_unplug_rpc = try List.nth default_args 0 with _ -> Rpc.Bool false in
            let ipv6_configuration_mode_rpc = try List.nth default_args 1 with _ -> Rpc.String "None" in
            let iPv6_rpc = try List.nth default_args 2 with _ -> Rpc.Enum [] in
            let ipv6_gateway_rpc = try List.nth default_args 3 with _ -> Rpc.String "" in
            let primary_address_type_rpc = try List.nth default_args 4 with _ -> Rpc.String "IPv4" in
            let managed_rpc = try List.nth default_args 5 with _ -> Rpc.Bool true in
            let properties_rpc = try List.nth default_args 6 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let device = string_of_rpc device_rpc in
            let network = ref_network_of_rpc network_rpc in
            let host = ref_host_of_rpc host_rpc in
            let mAC = string_of_rpc mAC_rpc in
            let mTU = int64_of_rpc mTU_rpc in
            let vLAN = int64_of_rpc vLAN_rpc in
            let physical = bool_of_rpc physical_rpc in
            let ip_configuration_mode = ip_configuration_mode_of_rpc ip_configuration_mode_rpc in
            let iP = string_of_rpc iP_rpc in
            let netmask = string_of_rpc netmask_rpc in
            let gateway = string_of_rpc gateway_rpc in
            let dNS = string_of_rpc dNS_rpc in
            let bond_slave_of = ref_Bond_of_rpc bond_slave_of_rpc in
            let vLAN_master_of = ref_VLAN_of_rpc vLAN_master_of_rpc in
            let management = bool_of_rpc management_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            let disallow_unplug = bool_of_rpc disallow_unplug_rpc in
            let ipv6_configuration_mode = ipv6_configuration_mode_of_rpc ipv6_configuration_mode_rpc in
            let iPv6 = string_set_of_rpc iPv6_rpc in
            let ipv6_gateway = string_of_rpc ipv6_gateway_rpc in
            let primary_address_type = primary_address_type_of_rpc primary_address_type_rpc in
            let managed = bool_of_rpc managed_rpc in
            let properties = string_to_string_map_of_rpc properties_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("device", device_rpc); ("network", network_rpc); ("host", host_rpc); ("mAC", mAC_rpc); ("mTU", mTU_rpc); ("vLAN", vLAN_rpc); ("physical", physical_rpc); ("ip_configuration_mode", ip_configuration_mode_rpc); ("iP", iP_rpc); ("netmask", netmask_rpc); ("gateway", gateway_rpc); ("dNS", dNS_rpc); ("bond_slave_of", bond_slave_of_rpc); ("vLAN_master_of", vLAN_master_of_rpc); ("management", management_rpc); ("other_config", other_config_rpc); ("disallow_unplug", disallow_unplug_rpc); ("ipv6_configuration_mode", ipv6_configuration_mode_rpc); ("IPv6", iPv6_rpc); ("ipv6_gateway", ipv6_gateway_rpc); ("primary_address_type", primary_address_type_rpc); ("managed", managed_rpc); ("properties", properties_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.pool_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~device ~network ~host ~mAC ~mTU ~vLAN ~physical ~ip_configuration_mode ~iP ~netmask ~gateway ~dNS ~bond_slave_of ~vLAN_master_of ~management ~other_config ~disallow_unplug ~ipv6_configuration_mode ~iPv6 ~ipv6_gateway ~primary_address_type ~managed ~properties))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.pool_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~device ~network ~host ~mAC ~mTU ~vLAN ~physical ~ip_configuration_mode ~iP ~netmask ~gateway ~dNS ~bond_slave_of ~vLAN_master_of ~management ~other_config ~disallow_unplug ~ipv6_configuration_mode ~iPv6 ~ipv6_gateway ~primary_address_type ~managed ~properties) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "16" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.db_introduce" | "PIF_db_introduce" -> 
        begin match __params with
        | session_id_rpc :: device_rpc :: network_rpc :: host_rpc :: mAC_rpc :: mTU_rpc :: vLAN_rpc :: physical_rpc :: ip_configuration_mode_rpc :: iP_rpc :: netmask_rpc :: gateway_rpc :: dNS_rpc :: bond_slave_of_rpc :: vLAN_master_of_rpc :: management_rpc :: other_config_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let disallow_unplug_rpc = try List.nth default_args 0 with _ -> Rpc.Bool false in
            let ipv6_configuration_mode_rpc = try List.nth default_args 1 with _ -> Rpc.String "None" in
            let iPv6_rpc = try List.nth default_args 2 with _ -> Rpc.Enum [] in
            let ipv6_gateway_rpc = try List.nth default_args 3 with _ -> Rpc.String "" in
            let primary_address_type_rpc = try List.nth default_args 4 with _ -> Rpc.String "IPv4" in
            let managed_rpc = try List.nth default_args 5 with _ -> Rpc.Bool true in
            let properties_rpc = try List.nth default_args 6 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let device = string_of_rpc device_rpc in
            let network = ref_network_of_rpc network_rpc in
            let host = ref_host_of_rpc host_rpc in
            let mAC = string_of_rpc mAC_rpc in
            let mTU = int64_of_rpc mTU_rpc in
            let vLAN = int64_of_rpc vLAN_rpc in
            let physical = bool_of_rpc physical_rpc in
            let ip_configuration_mode = ip_configuration_mode_of_rpc ip_configuration_mode_rpc in
            let iP = string_of_rpc iP_rpc in
            let netmask = string_of_rpc netmask_rpc in
            let gateway = string_of_rpc gateway_rpc in
            let dNS = string_of_rpc dNS_rpc in
            let bond_slave_of = ref_Bond_of_rpc bond_slave_of_rpc in
            let vLAN_master_of = ref_VLAN_of_rpc vLAN_master_of_rpc in
            let management = bool_of_rpc management_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            let disallow_unplug = bool_of_rpc disallow_unplug_rpc in
            let ipv6_configuration_mode = ipv6_configuration_mode_of_rpc ipv6_configuration_mode_rpc in
            let iPv6 = string_set_of_rpc iPv6_rpc in
            let ipv6_gateway = string_of_rpc ipv6_gateway_rpc in
            let primary_address_type = primary_address_type_of_rpc primary_address_type_rpc in
            let managed = bool_of_rpc managed_rpc in
            let properties = string_to_string_map_of_rpc properties_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("device", device_rpc); ("network", network_rpc); ("host", host_rpc); ("mAC", mAC_rpc); ("mTU", mTU_rpc); ("vLAN", vLAN_rpc); ("physical", physical_rpc); ("ip_configuration_mode", ip_configuration_mode_rpc); ("iP", iP_rpc); ("netmask", netmask_rpc); ("gateway", gateway_rpc); ("dNS", dNS_rpc); ("bond_slave_of", bond_slave_of_rpc); ("vLAN_master_of", vLAN_master_of_rpc); ("management", management_rpc); ("other_config", other_config_rpc); ("disallow_unplug", disallow_unplug_rpc); ("ipv6_configuration_mode", ipv6_configuration_mode_rpc); ("IPv6", iPv6_rpc); ("ipv6_gateway", ipv6_gateway_rpc); ("primary_address_type", primary_address_type_rpc); ("managed", managed_rpc); ("properties", properties_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.db_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~device ~network ~host ~mAC ~mTU ~vLAN ~physical ~ip_configuration_mode ~iP ~netmask ~gateway ~dNS ~bond_slave_of ~vLAN_master_of ~management ~other_config ~disallow_unplug ~ipv6_configuration_mode ~iPv6 ~ipv6_gateway ~primary_address_type ~managed ~properties))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.db_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~device ~network ~host ~mAC ~mTU ~vLAN ~physical ~ip_configuration_mode ~iP ~netmask ~gateway ~dNS ~bond_slave_of ~vLAN_master_of ~management ~other_config ~disallow_unplug ~ipv6_configuration_mode ~iPv6 ~ipv6_gateway ~primary_address_type ~managed ~properties) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "16" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.db_forget" | "PIF_db_forget" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.db_forget ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.db_forget ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.set_property" | "PIF_set_property" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; name_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_of_rpc self_rpc in
            let name = string_of_rpc name_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("name", name_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PIF.set_property ~__context:(Context.check_for_foreign_database ~__context)  ~self ~name ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PIF.set_property ~__context:(Context.check_for_foreign_database ~__context)  ~self ~name ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_all" | "PIF_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_all_records_where" | "PIF_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_to_pIF_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF.get_all_records" | "PIF_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_to_pIF_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_record" | "PIF_metrics_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pIF_metrics_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_by_uuid" | "PIF_metrics_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_metrics x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_uuid" | "PIF_metrics_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_io_read_kbs" | "PIF_metrics_get_io_read_kbs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_io_write_kbs" | "PIF_metrics_get_io_write_kbs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_carrier" | "PIF_metrics_get_carrier" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_carrier ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_carrier";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_vendor_id" | "PIF_metrics_get_vendor_id" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_vendor_id ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_vendor_id";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_vendor_name" | "PIF_metrics_get_vendor_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_vendor_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_vendor_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_device_id" | "PIF_metrics_get_device_id" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_device_id ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_device_id";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_device_name" | "PIF_metrics_get_device_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_device_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_device_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_speed" | "PIF_metrics_get_speed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_speed ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_speed";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_duplex" | "PIF_metrics_get_duplex" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_duplex ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_duplex";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_pci_bus_path" | "PIF_metrics_get_pci_bus_path" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_pci_bus_path ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_pci_bus_path";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_last_updated" | "PIF_metrics_get_last_updated" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_last_updated ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_last_updated";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_other_config" | "PIF_metrics_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.set_other_config" | "PIF_metrics_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PIF_metrics.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.add_to_other_config" | "PIF_metrics_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PIF_metrics.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.remove_from_other_config" | "PIF_metrics_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PIF_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PIF_metrics.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_all" | "PIF_metrics_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_metrics_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_all_records_where" | "PIF_metrics_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_metrics_to_pIF_metrics_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PIF_metrics.get_all_records" | "PIF_metrics_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_metrics_to_pIF_metrics_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PIF_metrics.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PIF_metrics.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_record" | "Bond_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bond_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_by_uuid" | "Bond_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Bond x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_uuid" | "Bond_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_master" | "Bond_get_master" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_master ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_master";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_slaves" | "Bond_get_slaves" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_slaves ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_slaves";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_other_config" | "Bond_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_primary_slave" | "Bond_get_primary_slave" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_primary_slave ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_primary_slave";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_mode" | "Bond_get_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bond_mode x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_mode";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_properties" | "Bond_get_properties" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_properties ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_properties";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_links_up" | "Bond_get_links_up" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_links_up ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_links_up";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_auto_update_mac" | "Bond_get_auto_update_mac" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_auto_update_mac ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_auto_update_mac";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.set_other_config" | "Bond_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "Bond.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.add_to_other_config" | "Bond_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "Bond.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.remove_from_other_config" | "Bond_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "Bond.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.create" | "Bond_create" -> 
        begin match __params with
        | session_id_rpc :: network_rpc :: members_rpc :: mAC_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let mode_rpc = try List.nth default_args 0 with _ -> Rpc.String "balance-slb" in
            let properties_rpc = try List.nth default_args 1 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let network = ref_network_of_rpc network_rpc in
            let members = ref_PIF_set_of_rpc members_rpc in
            let mAC = string_of_rpc mAC_rpc in
            let mode = bond_mode_of_rpc mode_rpc in
            let properties = string_to_string_map_of_rpc properties_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("network", network_rpc); ("members", members_rpc); ("mAC", mAC_rpc); ("mode", mode_rpc); ("properties", properties_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Bond x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Bond.create ~__context:(Context.check_for_foreign_database ~__context)  ~network ~members ~mAC ~mode ~properties))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Bond.create ~__context:(Context.check_for_foreign_database ~__context)  ~network ~members ~mAC ~mode ~properties) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.destroy" | "Bond_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Bond.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Bond.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.set_mode" | "Bond_set_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            let value = bond_mode_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Bond.set_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Bond.set_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.set_property" | "Bond_set_property" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; name_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Bond_of_rpc self_rpc in
            let name = string_of_rpc name_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("name", name_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Bond.set_property ~__context:(Context.check_for_foreign_database ~__context)  ~self ~name ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Bond.set_property ~__context:(Context.check_for_foreign_database ~__context)  ~self ~name ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_all" | "Bond_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Bond_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_all_records_where" | "Bond_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Bond_to_bond_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Bond.get_all_records" | "Bond_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Bond_to_bond_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Bond.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Bond.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.get_record" | "VLAN_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VLAN_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vLAN_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VLAN.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.get_by_uuid" | "VLAN_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VLAN x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VLAN.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.get_uuid" | "VLAN_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VLAN_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VLAN.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.get_tagged_PIF" | "VLAN_get_tagged_PIF" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VLAN_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.get_tagged_PIF ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VLAN.get_tagged_PIF";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.get_untagged_PIF" | "VLAN_get_untagged_PIF" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VLAN_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.get_untagged_PIF ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VLAN.get_untagged_PIF";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.get_tag" | "VLAN_get_tag" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VLAN_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.get_tag ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VLAN.get_tag";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.get_other_config" | "VLAN_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VLAN_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VLAN.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.set_other_config" | "VLAN_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VLAN_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VLAN.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.add_to_other_config" | "VLAN_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VLAN_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VLAN.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.remove_from_other_config" | "VLAN_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VLAN_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VLAN.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.pool_introduce" | "VLAN_pool_introduce" -> 
        begin match __params with
        | [session_id_rpc; tagged_PIF_rpc; untagged_PIF_rpc; tag_rpc; other_config_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let tagged_PIF = ref_PIF_of_rpc tagged_PIF_rpc in
            let untagged_PIF = ref_PIF_of_rpc untagged_PIF_rpc in
            let tag = int64_of_rpc tag_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("tagged_PIF", tagged_PIF_rpc); ("untagged_PIF", untagged_PIF_rpc); ("tag", tag_rpc); ("other_config", other_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VLAN x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VLAN.pool_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~tagged_PIF ~untagged_PIF ~tag ~other_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VLAN.pool_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~tagged_PIF ~untagged_PIF ~tag ~other_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.create" | "VLAN_create" -> 
        begin match __params with
        | [session_id_rpc; tagged_PIF_rpc; tag_rpc; network_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let tagged_PIF = ref_PIF_of_rpc tagged_PIF_rpc in
            let tag = int64_of_rpc tag_rpc in
            let network = ref_network_of_rpc network_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("tagged_PIF", tagged_PIF_rpc); ("tag", tag_rpc); ("network", network_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VLAN x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VLAN.create ~__context:(Context.check_for_foreign_database ~__context)  ~tagged_PIF ~tag ~network))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VLAN.create ~__context:(Context.check_for_foreign_database ~__context)  ~tagged_PIF ~tag ~network) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.destroy" | "VLAN_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VLAN_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VLAN.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VLAN.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.get_all" | "VLAN_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VLAN_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VLAN.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.get_all_records_where" | "VLAN_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VLAN_to_vLAN_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VLAN.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VLAN.get_all_records" | "VLAN_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VLAN_to_vLAN_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VLAN.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VLAN.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_record" | "SM_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_sM_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_by_uuid" | "SM_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_by_name_label" | "SM_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_uuid" | "SM_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_name_label" | "SM_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_name_description" | "SM_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_type" | "SM_get_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_vendor" | "SM_get_vendor" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_vendor ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_vendor";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_copyright" | "SM_get_copyright" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_copyright ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_copyright";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_version" | "SM_get_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_required_api_version" | "SM_get_required_api_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_required_api_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_required_api_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_configuration" | "SM_get_configuration" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_configuration ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_configuration";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_capabilities" | "SM_get_capabilities" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_capabilities ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_capabilities";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_features" | "SM_get_features" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_int64_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_features ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_features";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_other_config" | "SM_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_driver_filename" | "SM_get_driver_filename" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_driver_filename ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_driver_filename";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_required_cluster_stack" | "SM_get_required_cluster_stack" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_required_cluster_stack ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_required_cluster_stack";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.set_other_config" | "SM_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SM.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SM.add_to_other_config" | "SM_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SM.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "SM.remove_from_other_config" | "SM_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SM_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SM.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_all" | "SM_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SM_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_all_records_where" | "SM_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SM_to_sM_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SM.get_all_records" | "SM_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SM_to_sM_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SM.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SM.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_record" | "SR_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_sR_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_by_uuid" | "SR_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_by_name_label" | "SR_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_uuid" | "SR_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_name_label" | "SR_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_name_description" | "SR_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_allowed_operations" | "SR_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_storage_operations_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_current_operations" | "SR_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_storage_operations_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_VDIs" | "SR_get_VDIs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_VDIs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_VDIs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_PBDs" | "SR_get_PBDs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PBD_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_PBDs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_PBDs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_virtual_allocation" | "SR_get_virtual_allocation" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_virtual_allocation ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_virtual_allocation";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_physical_utilisation" | "SR_get_physical_utilisation" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_physical_utilisation ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_physical_utilisation";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_physical_size" | "SR_get_physical_size" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_physical_size ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_physical_size";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_type" | "SR_get_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_content_type" | "SR_get_content_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_content_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_content_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_shared" | "SR_get_shared" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_shared ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_shared";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_other_config" | "SR_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_tags" | "SR_get_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_sm_config" | "SR_get_sm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_sm_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_sm_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_blobs" | "SR_get_blobs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_ref_blob_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_blobs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_blobs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_local_cache_enabled" | "SR_get_local_cache_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_local_cache_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_local_cache_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_introduced_by" | "SR_get_introduced_by" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_DR_task x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_introduced_by ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_introduced_by";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_clustered" | "SR_get_clustered" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_clustered ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_clustered";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_is_tools_sr" | "SR_get_is_tools_sr" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_is_tools_sr ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_is_tools_sr";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.set_other_config" | "SR_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SR.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.add_to_other_config" | "SR_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = ["folder"; "XenCenter.CustomFields.*"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SR.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "SR.remove_from_other_config" | "SR_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = ["folder"; "XenCenter.CustomFields.*"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SR.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.set_tags" | "SR_set_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let value = string_set_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.set_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SR.set_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.add_tags" | "SR_add_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.add_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SR.add_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.remove_tags" | "SR_remove_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.remove_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SR.remove_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.set_sm_config" | "SR_set_sm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.set_sm_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SR.set_sm_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.add_to_sm_config" | "SR_add_to_sm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.add_to_sm_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SR.add_to_sm_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "SR.remove_from_sm_config" | "SR_remove_from_sm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.remove_from_sm_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "SR.remove_from_sm_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.create" | "SR_create" -> 
        begin match __params with
        | session_id_rpc :: host_rpc :: device_config_rpc :: physical_size_rpc :: name_label_rpc :: name_description_rpc :: _type_rpc :: content_type_rpc :: shared_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let sm_config_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let device_config = string_to_string_map_of_rpc device_config_rpc in
            let physical_size = int64_of_rpc physical_size_rpc in
            let name_label = string_of_rpc name_label_rpc in
            let name_description = string_of_rpc name_description_rpc in
            let _type = string_of_rpc _type_rpc in
            let content_type = string_of_rpc content_type_rpc in
            let shared = bool_of_rpc shared_rpc in
            let sm_config = string_to_string_map_of_rpc sm_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("device_config", device_config_rpc); ("physical_size", physical_size_rpc); ("name_label", name_label_rpc); ("name_description", name_description_rpc); ("_type", _type_rpc); ("content_type", content_type_rpc); ("shared", shared_rpc); ("sm_config", sm_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.create ~__context:(Context.check_for_foreign_database ~__context)  ~host ~device_config ~physical_size ~name_label ~name_description ~_type ~content_type ~shared ~sm_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.create ~__context:(Context.check_for_foreign_database ~__context)  ~host ~device_config ~physical_size ~name_label ~name_description ~_type ~content_type ~shared ~sm_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "8" (string_of_int ((List.length __params) - 1))
        end
    | "SR.introduce" | "SR_introduce" -> 
        begin match __params with
        | session_id_rpc :: uuid_rpc :: name_label_rpc :: name_description_rpc :: _type_rpc :: content_type_rpc :: shared_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let sm_config_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            let name_label = string_of_rpc name_label_rpc in
            let name_description = string_of_rpc name_description_rpc in
            let _type = string_of_rpc _type_rpc in
            let content_type = string_of_rpc content_type_rpc in
            let shared = bool_of_rpc shared_rpc in
            let sm_config = string_to_string_map_of_rpc sm_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc); ("name_label", name_label_rpc); ("name_description", name_description_rpc); ("_type", _type_rpc); ("content_type", content_type_rpc); ("shared", shared_rpc); ("sm_config", sm_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~name_label ~name_description ~_type ~content_type ~shared ~sm_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~name_label ~name_description ~_type ~content_type ~shared ~sm_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "6" (string_of_int ((List.length __params) - 1))
        end
    | "SR.make" | "SR_make" -> 
        begin match __params with
        | session_id_rpc :: host_rpc :: device_config_rpc :: physical_size_rpc :: name_label_rpc :: name_description_rpc :: _type_rpc :: content_type_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let sm_config_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let device_config = string_to_string_map_of_rpc device_config_rpc in
            let physical_size = int64_of_rpc physical_size_rpc in
            let name_label = string_of_rpc name_label_rpc in
            let name_description = string_of_rpc name_description_rpc in
            let _type = string_of_rpc _type_rpc in
            let content_type = string_of_rpc content_type_rpc in
            let sm_config = string_to_string_map_of_rpc sm_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("device_config", device_config_rpc); ("physical_size", physical_size_rpc); ("name_label", name_label_rpc); ("name_description", name_description_rpc); ("_type", _type_rpc); ("content_type", content_type_rpc); ("sm_config", sm_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.make ~__context:(Context.check_for_foreign_database ~__context)  ~host ~device_config ~physical_size ~name_label ~name_description ~_type ~content_type ~sm_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.make ~__context:(Context.check_for_foreign_database ~__context)  ~host ~device_config ~physical_size ~name_label ~name_description ~_type ~content_type ~sm_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "7" (string_of_int ((List.length __params) - 1))
        end
    | "SR.destroy" | "SR_destroy" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~sr))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.forget" | "SR_forget" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.forget ~__context:(Context.check_for_foreign_database ~__context)  ~sr))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.forget ~__context:(Context.check_for_foreign_database ~__context)  ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.update" | "SR_update" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.update ~__context:(Context.check_for_foreign_database ~__context)  ~sr))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.update ~__context:(Context.check_for_foreign_database ~__context)  ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_supported_types" | "SR_get_supported_types" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.get_supported_types ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.get_supported_types ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "SR.scan" | "SR_scan" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.scan ~__context:(Context.check_for_foreign_database ~__context)  ~sr))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.scan ~__context:(Context.check_for_foreign_database ~__context)  ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.probe" | "SR_probe" -> 
        begin match __params with
        | session_id_rpc :: host_rpc :: device_config_rpc :: _type_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let sm_config_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let device_config = string_to_string_map_of_rpc device_config_rpc in
            let _type = string_of_rpc _type_rpc in
            let sm_config = string_to_string_map_of_rpc sm_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("device_config", device_config_rpc); ("_type", _type_rpc); ("sm_config", sm_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.probe ~__context:(Context.check_for_foreign_database ~__context)  ~host ~device_config ~_type ~sm_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.probe ~__context:(Context.check_for_foreign_database ~__context)  ~host ~device_config ~_type ~sm_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "SR.probe_ext" | "SR_probe_ext" -> 
        begin match __params with
        | session_id_rpc :: host_rpc :: device_config_rpc :: _type_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let sm_config_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let device_config = string_to_string_map_of_rpc device_config_rpc in
            let _type = string_of_rpc _type_rpc in
            let sm_config = string_to_string_map_of_rpc sm_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("device_config", device_config_rpc); ("_type", _type_rpc); ("sm_config", sm_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_probe_result_t_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.probe_ext ~__context:(Context.check_for_foreign_database ~__context)  ~host ~device_config ~_type ~sm_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.probe_ext ~__context:(Context.check_for_foreign_database ~__context)  ~host ~device_config ~_type ~sm_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "SR.set_shared" | "SR_set_shared" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.set_shared ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.set_shared ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.set_name_label" | "SR_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.set_name_description" | "SR_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.create_new_blob" | "SR_create_new_blob" -> 
        begin match __params with
        | session_id_rpc :: sr_rpc :: name_rpc :: mime_type_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let public_rpc = try List.nth default_args 0 with _ -> Rpc.Bool false in
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            let name = string_of_rpc name_rpc in
            let mime_type = string_of_rpc mime_type_rpc in
            let public = bool_of_rpc public_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc); ("name", name_rpc); ("mime_type", mime_type_rpc); ("public", public_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_blob x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.create_new_blob ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~name ~mime_type ~public))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.create_new_blob ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~name ~mime_type ~public) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "SR.set_physical_size" | "SR_set_physical_size" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.set_physical_size ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.set_physical_size ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.set_virtual_allocation" | "SR_set_virtual_allocation" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.set_virtual_allocation ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.set_virtual_allocation ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.set_physical_utilisation" | "SR_set_physical_utilisation" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SR_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.set_physical_utilisation ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.set_physical_utilisation ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.assert_can_host_ha_statefile" | "SR_assert_can_host_ha_statefile" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.assert_can_host_ha_statefile ~__context:(Context.check_for_foreign_database ~__context)  ~sr))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.assert_can_host_ha_statefile ~__context:(Context.check_for_foreign_database ~__context)  ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.assert_supports_database_replication" | "SR_assert_supports_database_replication" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.assert_supports_database_replication ~__context:(Context.check_for_foreign_database ~__context)  ~sr))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.assert_supports_database_replication ~__context:(Context.check_for_foreign_database ~__context)  ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.enable_database_replication" | "SR_enable_database_replication" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.enable_database_replication ~__context:(Context.check_for_foreign_database ~__context)  ~sr))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.enable_database_replication ~__context:(Context.check_for_foreign_database ~__context)  ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.disable_database_replication" | "SR_disable_database_replication" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.disable_database_replication ~__context:(Context.check_for_foreign_database ~__context)  ~sr))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.disable_database_replication ~__context:(Context.check_for_foreign_database ~__context)  ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_data_sources" | "SR_get_data_sources" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_data_source_t_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.get_data_sources ~__context:(Context.check_for_foreign_database ~__context)  ~sr))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.get_data_sources ~__context:(Context.check_for_foreign_database ~__context)  ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.record_data_source" | "SR_record_data_source" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc; data_source_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            let data_source = string_of_rpc data_source_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc); ("data_source", data_source_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.record_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~data_source))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.record_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~data_source) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.query_data_source" | "SR_query_data_source" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc; data_source_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            let data_source = string_of_rpc data_source_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc); ("data_source", data_source_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_float x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.query_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~data_source))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.query_data_source ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~data_source) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.forget_data_source_archives" | "SR_forget_data_source_archives" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc; data_source_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            let data_source = string_of_rpc data_source_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc); ("data_source", data_source_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.forget_data_source_archives ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~data_source))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.forget_data_source_archives ~__context:(Context.check_for_foreign_database ~__context)  ~sr ~data_source) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_live_hosts" | "SR_get_live_hosts" -> 
        begin match __params with
        | [session_id_rpc; sr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("sr", sr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SR.get_live_hosts ~__context:(Context.check_for_foreign_database ~__context)  ~sr))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SR.get_live_hosts ~__context:(Context.check_for_foreign_database ~__context)  ~sr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_all" | "SR_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_all_records_where" | "SR_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR_to_sR_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SR.get_all_records" | "SR_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR_to_sR_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SR.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SR.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "LVHD.get_record" | "LVHD_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_LVHD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_lVHD_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.LVHD.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "LVHD.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "LVHD.get_by_uuid" | "LVHD_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_LVHD x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.LVHD.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "LVHD.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "LVHD.get_uuid" | "LVHD_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_LVHD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.LVHD.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "LVHD.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "LVHD.enable_thin_provisioning" | "LVHD_enable_thin_provisioning" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; sR_rpc; initial_allocation_rpc; allocation_quantum_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let _host = ref_host_of_rpc host_rpc in
            let _sR = ref_SR_of_rpc sR_rpc in
            let _initial_allocation = int64_of_rpc initial_allocation_rpc in
            let _allocation_quantum = int64_of_rpc allocation_quantum_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("sR", sR_rpc); ("initial_allocation", initial_allocation_rpc); ("allocation_quantum", allocation_quantum_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let host = ref_host_of_rpc host_rpc in
            let call_string = Jsonrpc.string_of_call {call with name=__call} in
            let marshaller = (fun x -> x) in
            let local_op = fun ~__context -> (rbac __context (fun()->(Custom.Host.call_extension ~__context:(Context.check_for_foreign_database ~__context) ~host ~call:call_string))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Host.call_extension ~__context:(Context.check_for_foreign_database ~__context) ~host ~call:call_string) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            if resp.Rpc.success then
              try
                D.debug "HostExtension '%s' resp \"%s\"" __call (Jsonrpc.string_of_response resp);
                ignore(if __sync_ty = `Sync then let _ = (fun x -> string_of_rpc x) resp.contents in ());
                resp
              with
              | _ -> API.response_of_failure Api_errors.internal_error [string_of_rpc resp.Rpc.contents]
            else
              Server_helpers.unknown_rpc_failure __call
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_record" | "VDI_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vDI_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_by_uuid" | "VDI_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.create" | "VDI_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let name_label = string_of_rpc ((List.assoc_opt "name_label" __structure) |> Option.value ~default:(Rpc.String "")) in
            let name_description = string_of_rpc ((List.assoc_opt "name_description" __structure) |> Option.value ~default:(Rpc.String "")) in
            let sR = ref_SR_of_rpc (my_assoc "SR" __structure) in
            let virtual_size = int64_of_rpc (my_assoc "virtual_size" __structure) in
            let _type = vdi_type_of_rpc (my_assoc "type" __structure) in
            let sharable = bool_of_rpc (my_assoc "sharable" __structure) in
            let read_only = bool_of_rpc (my_assoc "read_only" __structure) in
            let other_config = string_to_string_map_of_rpc (my_assoc "other_config" __structure) in
            let xenstore_data = string_to_string_map_of_rpc ((List.assoc_opt "xenstore_data" __structure) |> Option.value ~default:(Rpc.Dict [])) in
            let sm_config = string_to_string_map_of_rpc ((List.assoc_opt "sm_config" __structure) |> Option.value ~default:(Rpc.Dict [])) in
            let tags = string_set_of_rpc ((List.assoc_opt "tags" __structure) |> Option.value ~default:(Rpc.Enum [])) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~sR ~virtual_size ~_type ~sharable ~read_only ~other_config ~xenstore_data ~sm_config ~tags))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~sR ~virtual_size ~_type ~sharable ~read_only ~other_config ~xenstore_data ~sm_config ~tags) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.destroy" | "VDI_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_by_name_label" | "VDI_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_uuid" | "VDI_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_name_label" | "VDI_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_name_description" | "VDI_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_allowed_operations" | "VDI_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vdi_operations_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_current_operations" | "VDI_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_vdi_operations_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_SR" | "VDI_get_SR" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_SR ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_SR";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_VBDs" | "VDI_get_VBDs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VBD_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_VBDs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_VBDs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_crash_dumps" | "VDI_get_crash_dumps" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_crashdump_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_crash_dumps ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_crash_dumps";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_virtual_size" | "VDI_get_virtual_size" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_virtual_size ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_virtual_size";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_physical_utilisation" | "VDI_get_physical_utilisation" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_physical_utilisation ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_physical_utilisation";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_type" | "VDI_get_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vdi_type x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_sharable" | "VDI_get_sharable" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_sharable ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_sharable";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_read_only" | "VDI_get_read_only" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_read_only ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_read_only";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_other_config" | "VDI_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_storage_lock" | "VDI_get_storage_lock" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_storage_lock ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_storage_lock";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_location" | "VDI_get_location" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_location ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_location";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_managed" | "VDI_get_managed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_managed ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_managed";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_missing" | "VDI_get_missing" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_missing ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_missing";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_parent" | "VDI_get_parent" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_parent ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_parent";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_xenstore_data" | "VDI_get_xenstore_data" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_xenstore_data ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_xenstore_data";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_sm_config" | "VDI_get_sm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_sm_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_sm_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_is_a_snapshot" | "VDI_get_is_a_snapshot" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_is_a_snapshot ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_is_a_snapshot";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_snapshot_of" | "VDI_get_snapshot_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_snapshot_of ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_snapshot_of";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_snapshots" | "VDI_get_snapshots" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_snapshots ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_snapshots";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_snapshot_time" | "VDI_get_snapshot_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_snapshot_time ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_snapshot_time";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_tags" | "VDI_get_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_allow_caching" | "VDI_get_allow_caching" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_allow_caching ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_allow_caching";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_on_boot" | "VDI_get_on_boot" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_on_boot x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_on_boot ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_on_boot";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_metadata_of_pool" | "VDI_get_metadata_of_pool" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_pool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_metadata_of_pool ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_metadata_of_pool";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_metadata_latest" | "VDI_get_metadata_latest" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_metadata_latest ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_metadata_latest";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_is_tools_iso" | "VDI_get_is_tools_iso" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_is_tools_iso ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_is_tools_iso";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_cbt_enabled" | "VDI_get_cbt_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_cbt_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_cbt_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_other_config" | "VDI_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.add_to_other_config" | "VDI_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = ["folder"; "XenCenter.CustomFields.*"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.remove_from_other_config" | "VDI_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = ["folder"; "XenCenter.CustomFields.*"] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_xenstore_data" | "VDI_set_xenstore_data" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.set_xenstore_data ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.set_xenstore_data";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.add_to_xenstore_data" | "VDI_add_to_xenstore_data" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.add_to_xenstore_data ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.add_to_xenstore_data";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.remove_from_xenstore_data" | "VDI_remove_from_xenstore_data" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.remove_from_xenstore_data ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.remove_from_xenstore_data";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_sm_config" | "VDI_set_sm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.set_sm_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.set_sm_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.add_to_sm_config" | "VDI_add_to_sm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.add_to_sm_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.add_to_sm_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.remove_from_sm_config" | "VDI_remove_from_sm_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.remove_from_sm_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.remove_from_sm_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_tags" | "VDI_set_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = string_set_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.set_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.set_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.add_tags" | "VDI_add_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.add_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.add_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.remove_tags" | "VDI_remove_tags" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.remove_tags ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VDI.remove_tags";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.snapshot" | "VDI_snapshot" -> 
        begin match __params with
        | session_id_rpc :: vdi_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let driver_params_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            let driver_params = string_to_string_map_of_rpc driver_params_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vdi", vdi_rpc); ("driver_params", driver_params_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.snapshot ~__context:(Context.check_for_foreign_database ~__context)  ~vdi ~driver_params))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.snapshot ~__context:(Context.check_for_foreign_database ~__context)  ~vdi ~driver_params) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.clone" | "VDI_clone" -> 
        begin match __params with
        | session_id_rpc :: vdi_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let driver_params_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            let driver_params = string_to_string_map_of_rpc driver_params_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vdi", vdi_rpc); ("driver_params", driver_params_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.clone ~__context:(Context.check_for_foreign_database ~__context)  ~vdi ~driver_params))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.clone ~__context:(Context.check_for_foreign_database ~__context)  ~vdi ~driver_params) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.resize" | "VDI_resize" -> 
        begin match __params with
        | [session_id_rpc; vdi_rpc; size_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            let size = int64_of_rpc size_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vdi", vdi_rpc); ("size", size_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.resize ~__context:(Context.check_for_foreign_database ~__context)  ~vdi ~size))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.resize ~__context:(Context.check_for_foreign_database ~__context)  ~vdi ~size) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.resize_online" | "VDI_resize_online" -> 
        begin match __params with
        | [session_id_rpc; vdi_rpc; size_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.introduce" | "VDI_introduce" -> 
        begin match __params with
        | session_id_rpc :: uuid_rpc :: name_label_rpc :: name_description_rpc :: sR_rpc :: _type_rpc :: sharable_rpc :: read_only_rpc :: other_config_rpc :: location_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let xenstore_data_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let sm_config_rpc = try List.nth default_args 1 with _ -> Rpc.Dict [] in
            let managed_rpc = try List.nth default_args 2 with _ -> Rpc.Bool true in
            let virtual_size_rpc = try List.nth default_args 3 with _ -> Rpc.Int (0L) in
            let physical_utilisation_rpc = try List.nth default_args 4 with _ -> Rpc.Int (0L) in
            let metadata_of_pool_rpc = try List.nth default_args 5 with _ -> Rpc.String "" in
            let is_a_snapshot_rpc = try List.nth default_args 6 with _ -> Rpc.Bool false in
            let snapshot_time_rpc = try List.nth default_args 7 with _ -> Rpc.String "19700101T00:00:00Z" in
            let snapshot_of_rpc = try List.nth default_args 8 with _ -> Rpc.String "" in
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            let name_label = string_of_rpc name_label_rpc in
            let name_description = string_of_rpc name_description_rpc in
            let sR = ref_SR_of_rpc sR_rpc in
            let _type = vdi_type_of_rpc _type_rpc in
            let sharable = bool_of_rpc sharable_rpc in
            let read_only = bool_of_rpc read_only_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            let location = string_of_rpc location_rpc in
            let xenstore_data = string_to_string_map_of_rpc xenstore_data_rpc in
            let sm_config = string_to_string_map_of_rpc sm_config_rpc in
            let managed = bool_of_rpc managed_rpc in
            let virtual_size = int64_of_rpc virtual_size_rpc in
            let physical_utilisation = int64_of_rpc physical_utilisation_rpc in
            let metadata_of_pool = ref_pool_of_rpc metadata_of_pool_rpc in
            let is_a_snapshot = bool_of_rpc is_a_snapshot_rpc in
            let snapshot_time = datetime_of_rpc snapshot_time_rpc in
            let snapshot_of = ref_VDI_of_rpc snapshot_of_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc); ("name_label", name_label_rpc); ("name_description", name_description_rpc); ("sR", sR_rpc); ("_type", _type_rpc); ("sharable", sharable_rpc); ("read_only", read_only_rpc); ("other_config", other_config_rpc); ("location", location_rpc); ("xenstore_data", xenstore_data_rpc); ("sm_config", sm_config_rpc); ("managed", managed_rpc); ("virtual_size", virtual_size_rpc); ("physical_utilisation", physical_utilisation_rpc); ("metadata_of_pool", metadata_of_pool_rpc); ("is_a_snapshot", is_a_snapshot_rpc); ("snapshot_time", snapshot_time_rpc); ("snapshot_of", snapshot_of_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~name_label ~name_description ~sR ~_type ~sharable ~read_only ~other_config ~location ~xenstore_data ~sm_config ~managed ~virtual_size ~physical_utilisation ~metadata_of_pool ~is_a_snapshot ~snapshot_time ~snapshot_of))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~name_label ~name_description ~sR ~_type ~sharable ~read_only ~other_config ~location ~xenstore_data ~sm_config ~managed ~virtual_size ~physical_utilisation ~metadata_of_pool ~is_a_snapshot ~snapshot_time ~snapshot_of) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "9" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.pool_introduce" | "VDI_pool_introduce" -> 
        begin match __params with
        | session_id_rpc :: uuid_rpc :: name_label_rpc :: name_description_rpc :: sR_rpc :: _type_rpc :: sharable_rpc :: read_only_rpc :: other_config_rpc :: location_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let xenstore_data_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let sm_config_rpc = try List.nth default_args 1 with _ -> Rpc.Dict [] in
            let managed_rpc = try List.nth default_args 2 with _ -> Rpc.Bool true in
            let virtual_size_rpc = try List.nth default_args 3 with _ -> Rpc.Int (0L) in
            let physical_utilisation_rpc = try List.nth default_args 4 with _ -> Rpc.Int (0L) in
            let metadata_of_pool_rpc = try List.nth default_args 5 with _ -> Rpc.String "" in
            let is_a_snapshot_rpc = try List.nth default_args 6 with _ -> Rpc.Bool false in
            let snapshot_time_rpc = try List.nth default_args 7 with _ -> Rpc.String "19700101T00:00:00Z" in
            let snapshot_of_rpc = try List.nth default_args 8 with _ -> Rpc.String "" in
            let cbt_enabled_rpc = try List.nth default_args 9 with _ -> Rpc.Bool false in
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            let name_label = string_of_rpc name_label_rpc in
            let name_description = string_of_rpc name_description_rpc in
            let sR = ref_SR_of_rpc sR_rpc in
            let _type = vdi_type_of_rpc _type_rpc in
            let sharable = bool_of_rpc sharable_rpc in
            let read_only = bool_of_rpc read_only_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            let location = string_of_rpc location_rpc in
            let xenstore_data = string_to_string_map_of_rpc xenstore_data_rpc in
            let sm_config = string_to_string_map_of_rpc sm_config_rpc in
            let managed = bool_of_rpc managed_rpc in
            let virtual_size = int64_of_rpc virtual_size_rpc in
            let physical_utilisation = int64_of_rpc physical_utilisation_rpc in
            let metadata_of_pool = ref_pool_of_rpc metadata_of_pool_rpc in
            let is_a_snapshot = bool_of_rpc is_a_snapshot_rpc in
            let snapshot_time = datetime_of_rpc snapshot_time_rpc in
            let snapshot_of = ref_VDI_of_rpc snapshot_of_rpc in
            let cbt_enabled = bool_of_rpc cbt_enabled_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc); ("name_label", name_label_rpc); ("name_description", name_description_rpc); ("sR", sR_rpc); ("_type", _type_rpc); ("sharable", sharable_rpc); ("read_only", read_only_rpc); ("other_config", other_config_rpc); ("location", location_rpc); ("xenstore_data", xenstore_data_rpc); ("sm_config", sm_config_rpc); ("managed", managed_rpc); ("virtual_size", virtual_size_rpc); ("physical_utilisation", physical_utilisation_rpc); ("metadata_of_pool", metadata_of_pool_rpc); ("is_a_snapshot", is_a_snapshot_rpc); ("snapshot_time", snapshot_time_rpc); ("snapshot_of", snapshot_of_rpc); ("cbt_enabled", cbt_enabled_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.pool_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~name_label ~name_description ~sR ~_type ~sharable ~read_only ~other_config ~location ~xenstore_data ~sm_config ~managed ~virtual_size ~physical_utilisation ~metadata_of_pool ~is_a_snapshot ~snapshot_time ~snapshot_of ~cbt_enabled))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.pool_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~name_label ~name_description ~sR ~_type ~sharable ~read_only ~other_config ~location ~xenstore_data ~sm_config ~managed ~virtual_size ~physical_utilisation ~metadata_of_pool ~is_a_snapshot ~snapshot_time ~snapshot_of ~cbt_enabled) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "9" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.db_introduce" | "VDI_db_introduce" -> 
        begin match __params with
        | session_id_rpc :: uuid_rpc :: name_label_rpc :: name_description_rpc :: sR_rpc :: _type_rpc :: sharable_rpc :: read_only_rpc :: other_config_rpc :: location_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let xenstore_data_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let sm_config_rpc = try List.nth default_args 1 with _ -> Rpc.Dict [] in
            let managed_rpc = try List.nth default_args 2 with _ -> Rpc.Bool true in
            let virtual_size_rpc = try List.nth default_args 3 with _ -> Rpc.Int (0L) in
            let physical_utilisation_rpc = try List.nth default_args 4 with _ -> Rpc.Int (0L) in
            let metadata_of_pool_rpc = try List.nth default_args 5 with _ -> Rpc.String "" in
            let is_a_snapshot_rpc = try List.nth default_args 6 with _ -> Rpc.Bool false in
            let snapshot_time_rpc = try List.nth default_args 7 with _ -> Rpc.String "19700101T00:00:00Z" in
            let snapshot_of_rpc = try List.nth default_args 8 with _ -> Rpc.String "" in
            let cbt_enabled_rpc = try List.nth default_args 9 with _ -> Rpc.Bool false in
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            let name_label = string_of_rpc name_label_rpc in
            let name_description = string_of_rpc name_description_rpc in
            let sR = ref_SR_of_rpc sR_rpc in
            let _type = vdi_type_of_rpc _type_rpc in
            let sharable = bool_of_rpc sharable_rpc in
            let read_only = bool_of_rpc read_only_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            let location = string_of_rpc location_rpc in
            let xenstore_data = string_to_string_map_of_rpc xenstore_data_rpc in
            let sm_config = string_to_string_map_of_rpc sm_config_rpc in
            let managed = bool_of_rpc managed_rpc in
            let virtual_size = int64_of_rpc virtual_size_rpc in
            let physical_utilisation = int64_of_rpc physical_utilisation_rpc in
            let metadata_of_pool = ref_pool_of_rpc metadata_of_pool_rpc in
            let is_a_snapshot = bool_of_rpc is_a_snapshot_rpc in
            let snapshot_time = datetime_of_rpc snapshot_time_rpc in
            let snapshot_of = ref_VDI_of_rpc snapshot_of_rpc in
            let cbt_enabled = bool_of_rpc cbt_enabled_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc); ("name_label", name_label_rpc); ("name_description", name_description_rpc); ("sR", sR_rpc); ("_type", _type_rpc); ("sharable", sharable_rpc); ("read_only", read_only_rpc); ("other_config", other_config_rpc); ("location", location_rpc); ("xenstore_data", xenstore_data_rpc); ("sm_config", sm_config_rpc); ("managed", managed_rpc); ("virtual_size", virtual_size_rpc); ("physical_utilisation", physical_utilisation_rpc); ("metadata_of_pool", metadata_of_pool_rpc); ("is_a_snapshot", is_a_snapshot_rpc); ("snapshot_time", snapshot_time_rpc); ("snapshot_of", snapshot_of_rpc); ("cbt_enabled", cbt_enabled_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.db_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~name_label ~name_description ~sR ~_type ~sharable ~read_only ~other_config ~location ~xenstore_data ~sm_config ~managed ~virtual_size ~physical_utilisation ~metadata_of_pool ~is_a_snapshot ~snapshot_time ~snapshot_of ~cbt_enabled))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.db_introduce ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~name_label ~name_description ~sR ~_type ~sharable ~read_only ~other_config ~location ~xenstore_data ~sm_config ~managed ~virtual_size ~physical_utilisation ~metadata_of_pool ~is_a_snapshot ~snapshot_time ~snapshot_of ~cbt_enabled) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "9" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.db_forget" | "VDI_db_forget" -> 
        begin match __params with
        | [session_id_rpc; vdi_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vdi", vdi_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.db_forget ~__context:(Context.check_for_foreign_database ~__context)  ~vdi))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.db_forget ~__context:(Context.check_for_foreign_database ~__context)  ~vdi) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.update" | "VDI_update" -> 
        begin match __params with
        | [session_id_rpc; vdi_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vdi", vdi_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.update ~__context:(Context.check_for_foreign_database ~__context)  ~vdi))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.update ~__context:(Context.check_for_foreign_database ~__context)  ~vdi) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.copy" | "VDI_copy" -> 
        begin match __params with
        | session_id_rpc :: vdi_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let sr_rpc = try List.nth default_args 0 with _ -> Rpc.String "OpaqueRef:NULL" in
            let base_vdi_rpc = try List.nth default_args 1 with _ -> Rpc.String "OpaqueRef:NULL" in
            let into_vdi_rpc = try List.nth default_args 2 with _ -> Rpc.String "OpaqueRef:NULL" in
            let session_id = ref_session_of_rpc session_id_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            let base_vdi = ref_VDI_of_rpc base_vdi_rpc in
            let into_vdi = ref_VDI_of_rpc into_vdi_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vdi", vdi_rpc); ("sr", sr_rpc); ("base_vdi", base_vdi_rpc); ("into_vdi", into_vdi_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.copy ~__context:(Context.check_for_foreign_database ~__context)  ~vdi ~sr ~base_vdi ~into_vdi))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.copy ~__context:(Context.check_for_foreign_database ~__context)  ~vdi ~sr ~base_vdi ~into_vdi) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.force_unlock" | "VDI_force_unlock" -> 
        begin match __params with
        | [session_id_rpc; vdi_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vdi", vdi_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.force_unlock ~__context:(Context.check_for_foreign_database ~__context)  ~vdi))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.force_unlock ~__context:(Context.check_for_foreign_database ~__context)  ~vdi) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_managed" | "VDI_set_managed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_managed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_managed ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.forget" | "VDI_forget" -> 
        begin match __params with
        | [session_id_rpc; vdi_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vdi", vdi_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.forget ~__context:(Context.check_for_foreign_database ~__context)  ~vdi))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.forget ~__context:(Context.check_for_foreign_database ~__context)  ~vdi) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_sharable" | "VDI_set_sharable" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_sharable ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_sharable ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_read_only" | "VDI_set_read_only" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_read_only ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_read_only ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_missing" | "VDI_set_missing" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_missing ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_missing ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_virtual_size" | "VDI_set_virtual_size" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_virtual_size ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_virtual_size ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_physical_utilisation" | "VDI_set_physical_utilisation" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = int64_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_physical_utilisation ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_physical_utilisation ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_is_a_snapshot" | "VDI_set_is_a_snapshot" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_is_a_snapshot ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_is_a_snapshot ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_snapshot_of" | "VDI_set_snapshot_of" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = ref_VDI_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_snapshot_of ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_snapshot_of ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_snapshot_time" | "VDI_set_snapshot_time" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = datetime_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_snapshot_time ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_snapshot_time ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_metadata_of_pool" | "VDI_set_metadata_of_pool" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = ref_pool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_metadata_of_pool ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_metadata_of_pool ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_name_label" | "VDI_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_name_description" | "VDI_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.generate_config" | "VDI_generate_config" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; vdi_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("vdi", vdi_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.generate_config ~__context:(Context.check_for_foreign_database ~__context)  ~host ~vdi))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.generate_config ~__context:(Context.check_for_foreign_database ~__context)  ~host ~vdi) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_on_boot" | "VDI_set_on_boot" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = on_boot_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_on_boot ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_on_boot ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_allow_caching" | "VDI_set_allow_caching" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_allow_caching ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_allow_caching ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.open_database" | "VDI_open_database" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_session x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.open_database ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.open_database ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.checksum" | "VDI_checksum" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.checksum ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.checksum ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.read_database_pool_uuid" | "VDI_read_database_pool_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.read_database_pool_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.read_database_pool_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.pool_migrate" | "VDI_pool_migrate" -> 
        begin match __params with
        | [session_id_rpc; vdi_rpc; sr_rpc; options_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            let sr = ref_SR_of_rpc sr_rpc in
            let options = string_to_string_map_of_rpc options_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vdi", vdi_rpc); ("sr", sr_rpc); ("options", options_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.pool_migrate ~__context:(Context.check_for_foreign_database ~__context)  ~vdi ~sr ~options))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.pool_migrate ~__context:(Context.check_for_foreign_database ~__context)  ~vdi ~sr ~options) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.enable_cbt" | "VDI_enable_cbt" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.enable_cbt ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.enable_cbt ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.disable_cbt" | "VDI_disable_cbt" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.disable_cbt ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.disable_cbt ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.set_cbt_enabled" | "VDI_set_cbt_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.set_cbt_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.set_cbt_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.data_destroy" | "VDI_data_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.data_destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.data_destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.list_changed_blocks" | "VDI_list_changed_blocks" -> 
        begin match __params with
        | [session_id_rpc; vdi_from_rpc; vdi_to_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vdi_from = ref_VDI_of_rpc vdi_from_rpc in
            let vdi_to = ref_VDI_of_rpc vdi_to_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vdi_from", vdi_from_rpc); ("vdi_to", vdi_to_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.list_changed_blocks ~__context:(Context.check_for_foreign_database ~__context)  ~vdi_from ~vdi_to))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.list_changed_blocks ~__context:(Context.check_for_foreign_database ~__context)  ~vdi_from ~vdi_to) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_nbd_info" | "VDI_get_nbd_info" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VDI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vdi_nbd_server_info_t_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VDI.get_nbd_info ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VDI.get_nbd_info ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_all" | "VDI_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_all_records_where" | "VDI_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI_to_vDI_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VDI.get_all_records" | "VDI_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI_to_vDI_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VDI.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VDI.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_record" | "VBD_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vBD_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_by_uuid" | "VBD_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VBD x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.create" | "VBD_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let vM = ref_VM_of_rpc (my_assoc "VM" __structure) in
            let vDI = ref_VDI_of_rpc (my_assoc "VDI" __structure) in
            let device = string_of_rpc ((List.assoc_opt "device" __structure) |> Option.value ~default:(Rpc.String "")) in
            let userdevice = string_of_rpc (my_assoc "userdevice" __structure) in
            let bootable = bool_of_rpc (my_assoc "bootable" __structure) in
            let mode = vbd_mode_of_rpc (my_assoc "mode" __structure) in
            let _type = vbd_type_of_rpc (my_assoc "type" __structure) in
            let unpluggable = bool_of_rpc ((List.assoc_opt "unpluggable" __structure) |> Option.value ~default:(Rpc.Bool true)) in
            let empty = bool_of_rpc (my_assoc "empty" __structure) in
            let other_config = string_to_string_map_of_rpc (my_assoc "other_config" __structure) in
            let currently_attached = bool_of_rpc ((List.assoc_opt "currently_attached" __structure) |> Option.value ~default:(Rpc.Bool false)) in
            let qos_algorithm_type = string_of_rpc (my_assoc "qos_algorithm_type" __structure) in
            let qos_algorithm_params = string_to_string_map_of_rpc (my_assoc "qos_algorithm_params" __structure) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VBD x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.create ~__context:(Context.check_for_foreign_database ~__context)  ~vM ~vDI ~device ~userdevice ~bootable ~mode ~_type ~unpluggable ~empty ~other_config ~currently_attached ~qos_algorithm_type ~qos_algorithm_params))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.create ~__context:(Context.check_for_foreign_database ~__context)  ~vM ~vDI ~device ~userdevice ~bootable ~mode ~_type ~unpluggable ~empty ~other_config ~currently_attached ~qos_algorithm_type ~qos_algorithm_params) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.destroy" | "VBD_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_uuid" | "VBD_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_allowed_operations" | "VBD_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vbd_operations_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_current_operations" | "VBD_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_vbd_operations_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_VM" | "VBD_get_VM" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_VM ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_VM";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_VDI" | "VBD_get_VDI" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_VDI ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_VDI";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_device" | "VBD_get_device" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_device ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_device";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_userdevice" | "VBD_get_userdevice" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_userdevice ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_userdevice";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_bootable" | "VBD_get_bootable" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_bootable ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_bootable";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_mode" | "VBD_get_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vbd_mode x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_mode";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_type" | "VBD_get_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vbd_type x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_unpluggable" | "VBD_get_unpluggable" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_unpluggable ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_unpluggable";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_storage_lock" | "VBD_get_storage_lock" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_storage_lock ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_storage_lock";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_empty" | "VBD_get_empty" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_empty ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_empty";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_other_config" | "VBD_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_currently_attached" | "VBD_get_currently_attached" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_currently_attached ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_currently_attached";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_status_code" | "VBD_get_status_code" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_status_code ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_status_code";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_status_detail" | "VBD_get_status_detail" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_status_detail ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_status_detail";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_runtime_properties" | "VBD_get_runtime_properties" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_runtime_properties ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_runtime_properties";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_qos_algorithm_type" | "VBD_get_qos_algorithm_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_qos_algorithm_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_qos_algorithm_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_qos_algorithm_params" | "VBD_get_qos_algorithm_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_qos_algorithm_params ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_qos_algorithm_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_qos_supported_algorithms" | "VBD_get_qos_supported_algorithms" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_qos_supported_algorithms ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_qos_supported_algorithms";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_metrics" | "VBD_get_metrics" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.set_userdevice" | "VBD_set_userdevice" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.set_userdevice ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD.set_userdevice";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.set_bootable" | "VBD_set_bootable" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.set_bootable ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD.set_bootable";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.set_type" | "VBD_set_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let value = vbd_type_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.set_type ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD.set_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.set_unpluggable" | "VBD_set_unpluggable" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.set_unpluggable ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD.set_unpluggable";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.set_other_config" | "VBD_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.add_to_other_config" | "VBD_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.remove_from_other_config" | "VBD_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.set_qos_algorithm_type" | "VBD_set_qos_algorithm_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.set_qos_algorithm_type ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD.set_qos_algorithm_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.set_qos_algorithm_params" | "VBD_set_qos_algorithm_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.set_qos_algorithm_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD.set_qos_algorithm_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.add_to_qos_algorithm_params" | "VBD_add_to_qos_algorithm_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.add_to_qos_algorithm_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD.add_to_qos_algorithm_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.remove_from_qos_algorithm_params" | "VBD_remove_from_qos_algorithm_params" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.remove_from_qos_algorithm_params ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD.remove_from_qos_algorithm_params";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.eject" | "VBD_eject" -> 
        begin match __params with
        | [session_id_rpc; vbd_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vbd = ref_VBD_of_rpc vbd_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vbd", vbd_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.eject ~__context:(Context.check_for_foreign_database ~__context)  ~vbd))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.eject ~__context:(Context.check_for_foreign_database ~__context)  ~vbd) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.insert" | "VBD_insert" -> 
        begin match __params with
        | [session_id_rpc; vbd_rpc; vdi_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let vbd = ref_VBD_of_rpc vbd_rpc in
            let vdi = ref_VDI_of_rpc vdi_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vbd", vbd_rpc); ("vdi", vdi_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.insert ~__context:(Context.check_for_foreign_database ~__context)  ~vbd ~vdi))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.insert ~__context:(Context.check_for_foreign_database ~__context)  ~vbd ~vdi) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.plug" | "VBD_plug" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.plug ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.plug ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.unplug" | "VBD_unplug" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.unplug_force" | "VBD_unplug_force" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.unplug_force ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.unplug_force ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.unplug_force_no_safety_check" | "VBD_unplug_force_no_safety_check" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.unplug_force_no_safety_check ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.unplug_force_no_safety_check ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.assert_attachable" | "VBD_assert_attachable" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.assert_attachable ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.assert_attachable ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.pause" | "VBD_pause" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.pause ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.pause ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.unpause" | "VBD_unpause" -> 
        begin match __params with
        | session_id_rpc :: self_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let token_rpc = try List.nth default_args 0 with _ -> Rpc.String "" in
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let token = string_of_rpc token_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("token", token_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.unpause ~__context:(Context.check_for_foreign_database ~__context)  ~self ~token))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.unpause ~__context:(Context.check_for_foreign_database ~__context)  ~self ~token) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.set_mode" | "VBD_set_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_of_rpc self_rpc in
            let value = vbd_mode_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VBD.set_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VBD.set_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_all" | "VBD_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VBD_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_all_records_where" | "VBD_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VBD_to_vBD_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD.get_all_records" | "VBD_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VBD_to_vBD_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.get_record" | "VBD_metrics_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.get_by_uuid" | "VBD_metrics_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.get_uuid" | "VBD_metrics_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD_metrics.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD_metrics.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.get_io_read_kbs" | "VBD_metrics_get_io_read_kbs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.get_io_write_kbs" | "VBD_metrics_get_io_write_kbs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.get_last_updated" | "VBD_metrics_get_last_updated" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD_metrics.get_last_updated ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD_metrics.get_last_updated";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.get_other_config" | "VBD_metrics_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_metrics_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD_metrics.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VBD_metrics.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.set_other_config" | "VBD_metrics_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_metrics_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD_metrics.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD_metrics.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.add_to_other_config" | "VBD_metrics_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD_metrics.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD_metrics.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.remove_from_other_config" | "VBD_metrics_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VBD_metrics_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VBD_metrics.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VBD_metrics.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.get_all" | "VBD_metrics_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.get_all_records_where" | "VBD_metrics_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VBD_metrics.get_all_records" | "VBD_metrics_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            response_of_failure Api_errors.message_removed []
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.get_record" | "PBD_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pBD_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PBD.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.get_by_uuid" | "PBD_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PBD x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PBD.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.create" | "PBD_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let host = ref_host_of_rpc (my_assoc "host" __structure) in
            let sR = ref_SR_of_rpc (my_assoc "SR" __structure) in
            let device_config = string_to_string_map_of_rpc (my_assoc "device_config" __structure) in
            let other_config = string_to_string_map_of_rpc ((List.assoc_opt "other_config" __structure) |> Option.value ~default:(Rpc.Dict [])) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PBD x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PBD.create ~__context:(Context.check_for_foreign_database ~__context)  ~host ~sR ~device_config ~other_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PBD.create ~__context:(Context.check_for_foreign_database ~__context)  ~host ~sR ~device_config ~other_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.destroy" | "PBD_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PBD.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PBD.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.get_uuid" | "PBD_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PBD.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.get_host" | "PBD_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PBD.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.get_SR" | "PBD_get_SR" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.get_SR ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PBD.get_SR";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.get_device_config" | "PBD_get_device_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.get_device_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PBD.get_device_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.get_currently_attached" | "PBD_get_currently_attached" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.get_currently_attached ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PBD.get_currently_attached";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.get_other_config" | "PBD_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PBD.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.set_other_config" | "PBD_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PBD.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.add_to_other_config" | "PBD_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PBD.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.remove_from_other_config" | "PBD_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PBD.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.plug" | "PBD_plug" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PBD.plug ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PBD.plug ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.unplug" | "PBD_unplug" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PBD.unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PBD.unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.set_device_config" | "PBD_set_device_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PBD_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PBD.set_device_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PBD.set_device_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.get_all" | "PBD_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PBD_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PBD.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.get_all_records_where" | "PBD_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PBD_to_pBD_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PBD.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PBD.get_all_records" | "PBD_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PBD_to_pBD_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PBD.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PBD.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.get_record" | "crashdump_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_crashdump_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "crashdump.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.get_by_uuid" | "crashdump_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_crashdump x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "crashdump.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.get_uuid" | "crashdump_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "crashdump.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.get_VM" | "crashdump_get_VM" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.get_VM ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "crashdump.get_VM";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.get_VDI" | "crashdump_get_VDI" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.get_VDI ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "crashdump.get_VDI";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.get_other_config" | "crashdump_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "crashdump.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.set_other_config" | "crashdump_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_crashdump_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "crashdump.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.add_to_other_config" | "crashdump_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_crashdump_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "crashdump.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.remove_from_other_config" | "crashdump_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_crashdump_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "crashdump.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.destroy" | "crashdump_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_crashdump_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Crashdump.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Crashdump.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.get_all" | "crashdump_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_crashdump_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "crashdump.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.get_all_records_where" | "crashdump_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_crashdump_to_crashdump_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "crashdump.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "crashdump.get_all_records" | "crashdump_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_crashdump_to_crashdump_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Crashdump.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "crashdump.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VTPM.get_record" | "VTPM_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VTPM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vTPM_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VTPM.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VTPM.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VTPM.get_by_uuid" | "VTPM_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VTPM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VTPM.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VTPM.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VTPM.create" | "VTPM_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let vM = ref_VM_of_rpc (my_assoc "VM" __structure) in
            let backend = ref_VM_of_rpc (my_assoc "backend" __structure) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VTPM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VTPM.create ~__context:(Context.check_for_foreign_database ~__context)  ~vM ~backend))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VTPM.create ~__context:(Context.check_for_foreign_database ~__context)  ~vM ~backend) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VTPM.destroy" | "VTPM_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VTPM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VTPM.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VTPM.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VTPM.get_uuid" | "VTPM_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VTPM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VTPM.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VTPM.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VTPM.get_VM" | "VTPM_get_VM" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VTPM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VTPM.get_VM ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VTPM.get_VM";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VTPM.get_backend" | "VTPM_get_backend" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VTPM_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VTPM.get_backend ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VTPM.get_backend";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "console.get_record" | "console_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_console_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_console_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "console.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "console.get_by_uuid" | "console_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_console x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "console.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "console.create" | "console_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let other_config = string_to_string_map_of_rpc (my_assoc "other_config" __structure) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_console x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Console.create ~__context:(Context.check_for_foreign_database ~__context)  ~other_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Console.create ~__context:(Context.check_for_foreign_database ~__context)  ~other_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "console.destroy" | "console_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_console_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Console.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Console.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "console.get_uuid" | "console_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_console_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "console.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "console.get_protocol" | "console_get_protocol" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_console_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_console_protocol x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.get_protocol ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "console.get_protocol";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "console.get_location" | "console_get_location" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_console_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.get_location ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "console.get_location";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "console.get_VM" | "console_get_VM" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_console_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.get_VM ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "console.get_VM";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "console.get_other_config" | "console_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_console_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "console.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "console.set_other_config" | "console_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_console_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "console.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "console.add_to_other_config" | "console_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_console_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "console.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "console.remove_from_other_config" | "console_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_console_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "console.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "console.get_all" | "console_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_console_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "console.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "console.get_all_records_where" | "console_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_console_to_console_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "console.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "console.get_all_records" | "console_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_console_to_console_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Console.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "console.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "user.get_record" | "user_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_user_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_user_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.User.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "user.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "user.get_by_uuid" | "user_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_user x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.User.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "user.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "user.create" | "user_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let short_name = string_of_rpc (my_assoc "short_name" __structure) in
            let fullname = string_of_rpc (my_assoc "fullname" __structure) in
            let other_config = string_to_string_map_of_rpc ((List.assoc_opt "other_config" __structure) |> Option.value ~default:(Rpc.Dict [])) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_user x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.User.create ~__context:(Context.check_for_foreign_database ~__context)  ~short_name ~fullname ~other_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.User.create ~__context:(Context.check_for_foreign_database ~__context)  ~short_name ~fullname ~other_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "user.destroy" | "user_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_user_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.User.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.User.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "user.get_uuid" | "user_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_user_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.User.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "user.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "user.get_short_name" | "user_get_short_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_user_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.User.get_short_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "user.get_short_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "user.get_fullname" | "user_get_fullname" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_user_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.User.get_fullname ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "user.get_fullname";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "user.get_other_config" | "user_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_user_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.User.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "user.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "user.set_fullname" | "user_set_fullname" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_user_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.User.set_fullname ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "user.set_fullname";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "user.set_other_config" | "user_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_user_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.User.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "user.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "user.add_to_other_config" | "user_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_user_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.User.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "user.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "user.remove_from_other_config" | "user_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_user_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.User.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "user.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_record" | "blob_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_blob_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_by_uuid" | "blob_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_blob x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_by_name_label" | "blob_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_blob_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_uuid" | "blob_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_name_label" | "blob_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_name_description" | "blob_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_size" | "blob_get_size" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_size ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_size";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_public" | "blob_get_public" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_public ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_public";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_last_updated" | "blob_get_last_updated" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_last_updated ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_last_updated";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_mime_type" | "blob_get_mime_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_mime_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_mime_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.set_name_label" | "blob_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "blob.set_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "blob.set_name_description" | "blob_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "blob.set_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "blob.set_public" | "blob_set_public" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.set_public ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "blob.set_public";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "blob.create" | "blob_create" -> 
        begin match __params with
        | session_id_rpc :: mime_type_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let public_rpc = try List.nth default_args 0 with _ -> Rpc.Bool false in
            let session_id = ref_session_of_rpc session_id_rpc in
            let mime_type = string_of_rpc mime_type_rpc in
            let public = bool_of_rpc public_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("mime_type", mime_type_rpc); ("public", public_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_blob x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Blob.create ~__context:(Context.check_for_foreign_database ~__context)  ~mime_type ~public))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Blob.create ~__context:(Context.check_for_foreign_database ~__context)  ~mime_type ~public) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.destroy" | "blob_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_blob_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Blob.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Blob.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_all" | "blob_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_blob_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_all_records_where" | "blob_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_blob_to_blob_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "blob.get_all_records" | "blob_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_blob_to_blob_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Blob.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "blob.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "message.create" | "message_create" -> 
        begin match __params with
        | [session_id_rpc; name_rpc; priority_rpc; cls_rpc; obj_uuid_rpc; body_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let name = string_of_rpc name_rpc in
            let priority = int64_of_rpc priority_rpc in
            let cls = cls_of_rpc cls_rpc in
            let obj_uuid = string_of_rpc obj_uuid_rpc in
            let body = string_of_rpc body_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("name", name_rpc); ("priority", priority_rpc); ("cls", cls_rpc); ("obj_uuid", obj_uuid_rpc); ("body", body_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_message x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Message.create ~__context:(Context.check_for_foreign_database ~__context)  ~name ~priority ~cls ~obj_uuid ~body))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Message.create ~__context:(Context.check_for_foreign_database ~__context)  ~name ~priority ~cls ~obj_uuid ~body) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "5" (string_of_int ((List.length __params) - 1))
        end
    | "message.destroy" | "message_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_message_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Message.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Message.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "message.get" | "message_get" -> 
        begin match __params with
        | [session_id_rpc; cls_rpc; obj_uuid_rpc; since_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let cls = cls_of_rpc cls_rpc in
            let obj_uuid = string_of_rpc obj_uuid_rpc in
            let since = datetime_of_rpc since_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("cls", cls_rpc); ("obj_uuid", obj_uuid_rpc); ("since", since_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_message_to_message_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Message.get ~__context:(Context.check_for_foreign_database ~__context)  ~cls ~obj_uuid ~since))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Message.get ~__context:(Context.check_for_foreign_database ~__context)  ~cls ~obj_uuid ~since) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "message.get_all" | "message_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_message_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Message.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Message.get_all ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "message.get_since" | "message_get_since" -> 
        begin match __params with
        | [session_id_rpc; since_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let since = datetime_of_rpc since_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("since", since_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_message_to_message_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Message.get_since ~__context:(Context.check_for_foreign_database ~__context)  ~since))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Message.get_since ~__context:(Context.check_for_foreign_database ~__context)  ~since) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "message.get_record" | "message_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_message_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_message_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Message.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Message.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "message.get_by_uuid" | "message_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_message x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Message.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Message.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "message.get_all_records" | "message_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_message_to_message_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Message.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Message.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "message.get_all_records_where" | "message_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_message_to_message_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Message.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Message.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "secret.get_record" | "secret_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_secret_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_secret_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "secret.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "secret.get_by_uuid" | "secret_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_secret x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "secret.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "secret.create" | "secret_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let value = string_of_rpc (my_assoc "value" __structure) in
            let other_config = string_to_string_map_of_rpc ((List.assoc_opt "other_config" __structure) |> Option.value ~default:(Rpc.Dict [])) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_secret x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Secret.create ~__context:(Context.check_for_foreign_database ~__context)  ~value ~other_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Secret.create ~__context:(Context.check_for_foreign_database ~__context)  ~value ~other_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "secret.destroy" | "secret_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_secret_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Secret.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Secret.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "secret.get_uuid" | "secret_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_secret_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "secret.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "secret.get_value" | "secret_get_value" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_secret_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.get_value ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "secret.get_value";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "secret.get_other_config" | "secret_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_secret_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "secret.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "secret.set_value" | "secret_set_value" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_secret_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.set_value ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "secret.set_value";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "secret.set_other_config" | "secret_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_secret_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "secret.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "secret.add_to_other_config" | "secret_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_secret_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "secret.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "secret.remove_from_other_config" | "secret_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_secret_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "secret.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "secret.introduce" | "secret_introduce" -> 
        begin match __params with
        | session_id_rpc :: uuid_rpc :: value_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has no asynchronous mode *)
            let other_config_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            let value = string_of_rpc value_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc); ("value", value_rpc); ("other_config", other_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_secret x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Secret.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~value ~other_config))) in
            let supports_async = false in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Secret.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~uuid ~value ~other_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "secret.get_all" | "secret_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_secret_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "secret.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "secret.get_all_records_where" | "secret_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_secret_to_secret_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "secret.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "secret.get_all_records" | "secret_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_secret_to_secret_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Secret.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "secret.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.get_record" | "tunnel_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_tunnel_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "tunnel.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.get_by_uuid" | "tunnel_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_tunnel x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "tunnel.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.get_uuid" | "tunnel_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "tunnel.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.get_access_PIF" | "tunnel_get_access_PIF" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.get_access_PIF ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "tunnel.get_access_PIF";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.get_transport_PIF" | "tunnel_get_transport_PIF" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.get_transport_PIF ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "tunnel.get_transport_PIF";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.get_status" | "tunnel_get_status" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.get_status ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "tunnel.get_status";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.get_other_config" | "tunnel_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "tunnel.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.get_protocol" | "tunnel_get_protocol" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_tunnel_protocol x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.get_protocol ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "tunnel.get_protocol";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.set_status" | "tunnel_set_status" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.set_status ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "tunnel.set_status";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.add_to_status" | "tunnel_add_to_status" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.add_to_status ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "tunnel.add_to_status";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.remove_from_status" | "tunnel_remove_from_status" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.remove_from_status ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "tunnel.remove_from_status";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.set_other_config" | "tunnel_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "tunnel.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.add_to_other_config" | "tunnel_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "tunnel.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.remove_from_other_config" | "tunnel_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "tunnel.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.set_protocol" | "tunnel_set_protocol" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            let value = tunnel_protocol_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.set_protocol ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "tunnel.set_protocol";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.create" | "tunnel_create" -> 
        begin match __params with
        | session_id_rpc :: transport_PIF_rpc :: network_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let protocol_rpc = try List.nth default_args 0 with _ -> Rpc.String "gre" in
            let session_id = ref_session_of_rpc session_id_rpc in
            let transport_PIF = ref_PIF_of_rpc transport_PIF_rpc in
            let network = ref_network_of_rpc network_rpc in
            let protocol = tunnel_protocol_of_rpc protocol_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("transport_PIF", transport_PIF_rpc); ("network", network_rpc); ("protocol", protocol_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_tunnel x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Tunnel.create ~__context:(Context.check_for_foreign_database ~__context)  ~transport_PIF ~network ~protocol))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Tunnel.create ~__context:(Context.check_for_foreign_database ~__context)  ~transport_PIF ~network ~protocol) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.destroy" | "tunnel_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_tunnel_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Tunnel.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Tunnel.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.get_all" | "tunnel_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_tunnel_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "tunnel.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.get_all_records_where" | "tunnel_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_tunnel_to_tunnel_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "tunnel.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "tunnel.get_all_records" | "tunnel_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_tunnel_to_tunnel_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Tunnel.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "tunnel.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.get_record" | "network_sriov_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_sriov_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_network_sriov_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network_sriov.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network_sriov.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.get_by_uuid" | "network_sriov_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network_sriov x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network_sriov.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network_sriov.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.get_uuid" | "network_sriov_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_sriov_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network_sriov.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network_sriov.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.get_physical_PIF" | "network_sriov_get_physical_PIF" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_sriov_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network_sriov.get_physical_PIF ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network_sriov.get_physical_PIF";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.get_logical_PIF" | "network_sriov_get_logical_PIF" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_sriov_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network_sriov.get_logical_PIF ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network_sriov.get_logical_PIF";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.get_requires_reboot" | "network_sriov_get_requires_reboot" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_sriov_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network_sriov.get_requires_reboot ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network_sriov.get_requires_reboot";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.get_configuration_mode" | "network_sriov_get_configuration_mode" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_sriov_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_sriov_configuration_mode x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network_sriov.get_configuration_mode ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network_sriov.get_configuration_mode";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.create" | "network_sriov_create" -> 
        begin match __params with
        | [session_id_rpc; pif_rpc; network_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let pif = ref_PIF_of_rpc pif_rpc in
            let network = ref_network_of_rpc network_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("pif", pif_rpc); ("network", network_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network_sriov x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network_sriov.create ~__context:(Context.check_for_foreign_database ~__context)  ~pif ~network))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network_sriov.create ~__context:(Context.check_for_foreign_database ~__context)  ~pif ~network) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.destroy" | "network_sriov_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_sriov_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network_sriov.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network_sriov.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.get_remaining_capacity" | "network_sriov_get_remaining_capacity" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_network_sriov_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Network_sriov.get_remaining_capacity ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Network_sriov.get_remaining_capacity ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.get_all" | "network_sriov_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network_sriov_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network_sriov.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network_sriov.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.get_all_records_where" | "network_sriov_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network_sriov_to_network_sriov_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network_sriov.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network_sriov.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "network_sriov.get_all_records" | "network_sriov_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network_sriov_to_network_sriov_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Network_sriov.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "network_sriov.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_record" | "PCI_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pCI_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_by_uuid" | "PCI_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PCI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_uuid" | "PCI_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_class_name" | "PCI_get_class_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_class_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_class_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_vendor_name" | "PCI_get_vendor_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_vendor_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_vendor_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_device_name" | "PCI_get_device_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_device_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_device_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_host" | "PCI_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_pci_id" | "PCI_get_pci_id" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_pci_id ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_pci_id";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_dependencies" | "PCI_get_dependencies" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PCI_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_dependencies ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_dependencies";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_other_config" | "PCI_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_subsystem_vendor_name" | "PCI_get_subsystem_vendor_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_subsystem_vendor_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_subsystem_vendor_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_subsystem_device_name" | "PCI_get_subsystem_device_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_subsystem_device_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_subsystem_device_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_driver_name" | "PCI_get_driver_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_driver_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_driver_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.set_other_config" | "PCI_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PCI.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.add_to_other_config" | "PCI_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PCI.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.remove_from_other_config" | "PCI_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PCI_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PCI.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_all" | "PCI_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PCI_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_all_records_where" | "PCI_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PCI_to_pCI_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PCI.get_all_records" | "PCI_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PCI_to_pCI_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PCI.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PCI.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_record" | "PGPU_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pGPU_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_by_uuid" | "PGPU_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PGPU x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_uuid" | "PGPU_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_PCI" | "PGPU_get_PCI" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PCI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_PCI ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_PCI";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_GPU_group" | "PGPU_get_GPU_group" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_GPU_group x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_GPU_group ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_GPU_group";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_host" | "PGPU_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_other_config" | "PGPU_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_supported_VGPU_types" | "PGPU_get_supported_VGPU_types" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_type_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_supported_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_supported_VGPU_types";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_enabled_VGPU_types" | "PGPU_get_enabled_VGPU_types" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_type_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_enabled_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_enabled_VGPU_types";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_resident_VGPUs" | "PGPU_get_resident_VGPUs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_resident_VGPUs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_resident_VGPUs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_supported_VGPU_max_capacities" | "PGPU_get_supported_VGPU_max_capacities" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_type_to_int64_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_supported_VGPU_max_capacities ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_supported_VGPU_max_capacities";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_dom0_access" | "PGPU_get_dom0_access" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pgpu_dom0_access x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_dom0_access ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_dom0_access";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_is_system_display_device" | "PGPU_get_is_system_display_device" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_is_system_display_device ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_is_system_display_device";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_compatibility_metadata" | "PGPU_get_compatibility_metadata" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_compatibility_metadata ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_compatibility_metadata";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.set_other_config" | "PGPU_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PGPU.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.add_to_other_config" | "PGPU_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PGPU.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.remove_from_other_config" | "PGPU_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PGPU.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.add_enabled_VGPU_types" | "PGPU_add_enabled_VGPU_types" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            let value = ref_VGPU_type_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PGPU.add_enabled_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PGPU.add_enabled_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.remove_enabled_VGPU_types" | "PGPU_remove_enabled_VGPU_types" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            let value = ref_VGPU_type_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PGPU.remove_enabled_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PGPU.remove_enabled_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.set_enabled_VGPU_types" | "PGPU_set_enabled_VGPU_types" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            let value = ref_VGPU_type_set_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PGPU.set_enabled_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PGPU.set_enabled_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.set_GPU_group" | "PGPU_set_GPU_group" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            let value = ref_GPU_group_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PGPU.set_GPU_group ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PGPU.set_GPU_group ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_remaining_capacity" | "PGPU_get_remaining_capacity" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; vgpu_type_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            let vgpu_type = ref_VGPU_type_of_rpc vgpu_type_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("vgpu_type", vgpu_type_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PGPU.get_remaining_capacity ~__context:(Context.check_for_foreign_database ~__context)  ~self ~vgpu_type))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PGPU.get_remaining_capacity ~__context:(Context.check_for_foreign_database ~__context)  ~self ~vgpu_type) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.enable_dom0_access" | "PGPU_enable_dom0_access" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pgpu_dom0_access x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PGPU.enable_dom0_access ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PGPU.enable_dom0_access ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.disable_dom0_access" | "PGPU_disable_dom0_access" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pgpu_dom0_access x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PGPU.disable_dom0_access ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PGPU.disable_dom0_access ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_all" | "PGPU_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PGPU_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_all_records_where" | "PGPU_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PGPU_to_pGPU_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PGPU.get_all_records" | "PGPU_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PGPU_to_pGPU_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PGPU.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PGPU.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_record" | "GPU_group_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_gPU_group_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_by_uuid" | "GPU_group_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_GPU_group x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_by_name_label" | "GPU_group_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_GPU_group_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_uuid" | "GPU_group_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_name_label" | "GPU_group_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_name_description" | "GPU_group_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_PGPUs" | "GPU_group_get_PGPUs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PGPU_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_PGPUs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_PGPUs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_VGPUs" | "GPU_group_get_VGPUs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_VGPUs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_VGPUs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_GPU_types" | "GPU_group_get_GPU_types" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_GPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_GPU_types";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_other_config" | "GPU_group_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_allocation_algorithm" | "GPU_group_get_allocation_algorithm" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_allocation_algorithm x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_allocation_algorithm ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_allocation_algorithm";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_supported_VGPU_types" | "GPU_group_get_supported_VGPU_types" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_type_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_supported_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_supported_VGPU_types";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_enabled_VGPU_types" | "GPU_group_get_enabled_VGPU_types" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_type_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_enabled_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_enabled_VGPU_types";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.set_name_label" | "GPU_group_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "GPU_group.set_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.set_name_description" | "GPU_group_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "GPU_group.set_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.set_other_config" | "GPU_group_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "GPU_group.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.add_to_other_config" | "GPU_group_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "GPU_group.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.remove_from_other_config" | "GPU_group_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "GPU_group.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.set_allocation_algorithm" | "GPU_group_set_allocation_algorithm" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            let value = allocation_algorithm_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.set_allocation_algorithm ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "GPU_group.set_allocation_algorithm";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.create" | "GPU_group_create" -> 
        begin match __params with
        | session_id_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let name_label_rpc = try List.nth default_args 0 with _ -> Rpc.String "" in
            let name_description_rpc = try List.nth default_args 1 with _ -> Rpc.String "" in
            let other_config_rpc = try List.nth default_args 2 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let name_label = string_of_rpc name_label_rpc in
            let name_description = string_of_rpc name_description_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("name_label", name_label_rpc); ("name_description", name_description_rpc); ("other_config", other_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_GPU_group x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.GPU_group.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~other_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.GPU_group.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~other_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.destroy" | "GPU_group_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.GPU_group.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.GPU_group.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.update_enabled_VGPU_types" | "GPU_group_update_enabled_VGPU_types" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.GPU_group.update_enabled_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.GPU_group.update_enabled_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.update_supported_VGPU_types" | "GPU_group_update_supported_VGPU_types" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.GPU_group.update_supported_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.GPU_group.update_supported_VGPU_types ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_remaining_capacity" | "GPU_group_get_remaining_capacity" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; vgpu_type_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_GPU_group_of_rpc self_rpc in
            let vgpu_type = ref_VGPU_type_of_rpc vgpu_type_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("vgpu_type", vgpu_type_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.GPU_group.get_remaining_capacity ~__context:(Context.check_for_foreign_database ~__context)  ~self ~vgpu_type))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.GPU_group.get_remaining_capacity ~__context:(Context.check_for_foreign_database ~__context)  ~self ~vgpu_type) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_all" | "GPU_group_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_GPU_group_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_all_records_where" | "GPU_group_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_GPU_group_to_gPU_group_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "GPU_group.get_all_records" | "GPU_group_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_GPU_group_to_gPU_group_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.GPU_group.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "GPU_group.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_record" | "VGPU_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vGPU_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_by_uuid" | "VGPU_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_uuid" | "VGPU_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_VM" | "VGPU_get_VM" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_VM ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_VM";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_GPU_group" | "VGPU_get_GPU_group" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_GPU_group x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_GPU_group ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_GPU_group";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_device" | "VGPU_get_device" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_device ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_device";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_currently_attached" | "VGPU_get_currently_attached" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_currently_attached ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_currently_attached";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_other_config" | "VGPU_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_type" | "VGPU_get_type" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_type x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_type ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_type";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_resident_on" | "VGPU_get_resident_on" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PGPU x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_resident_on ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_resident_on";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_scheduled_to_be_resident_on" | "VGPU_get_scheduled_to_be_resident_on" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PGPU x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_scheduled_to_be_resident_on ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_scheduled_to_be_resident_on";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_compatibility_metadata" | "VGPU_get_compatibility_metadata" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_compatibility_metadata ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_compatibility_metadata";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_extra_args" | "VGPU_get_extra_args" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_extra_args ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_extra_args";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_PCI" | "VGPU_get_PCI" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PCI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_PCI ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_PCI";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.set_other_config" | "VGPU_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VGPU.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.add_to_other_config" | "VGPU_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VGPU.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.remove_from_other_config" | "VGPU_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VGPU.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.set_extra_args" | "VGPU_set_extra_args" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.set_extra_args ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VGPU.set_extra_args";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.create" | "VGPU_create" -> 
        begin match __params with
        | session_id_rpc :: vM_rpc :: gPU_group_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let device_rpc = try List.nth default_args 0 with _ -> Rpc.String "0" in
            let other_config_rpc = try List.nth default_args 1 with _ -> Rpc.Dict [] in
            let _type_rpc = try List.nth default_args 2 with _ -> Rpc.String "OpaqueRef:NULL" in
            let session_id = ref_session_of_rpc session_id_rpc in
            let vM = ref_VM_of_rpc vM_rpc in
            let gPU_group = ref_GPU_group_of_rpc gPU_group_rpc in
            let device = string_of_rpc device_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            let _type = ref_VGPU_type_of_rpc _type_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vM", vM_rpc); ("gPU_group", gPU_group_rpc); ("device", device_rpc); ("other_config", other_config_rpc); ("type", _type_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VGPU.create ~__context:(Context.check_for_foreign_database ~__context)  ~vM ~gPU_group ~device ~other_config ~_type))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VGPU.create ~__context:(Context.check_for_foreign_database ~__context)  ~vM ~gPU_group ~device ~other_config ~_type) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.destroy" | "VGPU_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VGPU.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VGPU.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.atomic_set_resident_on" | "VGPU_atomic_set_resident_on" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_of_rpc self_rpc in
            let value = ref_PGPU_of_rpc value_rpc in
            Session_check.check true session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VGPU.atomic_set_resident_on ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VGPU.atomic_set_resident_on ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_all" | "VGPU_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_all_records_where" | "VGPU_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_to_vGPU_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU.get_all_records" | "VGPU_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_to_vGPU_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_record" | "VGPU_type_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vGPU_type_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_by_uuid" | "VGPU_type_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_type x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_uuid" | "VGPU_type_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_vendor_name" | "VGPU_type_get_vendor_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_vendor_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_vendor_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_model_name" | "VGPU_type_get_model_name" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_model_name ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_model_name";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_framebuffer_size" | "VGPU_type_get_framebuffer_size" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_framebuffer_size ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_framebuffer_size";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_max_heads" | "VGPU_type_get_max_heads" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_max_heads ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_max_heads";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_max_resolution_x" | "VGPU_type_get_max_resolution_x" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_max_resolution_x ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_max_resolution_x";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_max_resolution_y" | "VGPU_type_get_max_resolution_y" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_max_resolution_y ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_max_resolution_y";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_supported_on_PGPUs" | "VGPU_type_get_supported_on_PGPUs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PGPU_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_supported_on_PGPUs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_supported_on_PGPUs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_enabled_on_PGPUs" | "VGPU_type_get_enabled_on_PGPUs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PGPU_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_enabled_on_PGPUs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_enabled_on_PGPUs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_VGPUs" | "VGPU_type_get_VGPUs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_VGPUs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_VGPUs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_supported_on_GPU_groups" | "VGPU_type_get_supported_on_GPU_groups" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_GPU_group_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_supported_on_GPU_groups ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_supported_on_GPU_groups";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_enabled_on_GPU_groups" | "VGPU_type_get_enabled_on_GPU_groups" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_GPU_group_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_enabled_on_GPU_groups ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_enabled_on_GPU_groups";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_implementation" | "VGPU_type_get_implementation" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vgpu_type_implementation x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_implementation ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_implementation";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_identifier" | "VGPU_type_get_identifier" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_identifier ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_identifier";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_experimental" | "VGPU_type_get_experimental" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_experimental ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_experimental";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_compatible_types_in_vm" | "VGPU_type_get_compatible_types_in_vm" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VGPU_type_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_type_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_compatible_types_in_vm ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_compatible_types_in_vm";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_all" | "VGPU_type_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_type_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_all_records_where" | "VGPU_type_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_type_to_vGPU_type_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VGPU_type.get_all_records" | "VGPU_type_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VGPU_type_to_vGPU_type_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VGPU_type.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VGPU_type.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_record" | "PVS_site_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pVS_site_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_by_uuid" | "PVS_site_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_site x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_by_name_label" | "PVS_site_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_site_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_uuid" | "PVS_site_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_name_label" | "PVS_site_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_name_description" | "PVS_site_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_PVS_uuid" | "PVS_site_get_PVS_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_PVS_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_PVS_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_cache_storage" | "PVS_site_get_cache_storage" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_cache_storage_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_cache_storage ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_cache_storage";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_servers" | "PVS_site_get_servers" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_server_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_servers ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_servers";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_proxies" | "PVS_site_get_proxies" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_proxy_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_proxies ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_proxies";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.set_name_label" | "PVS_site_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PVS_site.set_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.set_name_description" | "PVS_site_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PVS_site.set_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.introduce" | "PVS_site_introduce" -> 
        begin match __params with
        | [session_id_rpc; name_label_rpc; name_description_rpc; pVS_uuid_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let name_label = string_of_rpc name_label_rpc in
            let name_description = string_of_rpc name_description_rpc in
            let pVS_uuid = string_of_rpc pVS_uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("name_label", name_label_rpc); ("name_description", name_description_rpc); ("pVS_uuid", pVS_uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_site x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PVS_site.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~pVS_uuid))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PVS_site.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~pVS_uuid) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.forget" | "PVS_site_forget" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PVS_site.forget ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PVS_site.forget ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.set_PVS_uuid" | "PVS_site_set_PVS_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_site_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PVS_site.set_PVS_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PVS_site.set_PVS_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_all" | "PVS_site_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_site_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_all_records_where" | "PVS_site_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_site_to_pVS_site_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_site.get_all_records" | "PVS_site_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_site_to_pVS_site_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_site.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_site.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.get_record" | "PVS_server_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_server_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pVS_server_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_server.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_server.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.get_by_uuid" | "PVS_server_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_server x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_server.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_server.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.get_uuid" | "PVS_server_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_server_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_server.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_server.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.get_addresses" | "PVS_server_get_addresses" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_server_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_server.get_addresses ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_server.get_addresses";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.get_first_port" | "PVS_server_get_first_port" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_server_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_server.get_first_port ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_server.get_first_port";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.get_last_port" | "PVS_server_get_last_port" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_server_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_server.get_last_port ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_server.get_last_port";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.get_site" | "PVS_server_get_site" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_server_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_site x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_server.get_site ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_server.get_site";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.introduce" | "PVS_server_introduce" -> 
        begin match __params with
        | [session_id_rpc; addresses_rpc; first_port_rpc; last_port_rpc; site_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let addresses = string_set_of_rpc addresses_rpc in
            let first_port = int64_of_rpc first_port_rpc in
            let last_port = int64_of_rpc last_port_rpc in
            let site = ref_PVS_site_of_rpc site_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("addresses", addresses_rpc); ("first_port", first_port_rpc); ("last_port", last_port_rpc); ("site", site_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_server x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PVS_server.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~addresses ~first_port ~last_port ~site))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PVS_server.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~addresses ~first_port ~last_port ~site) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "4" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.forget" | "PVS_server_forget" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_server_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PVS_server.forget ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PVS_server.forget ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.get_all" | "PVS_server_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_server_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_server.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_server.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.get_all_records_where" | "PVS_server_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_server_to_pVS_server_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_server.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_server.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_server.get_all_records" | "PVS_server_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_server_to_pVS_server_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_server.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_server.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.get_record" | "PVS_proxy_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_proxy_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pVS_proxy_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_proxy.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_proxy.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.get_by_uuid" | "PVS_proxy_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_proxy x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_proxy.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_proxy.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.get_uuid" | "PVS_proxy_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_proxy_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_proxy.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_proxy.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.get_site" | "PVS_proxy_get_site" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_proxy_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_site x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_proxy.get_site ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_proxy.get_site";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.get_VIF" | "PVS_proxy_get_VIF" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_proxy_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_proxy.get_VIF ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_proxy.get_VIF";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.get_currently_attached" | "PVS_proxy_get_currently_attached" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_proxy_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_proxy.get_currently_attached ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_proxy.get_currently_attached";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.get_status" | "PVS_proxy_get_status" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_proxy_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pvs_proxy_status x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_proxy.get_status ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_proxy.get_status";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.create" | "PVS_proxy_create" -> 
        begin match __params with
        | [session_id_rpc; site_rpc; vIF_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let site = ref_PVS_site_of_rpc site_rpc in
            let vIF = ref_VIF_of_rpc vIF_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("site", site_rpc); ("vIF", vIF_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_proxy x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PVS_proxy.create ~__context:(Context.check_for_foreign_database ~__context)  ~site ~vIF))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PVS_proxy.create ~__context:(Context.check_for_foreign_database ~__context)  ~site ~vIF) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.destroy" | "PVS_proxy_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_proxy_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PVS_proxy.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PVS_proxy.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.get_all" | "PVS_proxy_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_proxy_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_proxy.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_proxy.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.get_all_records_where" | "PVS_proxy_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_proxy_to_pVS_proxy_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_proxy.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_proxy.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_proxy.get_all_records" | "PVS_proxy_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_proxy_to_pVS_proxy_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_proxy.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_proxy.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.get_record" | "PVS_cache_storage_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_cache_storage_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pVS_cache_storage_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_cache_storage.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_cache_storage.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.get_by_uuid" | "PVS_cache_storage_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_cache_storage x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_cache_storage.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_cache_storage.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.create" | "PVS_cache_storage_create" -> 
        begin match __params with
        | [session_id_rpc; __structure_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let __structure = match __structure_rpc with Dict d -> d | _ -> failwith "bad __structure" in
            let host = ref_host_of_rpc ((List.assoc_opt "host" __structure) |> Option.value ~default:(Rpc.String "OpaqueRef:NULL")) in
            let sR = ref_SR_of_rpc ((List.assoc_opt "SR" __structure) |> Option.value ~default:(Rpc.String "OpaqueRef:NULL")) in
            let site = ref_PVS_site_of_rpc ((List.assoc_opt "site" __structure) |> Option.value ~default:(Rpc.String "OpaqueRef:NULL")) in
            let size = int64_of_rpc ((List.assoc_opt "size" __structure) |> Option.value ~default:(Rpc.Int (21474836480L))) in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("__structure", __structure_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_cache_storage x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PVS_cache_storage.create ~__context:(Context.check_for_foreign_database ~__context)  ~host ~sR ~site ~size))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PVS_cache_storage.create ~__context:(Context.check_for_foreign_database ~__context)  ~host ~sR ~site ~size) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.destroy" | "PVS_cache_storage_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_cache_storage_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PVS_cache_storage.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PVS_cache_storage.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.get_uuid" | "PVS_cache_storage_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_cache_storage_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_cache_storage.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_cache_storage.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.get_host" | "PVS_cache_storage_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_cache_storage_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_cache_storage.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_cache_storage.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.get_SR" | "PVS_cache_storage_get_SR" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_cache_storage_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SR x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_cache_storage.get_SR ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_cache_storage.get_SR";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.get_site" | "PVS_cache_storage_get_site" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_cache_storage_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_site x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_cache_storage.get_site ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_cache_storage.get_site";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.get_size" | "PVS_cache_storage_get_size" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_cache_storage_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_cache_storage.get_size ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_cache_storage.get_size";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.get_VDI" | "PVS_cache_storage_get_VDI" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PVS_cache_storage_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VDI x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_cache_storage.get_VDI ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_cache_storage.get_VDI";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.get_all" | "PVS_cache_storage_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_cache_storage_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_cache_storage.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_cache_storage.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.get_all_records_where" | "PVS_cache_storage_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_cache_storage_to_pVS_cache_storage_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_cache_storage.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_cache_storage.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PVS_cache_storage.get_all_records" | "PVS_cache_storage_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PVS_cache_storage_to_pVS_cache_storage_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PVS_cache_storage.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PVS_cache_storage.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_record" | "Feature_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Feature_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_feature_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_by_uuid" | "Feature_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Feature x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_by_name_label" | "Feature_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Feature_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_uuid" | "Feature_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Feature_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_name_label" | "Feature_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Feature_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_name_description" | "Feature_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Feature_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_enabled" | "Feature_get_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Feature_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_experimental" | "Feature_get_experimental" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Feature_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_experimental ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_experimental";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_version" | "Feature_get_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Feature_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_host" | "Feature_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Feature_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_all" | "Feature_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Feature_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_all_records_where" | "Feature_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Feature_to_feature_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Feature.get_all_records" | "Feature_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Feature_to_feature_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Feature.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Feature.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "SDN_controller.get_record" | "SDN_controller_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SDN_controller_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_sDN_controller_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SDN_controller.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SDN_controller.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SDN_controller.get_by_uuid" | "SDN_controller_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SDN_controller x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SDN_controller.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SDN_controller.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SDN_controller.get_uuid" | "SDN_controller_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SDN_controller_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SDN_controller.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SDN_controller.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SDN_controller.get_protocol" | "SDN_controller_get_protocol" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SDN_controller_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_sdn_controller_protocol x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SDN_controller.get_protocol ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SDN_controller.get_protocol";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SDN_controller.get_address" | "SDN_controller_get_address" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SDN_controller_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SDN_controller.get_address ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SDN_controller.get_address";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SDN_controller.get_port" | "SDN_controller_get_port" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SDN_controller_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_int64 x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SDN_controller.get_port ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SDN_controller.get_port";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SDN_controller.introduce" | "SDN_controller_introduce" -> 
        begin match __params with
        | session_id_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let protocol_rpc = try List.nth default_args 0 with _ -> Rpc.String "ssl" in
            let address_rpc = try List.nth default_args 1 with _ -> Rpc.String "" in
            let port_rpc = try List.nth default_args 2 with _ -> Rpc.Int (0L) in
            let session_id = ref_session_of_rpc session_id_rpc in
            let protocol = sdn_controller_protocol_of_rpc protocol_rpc in
            let address = string_of_rpc address_rpc in
            let port = int64_of_rpc port_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("protocol", protocol_rpc); ("address", address_rpc); ("port", port_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SDN_controller x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SDN_controller.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~protocol ~address ~port))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SDN_controller.introduce ~__context:(Context.check_for_foreign_database ~__context)  ~protocol ~address ~port) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "SDN_controller.forget" | "SDN_controller_forget" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_SDN_controller_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.SDN_controller.forget ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.SDN_controller.forget ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SDN_controller.get_all" | "SDN_controller_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SDN_controller_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SDN_controller.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SDN_controller.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "SDN_controller.get_all_records_where" | "SDN_controller_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SDN_controller_to_sDN_controller_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SDN_controller.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SDN_controller.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "SDN_controller.get_all_records" | "SDN_controller_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_SDN_controller_to_sDN_controller_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.SDN_controller.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "SDN_controller.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_record" | "PUSB_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_pUSB_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_by_uuid" | "PUSB_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PUSB x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_uuid" | "PUSB_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_USB_group" | "PUSB_get_USB_group" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_USB_group x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_USB_group ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_USB_group";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_host" | "PUSB_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_path" | "PUSB_get_path" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_path ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_path";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_vendor_id" | "PUSB_get_vendor_id" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_vendor_id ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_vendor_id";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_vendor_desc" | "PUSB_get_vendor_desc" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_vendor_desc ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_vendor_desc";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_product_id" | "PUSB_get_product_id" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_product_id ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_product_id";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_product_desc" | "PUSB_get_product_desc" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_product_desc ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_product_desc";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_serial" | "PUSB_get_serial" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_serial ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_serial";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_version" | "PUSB_get_version" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_version ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_version";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_description" | "PUSB_get_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_passthrough_enabled" | "PUSB_get_passthrough_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_passthrough_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_passthrough_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_other_config" | "PUSB_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_speed" | "PUSB_get_speed" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_float x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_speed ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_speed";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.set_other_config" | "PUSB_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PUSB.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.add_to_other_config" | "PUSB_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PUSB.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.remove_from_other_config" | "PUSB_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "PUSB.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.scan" | "PUSB_scan" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PUSB.scan ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PUSB.scan ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.set_passthrough_enabled" | "PUSB_set_passthrough_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_PUSB_of_rpc self_rpc in
            let value = bool_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.PUSB.set_passthrough_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.PUSB.set_passthrough_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_all" | "PUSB_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PUSB_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_all_records_where" | "PUSB_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PUSB_to_pUSB_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "PUSB.get_all_records" | "PUSB_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PUSB_to_pUSB_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.PUSB.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "PUSB.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_record" | "USB_group_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_uSB_group_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_by_uuid" | "USB_group_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_USB_group x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_by_name_label" | "USB_group_get_by_name_label" -> 
        begin match __params with
        | [session_id_rpc; label_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let label = string_of_rpc label_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("label", label_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_USB_group_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_by_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~label))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_by_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_uuid" | "USB_group_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_name_label" | "USB_group_get_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_name_description" | "USB_group_get_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_PUSBs" | "USB_group_get_PUSBs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PUSB_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_PUSBs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_PUSBs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_VUSBs" | "USB_group_get_VUSBs" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VUSB_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_VUSBs ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_VUSBs";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_other_config" | "USB_group_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.set_name_label" | "USB_group_set_name_label" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.set_name_label ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "USB_group.set_name_label";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.set_name_description" | "USB_group_set_name_description" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.set_name_description ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "USB_group.set_name_description";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.set_other_config" | "USB_group_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "USB_group.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.add_to_other_config" | "USB_group_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "USB_group.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.remove_from_other_config" | "USB_group_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "USB_group.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.create" | "USB_group_create" -> 
        begin match __params with
        | session_id_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let name_label_rpc = try List.nth default_args 0 with _ -> Rpc.String "" in
            let name_description_rpc = try List.nth default_args 1 with _ -> Rpc.String "" in
            let other_config_rpc = try List.nth default_args 2 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let name_label = string_of_rpc name_label_rpc in
            let name_description = string_of_rpc name_description_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("name_label", name_label_rpc); ("name_description", name_description_rpc); ("other_config", other_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_USB_group x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.USB_group.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~other_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.USB_group.create ~__context:(Context.check_for_foreign_database ~__context)  ~name_label ~name_description ~other_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.destroy" | "USB_group_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_USB_group_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.USB_group.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.USB_group.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_all" | "USB_group_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_USB_group_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_all_records_where" | "USB_group_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_USB_group_to_uSB_group_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "USB_group.get_all_records" | "USB_group_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_USB_group_to_uSB_group_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.USB_group.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "USB_group.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_record" | "VUSB_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vUSB_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_by_uuid" | "VUSB_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VUSB x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_uuid" | "VUSB_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_allowed_operations" | "VUSB_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_vusb_operations_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_current_operations" | "VUSB_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_vusb_operations_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_VM" | "VUSB_get_VM" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VM x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_VM ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_VM";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_USB_group" | "VUSB_get_USB_group" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_USB_group x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_USB_group ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_USB_group";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_other_config" | "VUSB_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_currently_attached" | "VUSB_get_currently_attached" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_currently_attached ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_currently_attached";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.set_other_config" | "VUSB_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VUSB.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.add_to_other_config" | "VUSB_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VUSB.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.remove_from_other_config" | "VUSB_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "VUSB.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.create" | "VUSB_create" -> 
        begin match __params with
        | session_id_rpc :: vM_rpc :: uSB_group_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let other_config_rpc = try List.nth default_args 0 with _ -> Rpc.Dict [] in
            let session_id = ref_session_of_rpc session_id_rpc in
            let vM = ref_VM_of_rpc vM_rpc in
            let uSB_group = ref_USB_group_of_rpc uSB_group_rpc in
            let other_config = string_to_string_map_of_rpc other_config_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("vM", vM_rpc); ("uSB_group", uSB_group_rpc); ("other_config", other_config_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VUSB x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VUSB.create ~__context:(Context.check_for_foreign_database ~__context)  ~vM ~uSB_group ~other_config))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VUSB.create ~__context:(Context.check_for_foreign_database ~__context)  ~vM ~uSB_group ~other_config) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.unplug" | "VUSB_unplug" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VUSB.unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VUSB.unplug ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.destroy" | "VUSB_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_VUSB_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.VUSB.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.VUSB.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_all" | "VUSB_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VUSB_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_all_records_where" | "VUSB_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VUSB_to_vUSB_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "VUSB.get_all_records" | "VUSB_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_VUSB_to_vUSB_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.VUSB.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "VUSB.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_record" | "Cluster_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_cluster_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_by_uuid" | "Cluster_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_uuid" | "Cluster_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_cluster_hosts" | "Cluster_get_cluster_hosts" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster_host_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_cluster_hosts ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_cluster_hosts";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_pending_forget" | "Cluster_get_pending_forget" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_pending_forget ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_pending_forget";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_cluster_token" | "Cluster_get_cluster_token" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_cluster_token ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_cluster_token";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_cluster_stack" | "Cluster_get_cluster_stack" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_cluster_stack ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_cluster_stack";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_allowed_operations" | "Cluster_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_cluster_operation_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_current_operations" | "Cluster_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_cluster_operation_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_pool_auto_join" | "Cluster_get_pool_auto_join" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_pool_auto_join ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_pool_auto_join";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_token_timeout" | "Cluster_get_token_timeout" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_float x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_token_timeout ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_token_timeout";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_token_timeout_coefficient" | "Cluster_get_token_timeout_coefficient" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_float x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_token_timeout_coefficient ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_token_timeout_coefficient";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_cluster_config" | "Cluster_get_cluster_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_cluster_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_cluster_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_other_config" | "Cluster_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.set_other_config" | "Cluster_set_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            let value = string_to_string_map_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.set_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "Cluster.set_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.add_to_other_config" | "Cluster_add_to_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc; value_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            let value = string_of_rpc value_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc); ("value", value_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.add_to_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key ~value))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "Cluster.add_to_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.remove_from_other_config" | "Cluster_remove_from_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc; key_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            let key = string_of_rpc key_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc); ("key", key_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.remove_from_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self ~key))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogSideEffect.debug "Cluster.remove_from_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.create" | "Cluster_create" -> 
        begin match __params with
        | session_id_rpc :: pIF_rpc :: cluster_stack_rpc :: pool_auto_join_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let token_timeout_rpc = try List.nth default_args 0 with _ -> Rpc.Float (20.000000) in
            let token_timeout_coefficient_rpc = try List.nth default_args 1 with _ -> Rpc.Float (1.000000) in
            let session_id = ref_session_of_rpc session_id_rpc in
            let pIF = ref_PIF_of_rpc pIF_rpc in
            let cluster_stack = string_of_rpc cluster_stack_rpc in
            let pool_auto_join = bool_of_rpc pool_auto_join_rpc in
            let token_timeout = float_of_rpc token_timeout_rpc in
            let token_timeout_coefficient = float_of_rpc token_timeout_coefficient_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("pIF", pIF_rpc); ("cluster_stack", cluster_stack_rpc); ("pool_auto_join", pool_auto_join_rpc); ("token_timeout", token_timeout_rpc); ("token_timeout_coefficient", token_timeout_coefficient_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster.create ~__context:(Context.check_for_foreign_database ~__context)  ~pIF ~cluster_stack ~pool_auto_join ~token_timeout ~token_timeout_coefficient))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster.create ~__context:(Context.check_for_foreign_database ~__context)  ~pIF ~cluster_stack ~pool_auto_join ~token_timeout ~token_timeout_coefficient) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.destroy" | "Cluster_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_network" | "Cluster_get_network" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_network x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster.get_network ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster.get_network ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.pool_create" | "Cluster_pool_create" -> 
        begin match __params with
        | session_id_rpc :: network_rpc :: cluster_stack_rpc :: default_args -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let token_timeout_rpc = try List.nth default_args 0 with _ -> Rpc.Float (20.000000) in
            let token_timeout_coefficient_rpc = try List.nth default_args 1 with _ -> Rpc.Float (1.000000) in
            let session_id = ref_session_of_rpc session_id_rpc in
            let network = ref_network_of_rpc network_rpc in
            let cluster_stack = string_of_rpc cluster_stack_rpc in
            let token_timeout = float_of_rpc token_timeout_rpc in
            let token_timeout_coefficient = float_of_rpc token_timeout_coefficient_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("network", network_rpc); ("cluster_stack", cluster_stack_rpc); ("token_timeout", token_timeout_rpc); ("token_timeout_coefficient", token_timeout_coefficient_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster.pool_create ~__context:(Context.check_for_foreign_database ~__context)  ~network ~cluster_stack ~token_timeout ~token_timeout_coefficient))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster.pool_create ~__context:(Context.check_for_foreign_database ~__context)  ~network ~cluster_stack ~token_timeout ~token_timeout_coefficient) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.pool_force_destroy" | "Cluster_pool_force_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster.pool_force_destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster.pool_force_destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.pool_destroy" | "Cluster_pool_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster.pool_destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster.pool_destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.pool_resync" | "Cluster_pool_resync" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster.pool_resync ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster.pool_resync ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_all" | "Cluster_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_all_records_where" | "Cluster_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster_to_cluster_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster.get_all_records" | "Cluster_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster_to_cluster_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_record" | "Cluster_host_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_cluster_host_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_by_uuid" | "Cluster_host_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_uuid" | "Cluster_host_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_cluster" | "Cluster_host_get_cluster" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_cluster ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_cluster";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_host" | "Cluster_host_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_enabled" | "Cluster_host_get_enabled" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_enabled ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_enabled";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_PIF" | "Cluster_host_get_PIF" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_PIF x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_PIF ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_PIF";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_joined" | "Cluster_host_get_joined" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_bool x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_joined ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_joined";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_allowed_operations" | "Cluster_host_get_allowed_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_cluster_host_operation_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_allowed_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_allowed_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_current_operations" | "Cluster_host_get_current_operations" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_cluster_host_operation_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_current_operations ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_current_operations";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_other_config" | "Cluster_host_get_other_config" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_other_config ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_other_config";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.create" | "Cluster_host_create" -> 
        begin match __params with
        | [session_id_rpc; cluster_rpc; host_rpc; pif_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let cluster = ref_Cluster_of_rpc cluster_rpc in
            let host = ref_host_of_rpc host_rpc in
            let pif = ref_PIF_of_rpc pif_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("cluster", cluster_rpc); ("host", host_rpc); ("pif", pif_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster_host.create ~__context:(Context.check_for_foreign_database ~__context)  ~cluster ~host ~pif))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster_host.create ~__context:(Context.check_for_foreign_database ~__context)  ~cluster ~host ~pif) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "3" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.destroy" | "Cluster_host_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster_host.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster_host.destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.enable" | "Cluster_host_enable" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster_host.enable ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster_host.enable ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.force_destroy" | "Cluster_host_force_destroy" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster_host.force_destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster_host.force_destroy ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.forget" | "Cluster_host_forget" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster_host.forget ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster_host.forget ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.disable" | "Cluster_host_disable" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Cluster_host_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Cluster_host.disable ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Cluster_host.disable ~__context:(Context.check_for_foreign_database ~__context)  ~self) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_all" | "Cluster_host_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster_host_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_all_records_where" | "Cluster_host_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster_host_to_cluster_host_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Cluster_host.get_all_records" | "Cluster_host_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Cluster_host_to_cluster_host_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Cluster_host.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Cluster_host.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Certificate.get_record" | "Certificate_get_record" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Certificate_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_certificate_t x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Certificate.get_record ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Certificate.get_record";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Certificate.get_by_uuid" | "Certificate_get_by_uuid" -> 
        begin match __params with
        | [session_id_rpc; uuid_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let uuid = string_of_rpc uuid_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("uuid", uuid_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Certificate x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Certificate.get_by_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~uuid))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Certificate.get_by_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Certificate.get_uuid" | "Certificate_get_uuid" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Certificate_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Certificate.get_uuid ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Certificate.get_uuid";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Certificate.get_host" | "Certificate_get_host" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Certificate_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_host x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Certificate.get_host ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Certificate.get_host";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Certificate.get_not_before" | "Certificate_get_not_before" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Certificate_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Certificate.get_not_before ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Certificate.get_not_before";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Certificate.get_not_after" | "Certificate_get_not_after" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Certificate_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_datetime x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Certificate.get_not_after ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Certificate.get_not_after";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Certificate.get_fingerprint" | "Certificate_get_fingerprint" -> 
        begin match __params with
        | [session_id_rpc; self_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let self = ref_Certificate_of_rpc self_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("self", self_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Certificate.get_fingerprint ~__context:(Context.check_for_foreign_database ~__context)  ~self))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Certificate.get_fingerprint";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Certificate.get_all" | "Certificate_get_all" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Certificate_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Certificate.get_all ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Certificate.get_all";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Certificate.get_all_records_where" | "Certificate_get_all_records_where" -> 
        begin match __params with
        | [session_id_rpc; expr_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let expr = string_of_rpc expr_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("expr", expr_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Certificate_to_certificate_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Certificate.get_all_records_where ~__context:(Context.check_for_foreign_database ~__context)  ~expr))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Certificate.get_all_records_where";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Certificate.get_all_records" | "Certificate_get_all_records" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has no side-effect; should be handled by DB action *) 
            (* has no asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_ref_Certificate_to_certificate_t_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Db_actions.DB_Action.Certificate.get_all_records ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = false in
            let generate_task_for = true in
            ApiLogRead.debug "Certificate.get_all_records";
            let resp = Server_helpers.do_dispatch ~session_id  supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Diagnostics.gc_compact" | "Diagnostics_gc_compact" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun _ -> Rpc.String "") in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Diagnostics.gc_compact ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Diagnostics.gc_compact ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Diagnostics.gc_stats" | "Diagnostics_gc_stats" -> 
        begin match __params with
        | [session_id_rpc; host_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Diagnostics.gc_stats ~__context:(Context.check_for_foreign_database ~__context)  ~host))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Diagnostics.gc_stats ~__context:(Context.check_for_foreign_database ~__context)  ~host) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "1" (string_of_int ((List.length __params) - 1))
        end
    | "Diagnostics.db_stats" | "Diagnostics_db_stats" -> 
        begin match __params with
        | [session_id_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_to_string_map x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Diagnostics.db_stats ~__context:(Context.check_for_foreign_database ~__context) ))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Diagnostics.db_stats ~__context:(Context.check_for_foreign_database ~__context) ) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "0" (string_of_int ((List.length __params) - 1))
        end
    | "Diagnostics.network_stats" | "Diagnostics_network_stats" -> 
        begin match __params with
        | [session_id_rpc; host_rpc; params_rpc] -> 
            (* has side-effect (with locks and no automatic DB action) *)
            (* has asynchronous mode *)
            let session_id = ref_session_of_rpc session_id_rpc in
            let host = ref_host_of_rpc host_rpc in
            let params = string_to_string_map_of_rpc params_rpc in
            Session_check.check false session_id;
            let arg_names_values = [("session_id", session_id_rpc); ("host", host_rpc); ("params", params_rpc)] in
            let key_names = [] in
            let rbac __context fn = Rbac.check session_id __call ~args:arg_names_values ~keys:key_names ~__context ~fn in
            let marshaller = (fun x -> rpc_of_string_set_set x) in
            let local_op = fun ~__context ->(rbac __context (fun()->(Custom.Diagnostics.network_stats ~__context:(Context.check_for_foreign_database ~__context)  ~host ~params))) in
            let supports_async = true in
            let generate_task_for = true in
            let forward_op = fun ~local_fn ~__context -> (rbac __context (fun()-> (Forward.Diagnostics.network_stats ~__context:(Context.check_for_foreign_database ~__context)  ~host ~params) )) in
            let resp = Server_helpers.do_dispatch ~session_id ~forward_op supports_async __call local_op marshaller fd http_req __label __sync_ty generate_task_for in
            resp
        | _ ->
            Server_helpers.parameter_count_mismatch_failure __call "2" (string_of_int ((List.length __params) - 1))
        end
    | "system.listMethods" -> 
      success (rpc_of_string_set [
    "session.get_record";"session.get_by_uuid";"session.get_uuid";"session.get_this_host";"session.get_this_user";"session.get_last_active";"session.get_pool";"session.get_other_config";"session.get_is_local_superuser";"session.get_subject";"session.get_validation_time";"session.get_auth_user_sid";"session.get_auth_user_name";"session.get_rbac_permissions";"session.get_tasks";"session.get_parent";"session.get_originator";"session.set_other_config";"session.add_to_other_config";"session.remove_from_other_config";"session.login_with_password";"session.logout";"session.change_password";"session.slave_login";"session.slave_local_login";"session.slave_local_login_with_password";"session.create_from_db_file";"session.local_logout";"session.get_all_subject_identifiers";"session.logout_subject_identifier";
    "auth.get_subject_identifier";"auth.get_subject_information_from_identifier";"auth.get_group_membership";
    "subject.get_record";"subject.get_by_uuid";"subject.create";"subject.destroy";"subject.get_uuid";"subject.get_subject_identifier";"subject.get_other_config";"subject.get_roles";"subject.add_to_roles";"subject.remove_from_roles";"subject.get_permissions_name_label";"subject.get_all";"subject.get_all_records_where";"subject.get_all_records";
    "role.get_record";"role.get_by_uuid";"role.get_by_name_label";"role.get_uuid";"role.get_name_label";"role.get_name_description";"role.get_subroles";"role.get_permissions";"role.get_permissions_name_label";"role.get_by_permission";"role.get_by_permission_name_label";"role.get_all";"role.get_all_records_where";"role.get_all_records";
    "task.get_record";"task.get_by_uuid";"task.get_by_name_label";"task.get_uuid";"task.get_name_label";"task.get_name_description";"task.get_allowed_operations";"task.get_current_operations";"task.get_created";"task.get_finished";"task.get_status";"task.get_resident_on";"task.get_progress";"task.get_type";"task.get_result";"task.get_error_info";"task.get_other_config";"task.get_subtask_of";"task.get_subtasks";"task.get_backtrace";"task.set_other_config";"task.add_to_other_config";"task.remove_from_other_config";"task.create";"task.destroy";"task.cancel";"task.set_status";"task.set_progress";"task.get_all";"task.get_all_records_where";"task.get_all_records";
    "event.register";"event.unregister";"event.next";"event.from";"event.get_current_id";"event.inject";
    "pool.get_record";"pool.get_by_uuid";"pool.get_uuid";"pool.get_name_label";"pool.get_name_description";"pool.get_master";"pool.get_default_SR";"pool.get_suspend_image_SR";"pool.get_crash_dump_SR";"pool.get_other_config";"pool.get_ha_enabled";"pool.get_ha_configuration";"pool.get_ha_statefiles";"pool.get_ha_host_failures_to_tolerate";"pool.get_ha_plan_exists_for";"pool.get_ha_allow_overcommit";"pool.get_ha_overcommitted";"pool.get_blobs";"pool.get_tags";"pool.get_gui_config";"pool.get_health_check_config";"pool.get_wlb_url";"pool.get_wlb_username";"pool.get_wlb_enabled";"pool.get_wlb_verify_cert";"pool.get_redo_log_enabled";"pool.get_redo_log_vdi";"pool.get_vswitch_controller";"pool.get_restrictions";"pool.get_metadata_VDIs";"pool.get_ha_cluster_stack";"pool.get_allowed_operations";"pool.get_current_operations";"pool.get_guest_agent_config";"pool.get_cpu_info";"pool.get_policy_no_vendor_device";"pool.get_live_patching_disabled";"pool.get_igmp_snooping_enabled";"pool.get_uefi_certificates";"pool.get_is_psr_pending";"pool.set_name_label";"pool.set_name_description";"pool.set_default_SR";"pool.set_suspend_image_SR";"pool.set_crash_dump_SR";"pool.set_other_config";"pool.add_to_other_config";"pool.remove_from_other_config";"pool.set_ha_allow_overcommit";"pool.set_tags";"pool.add_tags";"pool.remove_tags";"pool.set_gui_config";"pool.add_to_gui_config";"pool.remove_from_gui_config";"pool.set_health_check_config";"pool.add_to_health_check_config";"pool.remove_from_health_check_config";"pool.set_wlb_enabled";"pool.set_wlb_verify_cert";"pool.set_policy_no_vendor_device";"pool.set_live_patching_disabled";"pool.set_uefi_certificates";"pool.set_is_psr_pending";"pool.join";"pool.join_force";"pool.eject";"pool.initial_auth";"pool.emergency_transition_to_master";"pool.emergency_reset_master";"pool.recover_slaves";"pool.hello";"pool.is_slave";"pool.create_VLAN";"pool.management_reconfigure";"pool.create_VLAN_from_PIF";"pool.slave_network_report";"pool.enable_ha";"pool.disable_ha";"pool.sync_database";"pool.designate_new_master";"pool.ha_prevent_restarts_for";"pool.ha_failover_plan_exists";"pool.ha_compute_max_host_failures_to_tolerate";"pool.ha_compute_hypothetical_max_host_failures_to_tolerate";"pool.ha_compute_vm_failover_plan";"pool.set_ha_host_failures_to_tolerate";"pool.create_new_blob";"pool.ha_schedule_plan_recomputation";"pool.enable_binary_storage";"pool.disable_binary_storage";"pool.enable_external_auth";"pool.disable_external_auth";"pool.detect_nonhomogeneous_external_auth";"pool.initialize_wlb";"pool.deconfigure_wlb";"pool.send_wlb_configuration";"pool.retrieve_wlb_configuration";"pool.retrieve_wlb_recommendations";"pool.send_test_post";"pool.certificate_install";"pool.certificate_uninstall";"pool.certificate_list";"pool.crl_install";"pool.crl_uninstall";"pool.crl_list";"pool.certificate_sync";"pool.enable_redo_log";"pool.disable_redo_log";"pool.audit_log_append";"pool.set_vswitch_controller";"pool.test_archive_target";"pool.enable_local_storage_caching";"pool.disable_local_storage_caching";"pool.get_license_state";"pool.apply_edition";"pool.enable_ssl_legacy";"pool.disable_ssl_legacy";"pool.set_igmp_snooping_enabled";"pool.has_extension";"pool.add_to_guest_agent_config";"pool.remove_from_guest_agent_config";"pool.rotate_secret";"pool.set_https_only";"pool.get_all";"pool.get_all_records_where";"pool.get_all_records";
    "pool_patch.get_record";"pool_patch.get_by_uuid";"pool_patch.get_by_name_label";"pool_patch.get_uuid";"pool_patch.get_name_label";"pool_patch.get_name_description";"pool_patch.get_version";"pool_patch.get_size";"pool_patch.get_pool_applied";"pool_patch.get_host_patches";"pool_patch.get_after_apply_guidance";"pool_patch.get_pool_update";"pool_patch.get_other_config";"pool_patch.set_other_config";"pool_patch.add_to_other_config";"pool_patch.remove_from_other_config";"pool_patch.apply";"pool_patch.pool_apply";"pool_patch.precheck";"pool_patch.clean";"pool_patch.pool_clean";"pool_patch.destroy";"pool_patch.clean_on_host";"pool_patch.get_all";"pool_patch.get_all_records_where";"pool_patch.get_all_records";
    "pool_update.get_record";"pool_update.get_by_uuid";"pool_update.get_by_name_label";"pool_update.get_uuid";"pool_update.get_name_label";"pool_update.get_name_description";"pool_update.get_version";"pool_update.get_installation_size";"pool_update.get_key";"pool_update.get_after_apply_guidance";"pool_update.get_vdi";"pool_update.get_hosts";"pool_update.get_other_config";"pool_update.get_enforce_homogeneity";"pool_update.set_other_config";"pool_update.add_to_other_config";"pool_update.remove_from_other_config";"pool_update.introduce";"pool_update.precheck";"pool_update.apply";"pool_update.pool_apply";"pool_update.pool_clean";"pool_update.destroy";"pool_update.attach";"pool_update.detach";"pool_update.resync_host";"pool_update.get_all";"pool_update.get_all_records_where";"pool_update.get_all_records";
    "VM.get_record";"VM.get_by_uuid";"VM.create";"VM.destroy";"VM.get_by_name_label";"VM.get_uuid";"VM.get_allowed_operations";"VM.get_current_operations";"VM.get_name_label";"VM.get_name_description";"VM.get_power_state";"VM.get_user_version";"VM.get_is_a_template";"VM.get_is_default_template";"VM.get_suspend_VDI";"VM.get_resident_on";"VM.get_scheduled_to_be_resident_on";"VM.get_affinity";"VM.get_memory_overhead";"VM.get_memory_target";"VM.get_memory_static_max";"VM.get_memory_dynamic_max";"VM.get_memory_dynamic_min";"VM.get_memory_static_min";"VM.get_VCPUs_params";"VM.get_VCPUs_max";"VM.get_VCPUs_at_startup";"VM.get_actions_after_shutdown";"VM.get_actions_after_reboot";"VM.get_actions_after_crash";"VM.get_consoles";"VM.get_VIFs";"VM.get_VBDs";"VM.get_VUSBs";"VM.get_crash_dumps";"VM.get_VTPMs";"VM.get_PV_bootloader";"VM.get_PV_kernel";"VM.get_PV_ramdisk";"VM.get_PV_args";"VM.get_PV_bootloader_args";"VM.get_PV_legacy_args";"VM.get_HVM_boot_policy";"VM.get_HVM_boot_params";"VM.get_HVM_shadow_multiplier";"VM.get_platform";"VM.get_PCI_bus";"VM.get_other_config";"VM.get_domid";"VM.get_domarch";"VM.get_last_boot_CPU_flags";"VM.get_is_control_domain";"VM.get_metrics";"VM.get_guest_metrics";"VM.get_last_booted_record";"VM.get_recommendations";"VM.get_xenstore_data";"VM.get_ha_always_run";"VM.get_ha_restart_priority";"VM.get_is_a_snapshot";"VM.get_snapshot_of";"VM.get_snapshots";"VM.get_snapshot_time";"VM.get_transportable_snapshot_id";"VM.get_blobs";"VM.get_tags";"VM.get_blocked_operations";"VM.get_snapshot_info";"VM.get_snapshot_metadata";"VM.get_parent";"VM.get_children";"VM.get_bios_strings";"VM.get_protection_policy";"VM.get_is_snapshot_from_vmpp";"VM.get_snapshot_schedule";"VM.get_is_vmss_snapshot";"VM.get_appliance";"VM.get_start_delay";"VM.get_shutdown_delay";"VM.get_order";"VM.get_VGPUs";"VM.get_attached_PCIs";"VM.get_suspend_SR";"VM.get_version";"VM.get_generation_id";"VM.get_hardware_platform_version";"VM.get_has_vendor_device";"VM.get_requires_reboot";"VM.get_reference_label";"VM.get_domain_type";"VM.get_NVRAM";"VM.set_name_label";"VM.set_name_description";"VM.set_user_version";"VM.set_is_a_template";"VM.set_affinity";"VM.set_VCPUs_params";"VM.add_to_VCPUs_params";"VM.remove_from_VCPUs_params";"VM.set_actions_after_shutdown";"VM.set_actions_after_reboot";"VM.set_PV_bootloader";"VM.set_PV_kernel";"VM.set_PV_ramdisk";"VM.set_PV_args";"VM.set_PV_bootloader_args";"VM.set_PV_legacy_args";"VM.set_HVM_boot_params";"VM.add_to_HVM_boot_params";"VM.remove_from_HVM_boot_params";"VM.set_platform";"VM.add_to_platform";"VM.remove_from_platform";"VM.set_PCI_bus";"VM.set_other_config";"VM.add_to_other_config";"VM.remove_from_other_config";"VM.set_recommendations";"VM.set_xenstore_data";"VM.add_to_xenstore_data";"VM.remove_from_xenstore_data";"VM.set_tags";"VM.add_tags";"VM.remove_tags";"VM.set_blocked_operations";"VM.add_to_blocked_operations";"VM.remove_from_blocked_operations";"VM.set_suspend_SR";"VM.set_hardware_platform_version";"VM.snapshot";"VM.snapshot_with_quiesce";"VM.clone";"VM.copy";"VM.revert";"VM.checkpoint";"VM.provision";"VM.start";"VM.start_on";"VM.pause";"VM.unpause";"VM.clean_shutdown";"VM.shutdown";"VM.clean_reboot";"VM.hard_shutdown";"VM.power_state_reset";"VM.hard_reboot";"VM.suspend";"VM.csvm";"VM.resume";"VM.set_is_default_template";"VM.hard_reboot_internal";"VM.resume_on";"VM.pool_migrate";"VM.pool_migrate_complete";"VM.set_VCPUs_number_live";"VM.add_to_VCPUs_params_live";"VM.set_NVRAM";"VM.add_to_NVRAM";"VM.remove_from_NVRAM";"VM.set_ha_restart_priority";"VM.set_ha_always_run";"VM.compute_memory_overhead";"VM.set_memory_dynamic_max";"VM.set_memory_dynamic_min";"VM.set_memory_dynamic_range";"VM.set_memory_static_max";"VM.set_memory_static_min";"VM.set_memory_static_range";"VM.set_memory_limits";"VM.set_memory";"VM.set_memory_target_live";"VM.wait_memory_target_live";"VM.get_cooperative";"VM.set_HVM_shadow_multiplier";"VM.set_shadow_multiplier_live";"VM.set_VCPUs_max";"VM.set_VCPUs_at_startup";"VM.send_sysrq";"VM.send_trigger";"VM.maximise_memory";"VM.migrate_send";"VM.assert_can_migrate";"VM.assert_can_migrate_sender";"VM.get_boot_record";"VM.get_data_sources";"VM.record_data_source";"VM.query_data_source";"VM.forget_data_source_archives";"VM.assert_operation_valid";"VM.update_allowed_operations";"VM.get_allowed_VBD_devices";"VM.get_allowed_VIF_devices";"VM.get_possible_hosts";"VM.assert_can_boot_here";"VM.atomic_set_resident_on";"VM.create_new_blob";"VM.s3_suspend";"VM.s3_resume";"VM.assert_agile";"VM.update_snapshot_metadata";"VM.retrieve_wlb_recommendations";"VM.set_bios_strings";"VM.copy_bios_strings";"VM.set_protection_policy";"VM.set_snapshot_schedule";"VM.set_start_delay";"VM.set_shutdown_delay";"VM.set_order";"VM.set_suspend_VDI";"VM.assert_can_be_recovered";"VM.get_SRs_required_for_recovery";"VM.recover";"VM.import_convert";"VM.set_appliance";"VM.query_services";"VM.call_plugin";"VM.set_has_vendor_device";"VM.import";"VM.set_actions_after_crash";"VM.set_domain_type";"VM.set_HVM_boot_policy";"VM.set_NVRAM_EFI_variables";"VM.get_all";"VM.get_all_records_where";"VM.get_all_records";
    "VM_metrics.get_record";"VM_metrics.get_by_uuid";"VM_metrics.get_uuid";"VM_metrics.get_memory_actual";"VM_metrics.get_VCPUs_number";"VM_metrics.get_VCPUs_utilisation";"VM_metrics.get_VCPUs_CPU";"VM_metrics.get_VCPUs_params";"VM_metrics.get_VCPUs_flags";"VM_metrics.get_state";"VM_metrics.get_start_time";"VM_metrics.get_install_time";"VM_metrics.get_last_updated";"VM_metrics.get_other_config";"VM_metrics.get_hvm";"VM_metrics.get_nested_virt";"VM_metrics.get_nomigrate";"VM_metrics.get_current_domain_type";"VM_metrics.set_other_config";"VM_metrics.add_to_other_config";"VM_metrics.remove_from_other_config";"VM_metrics.get_all";"VM_metrics.get_all_records_where";"VM_metrics.get_all_records";
    "VM_guest_metrics.get_record";"VM_guest_metrics.get_by_uuid";"VM_guest_metrics.get_uuid";"VM_guest_metrics.get_os_version";"VM_guest_metrics.get_PV_drivers_version";"VM_guest_metrics.get_PV_drivers_up_to_date";"VM_guest_metrics.get_memory";"VM_guest_metrics.get_disks";"VM_guest_metrics.get_networks";"VM_guest_metrics.get_other";"VM_guest_metrics.get_last_updated";"VM_guest_metrics.get_other_config";"VM_guest_metrics.get_live";"VM_guest_metrics.get_can_use_hotplug_vbd";"VM_guest_metrics.get_can_use_hotplug_vif";"VM_guest_metrics.get_PV_drivers_detected";"VM_guest_metrics.set_other_config";"VM_guest_metrics.add_to_other_config";"VM_guest_metrics.remove_from_other_config";"VM_guest_metrics.get_all";"VM_guest_metrics.get_all_records_where";"VM_guest_metrics.get_all_records";
    "VMPP.get_record";"VMPP.get_by_uuid";"VMPP.create";"VMPP.destroy";"VMPP.get_by_name_label";"VMPP.get_uuid";"VMPP.get_name_label";"VMPP.get_name_description";"VMPP.get_is_policy_enabled";"VMPP.get_backup_type";"VMPP.get_backup_retention_value";"VMPP.get_backup_frequency";"VMPP.get_backup_schedule";"VMPP.get_is_backup_running";"VMPP.get_backup_last_run_time";"VMPP.get_archive_target_type";"VMPP.get_archive_target_config";"VMPP.get_archive_frequency";"VMPP.get_archive_schedule";"VMPP.get_is_archive_running";"VMPP.get_archive_last_run_time";"VMPP.get_VMs";"VMPP.get_is_alarm_enabled";"VMPP.get_alarm_config";"VMPP.get_recent_alerts";"VMPP.set_name_label";"VMPP.set_name_description";"VMPP.set_is_policy_enabled";"VMPP.set_backup_type";"VMPP.protect_now";"VMPP.archive_now";"VMPP.create_alert";"VMPP.get_alerts";"VMPP.set_backup_retention_value";"VMPP.set_is_backup_running";"VMPP.set_is_archive_running";"VMPP.set_backup_frequency";"VMPP.set_backup_schedule";"VMPP.set_archive_frequency";"VMPP.set_archive_schedule";"VMPP.set_archive_target_type";"VMPP.set_archive_target_config";"VMPP.set_is_alarm_enabled";"VMPP.set_alarm_config";"VMPP.add_to_backup_schedule";"VMPP.add_to_archive_target_config";"VMPP.add_to_archive_schedule";"VMPP.add_to_alarm_config";"VMPP.remove_from_backup_schedule";"VMPP.remove_from_archive_target_config";"VMPP.remove_from_archive_schedule";"VMPP.remove_from_alarm_config";"VMPP.set_backup_last_run_time";"VMPP.set_archive_last_run_time";"VMPP.get_all";"VMPP.get_all_records_where";"VMPP.get_all_records";
    "VMSS.get_record";"VMSS.get_by_uuid";"VMSS.create";"VMSS.destroy";"VMSS.get_by_name_label";"VMSS.get_uuid";"VMSS.get_name_label";"VMSS.get_name_description";"VMSS.get_enabled";"VMSS.get_type";"VMSS.get_retained_snapshots";"VMSS.get_frequency";"VMSS.get_schedule";"VMSS.get_last_run_time";"VMSS.get_VMs";"VMSS.set_name_label";"VMSS.set_name_description";"VMSS.set_enabled";"VMSS.snapshot_now";"VMSS.set_retained_snapshots";"VMSS.set_frequency";"VMSS.set_schedule";"VMSS.add_to_schedule";"VMSS.remove_from_schedule";"VMSS.set_last_run_time";"VMSS.set_type";"VMSS.get_all";"VMSS.get_all_records_where";"VMSS.get_all_records";
    "VM_appliance.get_record";"VM_appliance.get_by_uuid";"VM_appliance.create";"VM_appliance.destroy";"VM_appliance.get_by_name_label";"VM_appliance.get_uuid";"VM_appliance.get_name_label";"VM_appliance.get_name_description";"VM_appliance.get_allowed_operations";"VM_appliance.get_current_operations";"VM_appliance.get_VMs";"VM_appliance.set_name_label";"VM_appliance.set_name_description";"VM_appliance.start";"VM_appliance.clean_shutdown";"VM_appliance.hard_shutdown";"VM_appliance.shutdown";"VM_appliance.assert_can_be_recovered";"VM_appliance.get_SRs_required_for_recovery";"VM_appliance.recover";"VM_appliance.get_all";"VM_appliance.get_all_records_where";"VM_appliance.get_all_records";
    "DR_task.get_record";"DR_task.get_by_uuid";"DR_task.get_uuid";"DR_task.get_introduced_SRs";"DR_task.create";"DR_task.destroy";"DR_task.get_all";"DR_task.get_all_records_where";"DR_task.get_all_records";
    "host.get_record";"host.get_by_uuid";"host.get_by_name_label";"host.get_uuid";"host.get_name_label";"host.get_name_description";"host.get_memory_overhead";"host.get_allowed_operations";"host.get_current_operations";"host.get_API_version_major";"host.get_API_version_minor";"host.get_API_version_vendor";"host.get_API_version_vendor_implementation";"host.get_enabled";"host.get_software_version";"host.get_other_config";"host.get_capabilities";"host.get_cpu_configuration";"host.get_sched_policy";"host.get_supported_bootloaders";"host.get_resident_VMs";"host.get_logging";"host.get_PIFs";"host.get_suspend_image_sr";"host.get_crash_dump_sr";"host.get_crashdumps";"host.get_patches";"host.get_updates";"host.get_PBDs";"host.get_host_CPUs";"host.get_cpu_info";"host.get_hostname";"host.get_address";"host.get_metrics";"host.get_license_params";"host.get_ha_statefiles";"host.get_ha_network_peers";"host.get_blobs";"host.get_tags";"host.get_external_auth_type";"host.get_external_auth_service_name";"host.get_external_auth_configuration";"host.get_edition";"host.get_license_server";"host.get_bios_strings";"host.get_power_on_mode";"host.get_power_on_config";"host.get_local_cache_sr";"host.get_chipset_info";"host.get_PCIs";"host.get_PGPUs";"host.get_PUSBs";"host.get_ssl_legacy";"host.get_guest_VCPUs_params";"host.get_display";"host.get_virtual_hardware_platform_versions";"host.get_control_domain";"host.get_updates_requiring_reboot";"host.get_features";"host.get_iscsi_iqn";"host.get_multipathing";"host.get_uefi_certificates";"host.get_certificates";"host.get_editions";"host.get_https_only";"host.set_name_label";"host.set_name_description";"host.set_other_config";"host.add_to_other_config";"host.remove_from_other_config";"host.set_logging";"host.add_to_logging";"host.remove_from_logging";"host.set_suspend_image_sr";"host.set_crash_dump_sr";"host.set_hostname";"host.set_address";"host.set_tags";"host.add_tags";"host.remove_tags";"host.set_license_server";"host.add_to_license_server";"host.remove_from_license_server";"host.set_guest_VCPUs_params";"host.add_to_guest_VCPUs_params";"host.remove_from_guest_VCPUs_params";"host.set_display";"host.disable";"host.enable";"host.shutdown";"host.reboot";"host.prepare_for_poweroff";"host.dmesg";"host.dmesg_clear";"host.get_log";"host.send_debug_keys";"host.bugreport_upload";"host.list_methods";"host.license_apply";"host.license_add";"host.license_remove";"host.create";"host.destroy";"host.power_on";"host.set_license_params";"host.emergency_ha_disable";"host.ha_disarm_fencing";"host.preconfigure_ha";"host.ha_join_liveset";"host.ha_disable_failover_decisions";"host.ha_wait_for_shutdown_via_statefile";"host.ha_stop_daemon";"host.ha_release_resources";"host.ha_xapi_healthcheck";"host.local_assert_healthy";"host.request_backup";"host.request_config_file_sync";"host.propose_new_master";"host.commit_new_master";"host.abort_new_master";"host.get_data_sources";"host.record_data_source";"host.query_data_source";"host.forget_data_source_archives";"host.assert_can_evacuate";"host.get_vms_which_prevent_evacuation";"host.get_uncooperative_resident_VMs";"host.get_uncooperative_domains";"host.evacuate";"host.signal_networking_change";"host.notify";"host.syslog_reconfigure";"host.management_reconfigure";"host.local_management_reconfigure";"host.management_disable";"host.get_management_interface";"host.get_system_status_capabilities";"host.get_diagnostic_timing_stats";"host.restart_agent";"host.shutdown_agent";"host.set_hostname_live";"host.is_in_emergency_mode";"host.compute_free_memory";"host.compute_memory_overhead";"host.tickle_heartbeat";"host.sync_data";"host.backup_rrds";"host.create_new_blob";"host.call_plugin";"host.has_extension";"host.call_extension";"host.get_servertime";"host.get_server_localtime";"host.enable_binary_storage";"host.disable_binary_storage";"host.enable_external_auth";"host.disable_external_auth";"host.retrieve_wlb_evacuate_recommendations";"host.certificate_install";"host.certificate_uninstall";"host.certificate_list";"host.crl_install";"host.crl_uninstall";"host.crl_list";"host.certificate_sync";"host.get_server_certificate";"host.install_server_certificate";"host.emergency_reset_server_certificate";"host.update_pool_secret";"host.update_master";"host.attach_static_vdis";"host.detach_static_vdis";"host.set_localdb_key";"host.apply_edition";"host.refresh_pack_info";"host.set_power_on_mode";"host.set_cpu_features";"host.reset_cpu_features";"host.reset_networking";"host.enable_local_storage_caching";"host.disable_local_storage_caching";"host.get_sm_diagnostics";"host.get_thread_diagnostics";"host.sm_dp_destroy";"host.sync_vlans";"host.sync_tunnels";"host.sync_pif_currently_attached";"host.migrate_receive";"host.declare_dead";"host.enable_display";"host.disable_display";"host.set_ssl_legacy";"host.apply_guest_agent_config";"host.mxgpu_vf_setup";"host.nvidia_vf_setup";"host.allocate_resources_for_vm";"host.set_iscsi_iqn";"host.set_multipathing";"host.set_uefi_certificates";"host.notify_accept_new_pool_secret";"host.notify_send_new_pool_secret";"host.cleanup_pool_secret";"host.set_https_only";"host.set_sched_gran";"host.get_sched_gran";"host.get_all";"host.get_all_records_where";"host.get_all_records";
    "host_crashdump.get_record";"host_crashdump.get_by_uuid";"host_crashdump.get_uuid";"host_crashdump.get_host";"host_crashdump.get_timestamp";"host_crashdump.get_size";"host_crashdump.get_other_config";"host_crashdump.set_other_config";"host_crashdump.add_to_other_config";"host_crashdump.remove_from_other_config";"host_crashdump.destroy";"host_crashdump.upload";"host_crashdump.get_all";"host_crashdump.get_all_records_where";"host_crashdump.get_all_records";
    "host_patch.get_record";"host_patch.get_by_uuid";"host_patch.get_by_name_label";"host_patch.get_uuid";"host_patch.get_name_label";"host_patch.get_name_description";"host_patch.get_version";"host_patch.get_host";"host_patch.get_applied";"host_patch.get_timestamp_applied";"host_patch.get_size";"host_patch.get_pool_patch";"host_patch.get_other_config";"host_patch.set_other_config";"host_patch.add_to_other_config";"host_patch.remove_from_other_config";"host_patch.destroy";"host_patch.apply";"host_patch.get_all";"host_patch.get_all_records_where";"host_patch.get_all_records";
    "host_metrics.get_record";"host_metrics.get_by_uuid";"host_metrics.get_uuid";"host_metrics.get_memory_total";"host_metrics.get_memory_free";"host_metrics.get_live";"host_metrics.get_last_updated";"host_metrics.get_other_config";"host_metrics.set_other_config";"host_metrics.add_to_other_config";"host_metrics.remove_from_other_config";"host_metrics.get_all";"host_metrics.get_all_records_where";"host_metrics.get_all_records";
    "host_cpu.get_record";"host_cpu.get_by_uuid";"host_cpu.get_uuid";"host_cpu.get_host";"host_cpu.get_number";"host_cpu.get_vendor";"host_cpu.get_speed";"host_cpu.get_modelname";"host_cpu.get_family";"host_cpu.get_model";"host_cpu.get_stepping";"host_cpu.get_flags";"host_cpu.get_features";"host_cpu.get_utilisation";"host_cpu.get_other_config";"host_cpu.set_other_config";"host_cpu.add_to_other_config";"host_cpu.remove_from_other_config";"host_cpu.get_all";"host_cpu.get_all_records_where";"host_cpu.get_all_records";
    "network.get_record";"network.get_by_uuid";"network.create";"network.destroy";"network.get_by_name_label";"network.get_uuid";"network.get_name_label";"network.get_name_description";"network.get_allowed_operations";"network.get_current_operations";"network.get_VIFs";"network.get_PIFs";"network.get_MTU";"network.get_other_config";"network.get_bridge";"network.get_managed";"network.get_blobs";"network.get_tags";"network.get_default_locking_mode";"network.get_assigned_ips";"network.get_purpose";"network.set_name_label";"network.set_name_description";"network.set_MTU";"network.set_other_config";"network.add_to_other_config";"network.remove_from_other_config";"network.set_tags";"network.add_tags";"network.remove_tags";"network.attach";"network.pool_introduce";"network.create_new_blob";"network.set_default_locking_mode";"network.attach_for_vm";"network.detach_for_vm";"network.add_purpose";"network.remove_purpose";"network.get_all";"network.get_all_records_where";"network.get_all_records";
    "VIF.get_record";"VIF.get_by_uuid";"VIF.create";"VIF.destroy";"VIF.get_uuid";"VIF.get_allowed_operations";"VIF.get_current_operations";"VIF.get_device";"VIF.get_network";"VIF.get_VM";"VIF.get_MAC";"VIF.get_MTU";"VIF.get_other_config";"VIF.get_currently_attached";"VIF.get_status_code";"VIF.get_status_detail";"VIF.get_runtime_properties";"VIF.get_qos_algorithm_type";"VIF.get_qos_algorithm_params";"VIF.get_qos_supported_algorithms";"VIF.get_metrics";"VIF.get_MAC_autogenerated";"VIF.get_locking_mode";"VIF.get_ipv4_allowed";"VIF.get_ipv6_allowed";"VIF.get_ipv4_configuration_mode";"VIF.get_ipv4_addresses";"VIF.get_ipv4_gateway";"VIF.get_ipv6_configuration_mode";"VIF.get_ipv6_addresses";"VIF.get_ipv6_gateway";"VIF.set_other_config";"VIF.add_to_other_config";"VIF.remove_from_other_config";"VIF.set_qos_algorithm_type";"VIF.set_qos_algorithm_params";"VIF.add_to_qos_algorithm_params";"VIF.remove_from_qos_algorithm_params";"VIF.plug";"VIF.unplug";"VIF.unplug_force";"VIF.move";"VIF.set_locking_mode";"VIF.set_ipv4_allowed";"VIF.add_ipv4_allowed";"VIF.remove_ipv4_allowed";"VIF.set_ipv6_allowed";"VIF.add_ipv6_allowed";"VIF.remove_ipv6_allowed";"VIF.configure_ipv4";"VIF.configure_ipv6";"VIF.get_all";"VIF.get_all_records_where";"VIF.get_all_records";
    "VIF_metrics.get_record";"VIF_metrics.get_by_uuid";"VIF_metrics.get_uuid";"VIF_metrics.get_io_read_kbs";"VIF_metrics.get_io_write_kbs";"VIF_metrics.get_last_updated";"VIF_metrics.get_other_config";"VIF_metrics.set_other_config";"VIF_metrics.add_to_other_config";"VIF_metrics.remove_from_other_config";"VIF_metrics.get_all";"VIF_metrics.get_all_records_where";"VIF_metrics.get_all_records";
    "PIF.get_record";"PIF.get_by_uuid";"PIF.get_uuid";"PIF.get_device";"PIF.get_network";"PIF.get_host";"PIF.get_MAC";"PIF.get_MTU";"PIF.get_VLAN";"PIF.get_metrics";"PIF.get_physical";"PIF.get_currently_attached";"PIF.get_ip_configuration_mode";"PIF.get_IP";"PIF.get_netmask";"PIF.get_gateway";"PIF.get_DNS";"PIF.get_bond_slave_of";"PIF.get_bond_master_of";"PIF.get_VLAN_master_of";"PIF.get_VLAN_slave_of";"PIF.get_management";"PIF.get_other_config";"PIF.get_disallow_unplug";"PIF.get_tunnel_access_PIF_of";"PIF.get_tunnel_transport_PIF_of";"PIF.get_ipv6_configuration_mode";"PIF.get_IPv6";"PIF.get_ipv6_gateway";"PIF.get_primary_address_type";"PIF.get_managed";"PIF.get_properties";"PIF.get_capabilities";"PIF.get_igmp_snooping_status";"PIF.get_sriov_physical_PIF_of";"PIF.get_sriov_logical_PIF_of";"PIF.get_PCI";"PIF.set_other_config";"PIF.add_to_other_config";"PIF.remove_from_other_config";"PIF.create_VLAN";"PIF.destroy";"PIF.reconfigure_ip";"PIF.reconfigure_ipv6";"PIF.set_primary_address_type";"PIF.scan";"PIF.introduce";"PIF.forget";"PIF.unplug";"PIF.set_disallow_unplug";"PIF.plug";"PIF.pool_introduce";"PIF.db_introduce";"PIF.db_forget";"PIF.set_property";"PIF.get_all";"PIF.get_all_records_where";"PIF.get_all_records";
    "PIF_metrics.get_record";"PIF_metrics.get_by_uuid";"PIF_metrics.get_uuid";"PIF_metrics.get_io_read_kbs";"PIF_metrics.get_io_write_kbs";"PIF_metrics.get_carrier";"PIF_metrics.get_vendor_id";"PIF_metrics.get_vendor_name";"PIF_metrics.get_device_id";"PIF_metrics.get_device_name";"PIF_metrics.get_speed";"PIF_metrics.get_duplex";"PIF_metrics.get_pci_bus_path";"PIF_metrics.get_last_updated";"PIF_metrics.get_other_config";"PIF_metrics.set_other_config";"PIF_metrics.add_to_other_config";"PIF_metrics.remove_from_other_config";"PIF_metrics.get_all";"PIF_metrics.get_all_records_where";"PIF_metrics.get_all_records";
    "Bond.get_record";"Bond.get_by_uuid";"Bond.get_uuid";"Bond.get_master";"Bond.get_slaves";"Bond.get_other_config";"Bond.get_primary_slave";"Bond.get_mode";"Bond.get_properties";"Bond.get_links_up";"Bond.get_auto_update_mac";"Bond.set_other_config";"Bond.add_to_other_config";"Bond.remove_from_other_config";"Bond.create";"Bond.destroy";"Bond.set_mode";"Bond.set_property";"Bond.get_all";"Bond.get_all_records_where";"Bond.get_all_records";
    "VLAN.get_record";"VLAN.get_by_uuid";"VLAN.get_uuid";"VLAN.get_tagged_PIF";"VLAN.get_untagged_PIF";"VLAN.get_tag";"VLAN.get_other_config";"VLAN.set_other_config";"VLAN.add_to_other_config";"VLAN.remove_from_other_config";"VLAN.pool_introduce";"VLAN.create";"VLAN.destroy";"VLAN.get_all";"VLAN.get_all_records_where";"VLAN.get_all_records";
    "SM.get_record";"SM.get_by_uuid";"SM.get_by_name_label";"SM.get_uuid";"SM.get_name_label";"SM.get_name_description";"SM.get_type";"SM.get_vendor";"SM.get_copyright";"SM.get_version";"SM.get_required_api_version";"SM.get_configuration";"SM.get_capabilities";"SM.get_features";"SM.get_other_config";"SM.get_driver_filename";"SM.get_required_cluster_stack";"SM.set_other_config";"SM.add_to_other_config";"SM.remove_from_other_config";"SM.get_all";"SM.get_all_records_where";"SM.get_all_records";
    "SR.get_record";"SR.get_by_uuid";"SR.get_by_name_label";"SR.get_uuid";"SR.get_name_label";"SR.get_name_description";"SR.get_allowed_operations";"SR.get_current_operations";"SR.get_VDIs";"SR.get_PBDs";"SR.get_virtual_allocation";"SR.get_physical_utilisation";"SR.get_physical_size";"SR.get_type";"SR.get_content_type";"SR.get_shared";"SR.get_other_config";"SR.get_tags";"SR.get_sm_config";"SR.get_blobs";"SR.get_local_cache_enabled";"SR.get_introduced_by";"SR.get_clustered";"SR.get_is_tools_sr";"SR.set_other_config";"SR.add_to_other_config";"SR.remove_from_other_config";"SR.set_tags";"SR.add_tags";"SR.remove_tags";"SR.set_sm_config";"SR.add_to_sm_config";"SR.remove_from_sm_config";"SR.create";"SR.introduce";"SR.make";"SR.destroy";"SR.forget";"SR.update";"SR.get_supported_types";"SR.scan";"SR.probe";"SR.probe_ext";"SR.set_shared";"SR.set_name_label";"SR.set_name_description";"SR.create_new_blob";"SR.set_physical_size";"SR.set_virtual_allocation";"SR.set_physical_utilisation";"SR.assert_can_host_ha_statefile";"SR.assert_supports_database_replication";"SR.enable_database_replication";"SR.disable_database_replication";"SR.get_data_sources";"SR.record_data_source";"SR.query_data_source";"SR.forget_data_source_archives";"SR.get_live_hosts";"SR.get_all";"SR.get_all_records_where";"SR.get_all_records";
    
    
    "LVHD.get_record";"LVHD.get_by_uuid";"LVHD.get_uuid";"LVHD.enable_thin_provisioning";
    "VDI.get_record";"VDI.get_by_uuid";"VDI.create";"VDI.destroy";"VDI.get_by_name_label";"VDI.get_uuid";"VDI.get_name_label";"VDI.get_name_description";"VDI.get_allowed_operations";"VDI.get_current_operations";"VDI.get_SR";"VDI.get_VBDs";"VDI.get_crash_dumps";"VDI.get_virtual_size";"VDI.get_physical_utilisation";"VDI.get_type";"VDI.get_sharable";"VDI.get_read_only";"VDI.get_other_config";"VDI.get_storage_lock";"VDI.get_location";"VDI.get_managed";"VDI.get_missing";"VDI.get_parent";"VDI.get_xenstore_data";"VDI.get_sm_config";"VDI.get_is_a_snapshot";"VDI.get_snapshot_of";"VDI.get_snapshots";"VDI.get_snapshot_time";"VDI.get_tags";"VDI.get_allow_caching";"VDI.get_on_boot";"VDI.get_metadata_of_pool";"VDI.get_metadata_latest";"VDI.get_is_tools_iso";"VDI.get_cbt_enabled";"VDI.set_other_config";"VDI.add_to_other_config";"VDI.remove_from_other_config";"VDI.set_xenstore_data";"VDI.add_to_xenstore_data";"VDI.remove_from_xenstore_data";"VDI.set_sm_config";"VDI.add_to_sm_config";"VDI.remove_from_sm_config";"VDI.set_tags";"VDI.add_tags";"VDI.remove_tags";"VDI.snapshot";"VDI.clone";"VDI.resize";"VDI.resize_online";"VDI.introduce";"VDI.pool_introduce";"VDI.db_introduce";"VDI.db_forget";"VDI.update";"VDI.copy";"VDI.force_unlock";"VDI.set_managed";"VDI.forget";"VDI.set_sharable";"VDI.set_read_only";"VDI.set_missing";"VDI.set_virtual_size";"VDI.set_physical_utilisation";"VDI.set_is_a_snapshot";"VDI.set_snapshot_of";"VDI.set_snapshot_time";"VDI.set_metadata_of_pool";"VDI.set_name_label";"VDI.set_name_description";"VDI.generate_config";"VDI.set_on_boot";"VDI.set_allow_caching";"VDI.open_database";"VDI.checksum";"VDI.read_database_pool_uuid";"VDI.pool_migrate";"VDI.enable_cbt";"VDI.disable_cbt";"VDI.set_cbt_enabled";"VDI.data_destroy";"VDI.list_changed_blocks";"VDI.get_nbd_info";"VDI.get_all";"VDI.get_all_records_where";"VDI.get_all_records";
    "VBD.get_record";"VBD.get_by_uuid";"VBD.create";"VBD.destroy";"VBD.get_uuid";"VBD.get_allowed_operations";"VBD.get_current_operations";"VBD.get_VM";"VBD.get_VDI";"VBD.get_device";"VBD.get_userdevice";"VBD.get_bootable";"VBD.get_mode";"VBD.get_type";"VBD.get_unpluggable";"VBD.get_storage_lock";"VBD.get_empty";"VBD.get_other_config";"VBD.get_currently_attached";"VBD.get_status_code";"VBD.get_status_detail";"VBD.get_runtime_properties";"VBD.get_qos_algorithm_type";"VBD.get_qos_algorithm_params";"VBD.get_qos_supported_algorithms";"VBD.get_metrics";"VBD.set_userdevice";"VBD.set_bootable";"VBD.set_type";"VBD.set_unpluggable";"VBD.set_other_config";"VBD.add_to_other_config";"VBD.remove_from_other_config";"VBD.set_qos_algorithm_type";"VBD.set_qos_algorithm_params";"VBD.add_to_qos_algorithm_params";"VBD.remove_from_qos_algorithm_params";"VBD.eject";"VBD.insert";"VBD.plug";"VBD.unplug";"VBD.unplug_force";"VBD.unplug_force_no_safety_check";"VBD.assert_attachable";"VBD.pause";"VBD.unpause";"VBD.set_mode";"VBD.get_all";"VBD.get_all_records_where";"VBD.get_all_records";
    "VBD_metrics.get_record";"VBD_metrics.get_by_uuid";"VBD_metrics.get_uuid";"VBD_metrics.get_io_read_kbs";"VBD_metrics.get_io_write_kbs";"VBD_metrics.get_last_updated";"VBD_metrics.get_other_config";"VBD_metrics.set_other_config";"VBD_metrics.add_to_other_config";"VBD_metrics.remove_from_other_config";"VBD_metrics.get_all";"VBD_metrics.get_all_records_where";"VBD_metrics.get_all_records";
    "PBD.get_record";"PBD.get_by_uuid";"PBD.create";"PBD.destroy";"PBD.get_uuid";"PBD.get_host";"PBD.get_SR";"PBD.get_device_config";"PBD.get_currently_attached";"PBD.get_other_config";"PBD.set_other_config";"PBD.add_to_other_config";"PBD.remove_from_other_config";"PBD.plug";"PBD.unplug";"PBD.set_device_config";"PBD.get_all";"PBD.get_all_records_where";"PBD.get_all_records";
    "crashdump.get_record";"crashdump.get_by_uuid";"crashdump.get_uuid";"crashdump.get_VM";"crashdump.get_VDI";"crashdump.get_other_config";"crashdump.set_other_config";"crashdump.add_to_other_config";"crashdump.remove_from_other_config";"crashdump.destroy";"crashdump.get_all";"crashdump.get_all_records_where";"crashdump.get_all_records";
    "VTPM.get_record";"VTPM.get_by_uuid";"VTPM.create";"VTPM.destroy";"VTPM.get_uuid";"VTPM.get_VM";"VTPM.get_backend";
    "console.get_record";"console.get_by_uuid";"console.create";"console.destroy";"console.get_uuid";"console.get_protocol";"console.get_location";"console.get_VM";"console.get_other_config";"console.set_other_config";"console.add_to_other_config";"console.remove_from_other_config";"console.get_all";"console.get_all_records_where";"console.get_all_records";
    "user.get_record";"user.get_by_uuid";"user.create";"user.destroy";"user.get_uuid";"user.get_short_name";"user.get_fullname";"user.get_other_config";"user.set_fullname";"user.set_other_config";"user.add_to_other_config";"user.remove_from_other_config";
    
    "blob.get_record";"blob.get_by_uuid";"blob.get_by_name_label";"blob.get_uuid";"blob.get_name_label";"blob.get_name_description";"blob.get_size";"blob.get_public";"blob.get_last_updated";"blob.get_mime_type";"blob.set_name_label";"blob.set_name_description";"blob.set_public";"blob.create";"blob.destroy";"blob.get_all";"blob.get_all_records_where";"blob.get_all_records";
    "message.create";"message.destroy";"message.get";"message.get_all";"message.get_since";"message.get_record";"message.get_by_uuid";"message.get_all_records";"message.get_all_records_where";
    "secret.get_record";"secret.get_by_uuid";"secret.create";"secret.destroy";"secret.get_uuid";"secret.get_value";"secret.get_other_config";"secret.set_value";"secret.set_other_config";"secret.add_to_other_config";"secret.remove_from_other_config";"secret.introduce";"secret.get_all";"secret.get_all_records_where";"secret.get_all_records";
    "tunnel.get_record";"tunnel.get_by_uuid";"tunnel.get_uuid";"tunnel.get_access_PIF";"tunnel.get_transport_PIF";"tunnel.get_status";"tunnel.get_other_config";"tunnel.get_protocol";"tunnel.set_status";"tunnel.add_to_status";"tunnel.remove_from_status";"tunnel.set_other_config";"tunnel.add_to_other_config";"tunnel.remove_from_other_config";"tunnel.set_protocol";"tunnel.create";"tunnel.destroy";"tunnel.get_all";"tunnel.get_all_records_where";"tunnel.get_all_records";
    "network_sriov.get_record";"network_sriov.get_by_uuid";"network_sriov.get_uuid";"network_sriov.get_physical_PIF";"network_sriov.get_logical_PIF";"network_sriov.get_requires_reboot";"network_sriov.get_configuration_mode";"network_sriov.create";"network_sriov.destroy";"network_sriov.get_remaining_capacity";"network_sriov.get_all";"network_sriov.get_all_records_where";"network_sriov.get_all_records";
    "PCI.get_record";"PCI.get_by_uuid";"PCI.get_uuid";"PCI.get_class_name";"PCI.get_vendor_name";"PCI.get_device_name";"PCI.get_host";"PCI.get_pci_id";"PCI.get_dependencies";"PCI.get_other_config";"PCI.get_subsystem_vendor_name";"PCI.get_subsystem_device_name";"PCI.get_driver_name";"PCI.set_other_config";"PCI.add_to_other_config";"PCI.remove_from_other_config";"PCI.get_all";"PCI.get_all_records_where";"PCI.get_all_records";
    "PGPU.get_record";"PGPU.get_by_uuid";"PGPU.get_uuid";"PGPU.get_PCI";"PGPU.get_GPU_group";"PGPU.get_host";"PGPU.get_other_config";"PGPU.get_supported_VGPU_types";"PGPU.get_enabled_VGPU_types";"PGPU.get_resident_VGPUs";"PGPU.get_supported_VGPU_max_capacities";"PGPU.get_dom0_access";"PGPU.get_is_system_display_device";"PGPU.get_compatibility_metadata";"PGPU.set_other_config";"PGPU.add_to_other_config";"PGPU.remove_from_other_config";"PGPU.add_enabled_VGPU_types";"PGPU.remove_enabled_VGPU_types";"PGPU.set_enabled_VGPU_types";"PGPU.set_GPU_group";"PGPU.get_remaining_capacity";"PGPU.enable_dom0_access";"PGPU.disable_dom0_access";"PGPU.get_all";"PGPU.get_all_records_where";"PGPU.get_all_records";
    "GPU_group.get_record";"GPU_group.get_by_uuid";"GPU_group.get_by_name_label";"GPU_group.get_uuid";"GPU_group.get_name_label";"GPU_group.get_name_description";"GPU_group.get_PGPUs";"GPU_group.get_VGPUs";"GPU_group.get_GPU_types";"GPU_group.get_other_config";"GPU_group.get_allocation_algorithm";"GPU_group.get_supported_VGPU_types";"GPU_group.get_enabled_VGPU_types";"GPU_group.set_name_label";"GPU_group.set_name_description";"GPU_group.set_other_config";"GPU_group.add_to_other_config";"GPU_group.remove_from_other_config";"GPU_group.set_allocation_algorithm";"GPU_group.create";"GPU_group.destroy";"GPU_group.update_enabled_VGPU_types";"GPU_group.update_supported_VGPU_types";"GPU_group.get_remaining_capacity";"GPU_group.get_all";"GPU_group.get_all_records_where";"GPU_group.get_all_records";
    "VGPU.get_record";"VGPU.get_by_uuid";"VGPU.get_uuid";"VGPU.get_VM";"VGPU.get_GPU_group";"VGPU.get_device";"VGPU.get_currently_attached";"VGPU.get_other_config";"VGPU.get_type";"VGPU.get_resident_on";"VGPU.get_scheduled_to_be_resident_on";"VGPU.get_compatibility_metadata";"VGPU.get_extra_args";"VGPU.get_PCI";"VGPU.set_other_config";"VGPU.add_to_other_config";"VGPU.remove_from_other_config";"VGPU.set_extra_args";"VGPU.create";"VGPU.destroy";"VGPU.atomic_set_resident_on";"VGPU.get_all";"VGPU.get_all_records_where";"VGPU.get_all_records";
    "VGPU_type.get_record";"VGPU_type.get_by_uuid";"VGPU_type.get_uuid";"VGPU_type.get_vendor_name";"VGPU_type.get_model_name";"VGPU_type.get_framebuffer_size";"VGPU_type.get_max_heads";"VGPU_type.get_max_resolution_x";"VGPU_type.get_max_resolution_y";"VGPU_type.get_supported_on_PGPUs";"VGPU_type.get_enabled_on_PGPUs";"VGPU_type.get_VGPUs";"VGPU_type.get_supported_on_GPU_groups";"VGPU_type.get_enabled_on_GPU_groups";"VGPU_type.get_implementation";"VGPU_type.get_identifier";"VGPU_type.get_experimental";"VGPU_type.get_compatible_types_in_vm";"VGPU_type.get_all";"VGPU_type.get_all_records_where";"VGPU_type.get_all_records";
    "PVS_site.get_record";"PVS_site.get_by_uuid";"PVS_site.get_by_name_label";"PVS_site.get_uuid";"PVS_site.get_name_label";"PVS_site.get_name_description";"PVS_site.get_PVS_uuid";"PVS_site.get_cache_storage";"PVS_site.get_servers";"PVS_site.get_proxies";"PVS_site.set_name_label";"PVS_site.set_name_description";"PVS_site.introduce";"PVS_site.forget";"PVS_site.set_PVS_uuid";"PVS_site.get_all";"PVS_site.get_all_records_where";"PVS_site.get_all_records";
    "PVS_server.get_record";"PVS_server.get_by_uuid";"PVS_server.get_uuid";"PVS_server.get_addresses";"PVS_server.get_first_port";"PVS_server.get_last_port";"PVS_server.get_site";"PVS_server.introduce";"PVS_server.forget";"PVS_server.get_all";"PVS_server.get_all_records_where";"PVS_server.get_all_records";
    "PVS_proxy.get_record";"PVS_proxy.get_by_uuid";"PVS_proxy.get_uuid";"PVS_proxy.get_site";"PVS_proxy.get_VIF";"PVS_proxy.get_currently_attached";"PVS_proxy.get_status";"PVS_proxy.create";"PVS_proxy.destroy";"PVS_proxy.get_all";"PVS_proxy.get_all_records_where";"PVS_proxy.get_all_records";
    "PVS_cache_storage.get_record";"PVS_cache_storage.get_by_uuid";"PVS_cache_storage.create";"PVS_cache_storage.destroy";"PVS_cache_storage.get_uuid";"PVS_cache_storage.get_host";"PVS_cache_storage.get_SR";"PVS_cache_storage.get_site";"PVS_cache_storage.get_size";"PVS_cache_storage.get_VDI";"PVS_cache_storage.get_all";"PVS_cache_storage.get_all_records_where";"PVS_cache_storage.get_all_records";
    "Feature.get_record";"Feature.get_by_uuid";"Feature.get_by_name_label";"Feature.get_uuid";"Feature.get_name_label";"Feature.get_name_description";"Feature.get_enabled";"Feature.get_experimental";"Feature.get_version";"Feature.get_host";"Feature.get_all";"Feature.get_all_records_where";"Feature.get_all_records";
    "SDN_controller.get_record";"SDN_controller.get_by_uuid";"SDN_controller.get_uuid";"SDN_controller.get_protocol";"SDN_controller.get_address";"SDN_controller.get_port";"SDN_controller.introduce";"SDN_controller.forget";"SDN_controller.get_all";"SDN_controller.get_all_records_where";"SDN_controller.get_all_records";
    
    "PUSB.get_record";"PUSB.get_by_uuid";"PUSB.get_uuid";"PUSB.get_USB_group";"PUSB.get_host";"PUSB.get_path";"PUSB.get_vendor_id";"PUSB.get_vendor_desc";"PUSB.get_product_id";"PUSB.get_product_desc";"PUSB.get_serial";"PUSB.get_version";"PUSB.get_description";"PUSB.get_passthrough_enabled";"PUSB.get_other_config";"PUSB.get_speed";"PUSB.set_other_config";"PUSB.add_to_other_config";"PUSB.remove_from_other_config";"PUSB.scan";"PUSB.set_passthrough_enabled";"PUSB.get_all";"PUSB.get_all_records_where";"PUSB.get_all_records";
    "USB_group.get_record";"USB_group.get_by_uuid";"USB_group.get_by_name_label";"USB_group.get_uuid";"USB_group.get_name_label";"USB_group.get_name_description";"USB_group.get_PUSBs";"USB_group.get_VUSBs";"USB_group.get_other_config";"USB_group.set_name_label";"USB_group.set_name_description";"USB_group.set_other_config";"USB_group.add_to_other_config";"USB_group.remove_from_other_config";"USB_group.create";"USB_group.destroy";"USB_group.get_all";"USB_group.get_all_records_where";"USB_group.get_all_records";
    "VUSB.get_record";"VUSB.get_by_uuid";"VUSB.get_uuid";"VUSB.get_allowed_operations";"VUSB.get_current_operations";"VUSB.get_VM";"VUSB.get_USB_group";"VUSB.get_other_config";"VUSB.get_currently_attached";"VUSB.set_other_config";"VUSB.add_to_other_config";"VUSB.remove_from_other_config";"VUSB.create";"VUSB.unplug";"VUSB.destroy";"VUSB.get_all";"VUSB.get_all_records_where";"VUSB.get_all_records";
    "Cluster.get_record";"Cluster.get_by_uuid";"Cluster.get_uuid";"Cluster.get_cluster_hosts";"Cluster.get_pending_forget";"Cluster.get_cluster_token";"Cluster.get_cluster_stack";"Cluster.get_allowed_operations";"Cluster.get_current_operations";"Cluster.get_pool_auto_join";"Cluster.get_token_timeout";"Cluster.get_token_timeout_coefficient";"Cluster.get_cluster_config";"Cluster.get_other_config";"Cluster.set_other_config";"Cluster.add_to_other_config";"Cluster.remove_from_other_config";"Cluster.create";"Cluster.destroy";"Cluster.get_network";"Cluster.pool_create";"Cluster.pool_force_destroy";"Cluster.pool_destroy";"Cluster.pool_resync";"Cluster.get_all";"Cluster.get_all_records_where";"Cluster.get_all_records";
    "Cluster_host.get_record";"Cluster_host.get_by_uuid";"Cluster_host.get_uuid";"Cluster_host.get_cluster";"Cluster_host.get_host";"Cluster_host.get_enabled";"Cluster_host.get_PIF";"Cluster_host.get_joined";"Cluster_host.get_allowed_operations";"Cluster_host.get_current_operations";"Cluster_host.get_other_config";"Cluster_host.create";"Cluster_host.destroy";"Cluster_host.enable";"Cluster_host.force_destroy";"Cluster_host.forget";"Cluster_host.disable";"Cluster_host.get_all";"Cluster_host.get_all_records_where";"Cluster_host.get_all_records";
    "Certificate.get_record";"Certificate.get_by_uuid";"Certificate.get_uuid";"Certificate.get_host";"Certificate.get_not_before";"Certificate.get_not_after";"Certificate.get_fingerprint";"Certificate.get_all";"Certificate.get_all_records_where";"Certificate.get_all_records";
    "Diagnostics.gc_compact";"Diagnostics.gc_stats";"Diagnostics.db_stats";"Diagnostics.network_stats";
     ])
    | func -> 
      if (try Scanf.sscanf func "system.isAlive:%s" (fun _ -> true) with _ -> false)
      then Rpc.success (List.hd __params)
      else begin
        if (try Scanf.sscanf func "unknown-message-%s" (fun _ -> false) with _ -> true)
        then D.debug "This is not a built-in rpc \"%s\"" __call;
        begin match __params with
        | session_id_rpc :: _->
          let session_id = ref_session_of_rpc session_id_rpc in
          Session_check.check false session_id;
          (* based on the Host.call_extension call *)
          let call_rpc = Rpc.String __call in 
          let arg_names_values =
            [("session_id", session_id_rpc); (__call, call_rpc)]
          in
          let key_names = [] in
          let rbac __context fn = Rbac.check session_id "Host.call_extension" ~args:arg_names_values ~keys:key_names ~__context ~fn in
          Server_helpers.forward_extension ~__context rbac { call with Rpc.name = __call }
        | _ ->
          Server_helpers.unknown_rpc_failure func 
        end
      end
    )))

end

